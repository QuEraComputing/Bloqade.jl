<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>3-Level Support and Quantum Gates · Bloqade.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://QuEraComputing.github.io/Bloqade.jl/3-level/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Bloqade.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Bloqade.jl logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../julia/">The Julia Programming Language</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../lattices/">Lattices</a></li><li><a class="tocitem" href="../waveform/">Waveforms</a></li><li><a class="tocitem" href="../hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../registers/">Registers and Observables</a></li><li><a class="tocitem" href="../emulation/">Emulation</a></li><li><a class="tocitem" href="../subspace/">Working with Subspace</a></li><li><a class="tocitem" href="../units/">Working with Units</a></li><li><a class="tocitem" href="../mis/">Maximum Independent Set</a></li><li><a class="tocitem" href="../cuda/">GPU Acceleration</a></li><li class="is-active"><a class="tocitem" href>3-Level Support and Quantum Gates</a><ul class="internal"><li><a class="tocitem" href="#Interface-for-the-3-level-Hamiltonian"><span>Interface for the 3-level Hamiltonian</span></a></li><li><a class="tocitem" href="#Pulse-sequences-and-quantum-gates"><span>Pulse sequences and quantum gates</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../schema/">Interacting with Neutral Atom Hardware</a></li><li><a class="tocitem" href="../capabilities/">Hardware Capabilities</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/1.blockade/main/">Rydberg Blockade</a></li><li><a class="tocitem" href="../tutorials/2.adiabatic/main/">Adiabatic Evolution</a></li><li><a class="tocitem" href="../tutorials/3.quantum-scar/main/">Quantum Scar</a></li><li><a class="tocitem" href="../tutorials/4.LGT/main/">Simulation of lattice gauge theory with Rydberg atoms</a></li><li><a class="tocitem" href="../tutorials/5.MIS/main/">The Maximum Independent Set Problem</a></li><li><a class="tocitem" href="../tutorials/6.MWIS/main/">Maximum Weight Independent Set</a></li><li><a class="tocitem" href="../tutorials/7.QMC/main/">Quantum Monte Carlo Method</a></li></ul></li><li><a class="tocitem" href="../contrib/">Contributing to Bloqade</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>3-Level Support and Quantum Gates</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>3-Level Support and Quantum Gates</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuEraComputing/Bloqade.jl/blob/master/docs/src/3-level.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Hamiltonian-in-a-3-level-system"><a class="docs-heading-anchor" href="#Hamiltonian-in-a-3-level-system">Hamiltonian in a 3-level system</a><a id="Hamiltonian-in-a-3-level-system-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian-in-a-3-level-system" title="Permalink"></a></h1><p>The Hamiltonian in a 3-level system is similar to a 2-level system. It also  consists of Rabi terms, detuning terms, and Rydberg interaction between  atoms but with more levels. The convention we used for a 3-level system  Hamiltonian is </p><p class="math-container">\[i \hbar \dfrac{\partial}{\partial t} | \psi \rangle = \hat{\mathcal{H}}(t) | \psi \rangle,  \\

\begin{aligned} 
    \frac{\mathcal{H}(t)}{\hbar} = &amp; \sum_i \frac{\Omega_i^{\mathrm{hf}}(t)}{2}\left(e^{i \phi_i^{\mathrm{hf}}(t)}|0_i\rangle\langle 1_i|+e^{-i \phi_i^{\mathrm{hf}}(t)}| 1_i\rangle\langle 0_i|\right)-\sum_i \Delta_i^{\mathrm{hf}}(t)|1_i\rangle\langle 1_i| \\ 
    &amp; +\sum_i \frac{\Omega_i^{\mathrm{r}}(t)}{2}\left(e^{i \phi_i^{\mathrm{r}}(t)}|1_i\rangle\langle r_i|+e^{-i \phi_i^{\mathrm{r}}(t)}| r_i\rangle\langle 1_i|\right)-\sum_i\left[\Delta_i^{\mathrm{hf}}(t)+\Delta_i^{\mathrm{r}}(t)\right]\left|r_i\right\rangle\left\langle r_i\right| \\ 
    &amp; +\sum_{i&lt;j} V_{i j}\left|r_i\right\rangle\left\langle r_i|\otimes| r_j\right\rangle\left\langle r_j\right| .
\end{aligned}\]</p><p>Here, <span>$|0\rangle$</span> and <span>$|1\rangle$</span> represent two different hyperfine levels  in a atom. And <span>$|r\rangle$</span> represent the Rydberg level we use for entangling  different atoms. There are two seperated pulses: the first one couples two  hyperfine levels <span>$|0\rangle$</span> and <span>$|1\rangle$</span> and the second couples the  hyperfine level <span>$|1\rangle$</span> and the Rydberg level <span>$|r\rangle$</span>. We use two  different superscripts <span>$\mathrm{hf}$</span> and <span>$\mathrm{r}$</span> to indicate them  respectively.</p><p>With <code>ArrayReg</code> in <code>YaoArrayRegister</code>, we use <span>$|0\rangle$</span>, <span>$|1\rangle$</span>, and <span>$|2\rangle$</span> to  represent <span>$|0\rangle$</span>, <span>$|1\rangle$</span>, and <span>$|r\rangle$</span>, respectively. </p><h2 id="Interface-for-the-3-level-Hamiltonian"><a class="docs-heading-anchor" href="#Interface-for-the-3-level-Hamiltonian">Interface for the 3-level Hamiltonian</a><a id="Interface-for-the-3-level-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-for-the-3-level-Hamiltonian" title="Permalink"></a></h2><p>The interface for defining a 3-level Rydberg Hamiltonian is <a href="#BloqadeExpr.rydberg_h_3"><code>rydberg_h_3</code></a>. It is similar as the  2-level interface <a href="../hamiltonians/#BloqadeExpr.rydberg_h"><code>rydberg_h</code></a>. The only difference is that, in 3-level you need to specify the Rabi term  <span>$(\Omega, \phi)$</span> and the detunning term <span>$(\Delta)$</span> for both hyperfine coupling  <span>$(\Omega^{\mathrm{hf}}, \phi^{\mathrm{hf}}, \Delta^{\mathrm{hf}})$</span> and rydberg coupling  <span>$(\Omega^{\mathrm{r}}, \phi^{\mathrm{r}}, \Delta^{\mathrm{r}})$</span>. And both time-dependent and site-dependent waveforms are supported for each parameter (see <a href="../hamiltonians/#Hamiltonians">Hamiltonians</a> for details about defining different waveforms).</p><h2 id="Pulse-sequences-and-quantum-gates"><a class="docs-heading-anchor" href="#Pulse-sequences-and-quantum-gates">Pulse sequences and quantum gates</a><a id="Pulse-sequences-and-quantum-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Pulse-sequences-and-quantum-gates" title="Permalink"></a></h2><p>We can use two hyperfine levels to represent a qubit. In this case  single-qubit gates can be directly obtained using hyperfine coupling in the  3-level system, and two-qubit gates can also be implemented by the coupling  between <span>$|1\rangle$</span> and <span>$|r\rangle$</span> with the assist of Rydberg interation  between different Rydberg atoms. In general, any n-qubit unitary can be  approximated by a 3-level Rydberg pulse sequence. Hence, the 3-level Rydberg  system is universal for qubit quantum computation.</p><h3 id="Single-qubit-gates"><a class="docs-heading-anchor" href="#Single-qubit-gates">Single-qubit gates</a><a id="Single-qubit-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Single-qubit-gates" title="Permalink"></a></h3><p>Here is an example for applying a Pauli <span>$X$</span> gate (acting on hyperfine levels  <span>$|0\rangle$</span> and <span>$|1\rangle$</span>) to each site. Notes that single qubit gates  could be parallelize, that is implementing the same single qubit gate on  different sites with only one pulse.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Bloqade</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = generate_sites(ChainLattice(), 5, scale=5)</code><code class="nohighlight hljs ansi" style="display:block;">5-element AtomList{1, Float64}:
 (0.0,)
 (5.0,)
 (10.0,)
 (15.0,)
 (20.0,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h = rydberg_h_3(atoms; Ω_hf = 1.0)</code><code class="nohighlight hljs ansi" style="display:block;">nqudits: 5
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n^r_i n^r_j
└─ [+] 2π ⋅ 0.0796 ⋅ ∑ σ^{x,hf}_i</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg = zero_state(5; nlevel = 3); # the initial state is an all-zero state</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; prob = KrylovEvolution(reg, 0.0:1e-2:pi, h); # an X gate is a π-pulse</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; emulate!(prob);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; measure(reg) # the final state is an all-one state</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{BitBasis.DitStr64{3, 5}}:
 11111 ₍₃₎</code></pre><h3 id="Two-qubit-gates"><a class="docs-heading-anchor" href="#Two-qubit-gates">Two-qubit gates</a><a id="Two-qubit-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Two-qubit-gates" title="Permalink"></a></h3><p>Two-qubit gates can be implemented with the assist of Rydberg interaction  between two atoms. Here we give two example of different implementation of  the CZ-gate using the 3-level Rydberg system. </p><ul><li>5-pulse CZ-gate</li><li>The Levine-Pichler gate</li></ul><p>Notes that the gate set of arbitrary single-qubit gate + CZ-gate is universal.  Hence, 3-level Rydberg system is universal for quantum computing.</p><h3 id="pulse-CZ-gate"><a class="docs-heading-anchor" href="#pulse-CZ-gate">5-pulse CZ-gate</a><a id="pulse-CZ-gate-1"></a><a class="docs-heading-anchor-permalink" href="#pulse-CZ-gate" title="Permalink"></a></h3><p>Suppose we have two atoms which are cloesed to each other so that there is  Rydberg blockade between them. And the first atom is the controlling qubit  while the second atom is the target qubit. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Bloqade</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = generate_sites(ChainLattice(), 2; scale = 4)</code><code class="nohighlight hljs ansi" style="display:block;">2-element AtomList{1, Float64}:
 (0.0,)
 (4.0,)</code></pre><p>There are 5 steps in total for the CZ-gate. </p><ol><li>Apply an X-gate (hyperfine π-pulse) on each qubit to flip <span>$|0\rangle$</span> and <span>$|1\rangle$</span></li><li>Apply an Rydberg π-pulse on the controlling qubit</li><li>Apply an Rydberg 2π-pulse on the target qubit</li><li>Apply an Rydberg π-pulse on the controlling qubit</li><li>Apply an X-gate (hyperfine π-pulse) on each qubit to flip <span>$|0\rangle$</span> and <span>$|1\rangle$</span></li></ol><p>To understand the above steps, let us consider two different cases when the  controlling qubit starts with <span>$|0\rangle$</span> and <span>$|1\rangle$</span>.</p><ul><li>If the controlling qubit starts with <span>$|0\rangle$</span>, then after step 2 it will be </li></ul><p>excited into the Rydberg state <span>$|r\rangle$</span>. Because of the Rydberg blockade, the  pulse in step 3 act trivially but a global phase -1 onto the target qubit.  This means nothing changes but a global phase -1 if controlling qubit is <span>$|0\rangle$</span>.</p><ul><li>If the controlling qubit is started with <span>$|1\rangle$</span>, then after step 2 it will </li></ul><p>become the hyperfine state <span>$|0\rangle$</span> which will not affect the pulse in step 3.  In this case, the 2π-pulse will cause a phase -1 only if the target qubit  is <span>$|1\rangle$</span> after step 2 (which means the target qubit starts with <span>$|0\rangle$</span>). This  means a Z-gate upto a global phase -1 is applied on the target qubit when  the controlling qubit is <span>$|1\rangle$</span>.</p><p>The following codes implement the above 5-steps of the CZ-gate.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Bloqade</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Yao</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = generate_sites(ChainLattice(), 2; scale = 4)</code><code class="nohighlight hljs ansi" style="display:block;">2-element AtomList{1, Float64}:
 (0.0,)
 (4.0,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; st = zeros(ComplexF64, 9); st[[1, 2, 4, 5]] .= 1/2; # [1, 2, 4, 5] are indices for hyperfine states</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg = arrayreg(st; nlevel = 3)  # initialize the state with 1/2 (|00⟩ + |01⟩ + |10⟩ + |11⟩)</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{3, ComplexF64, Array...}
    active qudits: 2/2
    nlevel: 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hs = [
           rydberg_h_3(atoms; Ω_hf = [1.0, 1.0]),  # hyperfine pulse for step 1
           rydberg_h_3(atoms; Ω_r = [1.0, 0.0]),   # Rydberg pulse for step 2
           rydberg_h_3(atoms; Ω_r = [0.0, 1.0]),   # Rydberg pulse for step 3
           rydberg_h_3(atoms; Ω_r = [1.0, 0.0]),   # Rydberg pulse for step 4
           rydberg_h_3(atoms; Ω_hf = [1.0, 1.0]),  # hyperfine pulse for step 5
       ]   # Hamiltonians for step 1-5</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{RydbergHamiltonian3}:
 nqudits: 2
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n^r_i n^r_j
└─ [+] ∑ Ω_i ⋅ σ^{x,hf}_i

 nqudits: 2
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n^r_i n^r_j
└─ [+] ∑ Ω_i ⋅ σ^{x,r}_i

 nqudits: 2
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n^r_i n^r_j
└─ [+] ∑ Ω_i ⋅ σ^{x,r}_i

 nqudits: 2
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n^r_i n^r_j
└─ [+] ∑ Ω_i ⋅ σ^{x,r}_i

 nqudits: 2
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n^r_i n^r_j
└─ [+] ∑ Ω_i ⋅ σ^{x,hf}_i</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ts = [π, π, 2π, π, π]   # pulse time for step 1-5</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 3.141592653589793
 3.141592653589793
 6.283185307179586
 3.141592653589793
 3.141592653589793</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; step = 1e-3; # Krylov time step</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i = 1:5
           prob = KrylovEvolution(reg, 0.0:step:ts[i], hs[i])
           emulate!(prob)
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; state(reg)[1, 2, 4, 5]  # equivalent to 1/2 (|00⟩ + |01⟩ + |10⟩ - |11⟩)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: BoundsError: attempt to access 9×1 Matrix{ComplexF64} at index [1, 2, 4, 5]</code></pre><h4 id="The-Levine-Pichler-gate"><a class="docs-heading-anchor" href="#The-Levine-Pichler-gate">The Levine-Pichler gate</a><a id="The-Levine-Pichler-gate-1"></a><a class="docs-heading-anchor-permalink" href="#The-Levine-Pichler-gate" title="Permalink"></a></h4><p>A more efficient way to implementing the CZ-gate is using the  <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.123.170503">Levine-Pichler gate</a>.  Comparing to the above 5-pulse CZ-gate, the Levine-Pichler gate uses shorter  sequence and less time. </p><p>Consider two atoms which are closed to each other. If we apply a pulse that  couples <span>$|1\rangle$</span> and <span>$|r\rangle$</span> with the Rabi frequency  <span>$\Omega^\mathrm{r}$</span>, detunning <span>$\Delta^\mathrm{r}$</span>, and duration  <span>$\tau$</span>, then the dynamics of four hyperfine state are different.</p><ul><li><span>$|00\rangle$</span> will not change during the pulse</li><li><span>$|01\rangle$</span> (<span>$|10\rangle$</span>) will oscillate between <span>$|01\rangle$</span> and <span>$|0r\rangle$</span> (<span>$|10\rangle$</span> and <span>$|r0\rangle$</span>) with a frequency <span>$\Omega^\mathrm{r}$</span></li><li><span>$|11\rangle$</span> will oscillate between <span>$|11\rangle$</span> and <span>$|w\rangle = \frac{1}{2}\left( |1r\rangle + |r1\rangle \right)$</span> with a frequency <span>$\sqrt{2}\Omega^\mathrm{r}$</span> (this is an approximation when the Rydberg blockade is strong enough such that the population of <span>$|rr\rangle$</span> could be ignored)</li></ul><p>The Levine-Pichler gate consists of two global pulses. Together with a global hyperfine pulse for rotation-Z gates, we will get a CZ-gate.</p><ol><li>A global Rydberg pulse with parameters <span>$\frac{\Delta^\mathrm{r}}{\Omega^\mathrm{r}} \approx 0.377371$</span>, <span>$\phi^\mathrm{r} = 0$</span>, <span>$\Omega^\mathrm{r}\tau \approx 4.29268$</span></li><li>A global Rydberg pulse with parameters <span>$\frac{\Delta^\mathrm{r}}{\Omega^\mathrm{r}} \approx 0.377371$</span>, <span>$\phi^\mathrm{r} \approx 3.90242$</span>, <span>$\Omega^\mathrm{r}\tau \approx 4.29268$</span></li><li>A global hyperfine pulse with parameters <span>$\Delta^\mathrm{r}\tau = 2\pi - \alpha \approx 3.90242$</span>, <span>$\Omega^\mathrm{r} = \phi^\mathrm{r} = 0$</span></li></ol><p>The first pulse completes a full cycle of oscillation for <span>$|11\rangle$</span> while it  does not complete a cycle for <span>$|01\rangle$</span> and <span>$|10\rangle$</span>. The only difference  between the first and the second pulse is the parameter <span>$\phi^\mathrm{r}$</span>. This  difference causes a change of the rotation axis on the Bloch sphere, such that the  second pulse completes another full cycle of oscillation for <span>$|11\rangle$</span> while it  also brings back <span>$|01\rangle$</span> and <span>$|10\rangle$</span>. After these two pulses has a unitary representation </p><p class="math-container">\[\begin{pmatrix}
1 &amp; &amp; &amp; \\
&amp; e^{i\alpha} &amp; &amp; \\
&amp; &amp; e^{i\alpha} &amp; \\
&amp; &amp; &amp; e^{i(2\alpha-\pi)}
\end{pmatrix},\]</p><p>which is a CZ-gate with single qubit rotation gates <span>$R_Z(\alpha)$</span> on each qubit. The following picture (Fig 2 c) in <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.123.170503">the original paper</a>)  demonstrates the process of the first pulse and the second pulse. <img src="../assets/levine-pichler.png" alt/></p><p>Here are codes for the Levine-Pichler gate.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Bloqade</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Yao</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; st = zeros(ComplexF64, 9); st[[1, 2, 4, 5]] .= 1/2; # [1, 2, 4, 5] are indices for hyperfine states</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg = arrayreg(st; nlevel = 3); # initialize the state with 1/2 (|00⟩ + |01⟩ + |10⟩ + |11⟩)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = generate_sites(ChainLattice(), 2; scale = 4);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Ω_r = 1.0; ϕ_r = 3.90242; Δ_r = 0.377371*Ω_r;   # define parameters</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; τ = 4.29268/Ω_r; α = 2.38076;   # define pulse durations</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; step = 1e-3;    # Krylov step</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hs = [
           rydberg_h_3(atoms; Ω_r = Ω_r, Δ_r = Δ_r),   # global Rydberg pulse for step 1
           rydberg_h_3(atoms; Ω_r = Ω_r, ϕ_r = ϕ_r, Δ_r = Δ_r),    # global Rydberg pulse for step 2
           rydberg_h_3(atoms; Δ_hf = 1.0), # global hyperfine pulse for R_Z-gate in step 3
       ]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{RydbergHamiltonian3}:
 nqudits: 2
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n^r_i n^r_j
├─ [+] 2π ⋅ 0.0796 ⋅ ∑ σ^{x,r}_i
└─ [-] 2π ⋅ 0.0601 ⋅ ∑ n^r_i

 nqudits: 2
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n^r_i n^r_j
├─ [+] 2π ⋅ 0.0796 ⋅ ∑ e^{3.9 ⋅ im} |1⟩⟨r| + e^{-3.9 ⋅ im} |r⟩⟨1|
└─ [-] 2π ⋅ 0.0601 ⋅ ∑ n^r_i

 nqudits: 2
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n^r_i n^r_j
├─ [-] ∑ n^{hf}_i
└─ [-] ∑ n^r_i</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ts = [τ, τ, 2π - α]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 4.29268
 4.29268
 3.9024253071795862</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i = 1:3 # simulation
           prob = KrylovEvolution(reg, 0:step:ts[i], hs[i])
           emulate!(prob)
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; state(reg)[[1, 2, 4, 5]]  # desired state 1/2 (|00⟩ + |01⟩ + |10⟩ - |11⟩)</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{ComplexF64}:
   0.5000000000000684 - 3.921184545062583e-16im
     0.49999993904048 - 0.0002116027322573276im
     0.49999993904048 - 0.0002116027322573276im
 -0.49999987685455977 - 0.00033513730510885246im</code></pre><h3 id="Predefined-pulse-sequences-for-different-quantum-gates"><a class="docs-heading-anchor" href="#Predefined-pulse-sequences-for-different-quantum-gates">Predefined pulse sequences for different quantum gates</a><a id="Predefined-pulse-sequences-for-different-quantum-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Predefined-pulse-sequences-for-different-quantum-gates" title="Permalink"></a></h3><p>Instead of defining pulse sequences manually, we provide lots of predefined pulse  sequences for basic quantum gates. For more details, please refer to the package  <a href="https://github.com/QuEraComputing/Bloqade.jl/tree/master/lib/BloqadeGates"><code>BloqadeGates</code></a>.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>The 3-level Rydberg Hamiltonian:</p><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.rydberg_h_3" href="#BloqadeExpr.rydberg_h_3"><code>BloqadeExpr.rydberg_h_3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rydberg_h_3(atoms; [C=2π * 862690 * MHz*µm^6, 
    Ω_hf = nothing, ϕ_hf = nothing, Δ_hf = nothing, 
    Ω_r = nothing, ϕ_r = nothing, Δ_r = nothing])</code></pre><p>Create a 3-level Rydberg Hamiltonian</p><p class="math-container">\[\sum_{i&lt;j} \frac{C}{|x_i - x_j|^6} n^r_i n^r_j + 
\sum_{i} \left[\frac{Ω^{\mathrm{hf}}}{2} (e^{iϕ^\mathrm{hf}}|0⟩⟨1| + e^{-iϕ^\mathrm{hf}}|1⟩⟨0|) - Δ^{\mathrm{hf}} n^{1}_i + 
\frac{Ω^{\mathrm{r}}}{2} (e^{iϕ^\mathrm{r}}|1⟩⟨r| + e^{-iϕ^\mathrm{r}}|r⟩⟨1|) - (Δ^{\mathrm{hf}} + Δ^{\mathrm{r}}) n^{\mathrm{r}}_i \right]\]</p><p>shorthand for</p><pre><code class="language-julia hljs">RydInteract(C, atoms; nlevel = 3) + 
    SumOfXPhase_01(length(atoms), Ω_hf/2, ϕ_hf) - SumOfN(length(atoms), Δ_hf) +
    SumOfXPhase_1r(length(atoms), Ω_r/2, ϕ_r) - SumOfN(length(atoms), Δ_r + Δ_hf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/interface.jl#L117-L137">source</a></section></article><p>The following operators only for 3-level system are also supported by Bloqade.</p><h3 id="Single-site-operators"><a class="docs-heading-anchor" href="#Single-site-operators">Single site operators</a><a id="Single-site-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Single-site-operators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.X_01" href="#BloqadeExpr.X_01"><code>BloqadeExpr.X_01</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">X_01
OpX_01 &lt;: YaoBlocks.ConstantGate{1, 3}</code></pre><p>Pauli X operator act on |0⟩ and |1⟩ for 3-level Rydberg system.</p><p>Matrix expression:</p><p class="math-container">\[\sigma^{x,\mathrm{hf}} = 
\begin{pmatrix}
0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L152-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.X_1r" href="#BloqadeExpr.X_1r"><code>BloqadeExpr.X_1r</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">X_1r
OpX_1r &lt;: YaoBlocks.ConstantGate{1, 3}</code></pre><p>Pauli X operator act on |1⟩ and |r⟩ for 3-level Rydberg system.</p><p>Matrix expression:</p><p class="math-container">\[\sigma^{x,\mathrm{r}} = 
\begin{pmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L171-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.N_1" href="#BloqadeExpr.N_1"><code>BloqadeExpr.N_1</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">N_1
OpN_1 &lt;: YaoBlocks.ConstantGate{1, 3}</code></pre><p>Projection operator onto |1⟩ for 3-level Rydberg system.</p><p>Matrix expression:</p><p class="math-container">\[n^1 = |1⟩⟨1| = 
\begin{pmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L228-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.N_r" href="#BloqadeExpr.N_r"><code>BloqadeExpr.N_r</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">N_r
OpN_r &lt;: YaoBlocks.ConstantGate{1, 3}</code></pre><p>Projection operator onto |r⟩ for 3-level Rydberg system.</p><p>Matrix expression:</p><p class="math-container">\[n^{\mathrm{r}} = |r⟩⟨r| = 
\begin{pmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L247-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.Pu_01" href="#BloqadeExpr.Pu_01"><code>BloqadeExpr.Pu_01</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Pu_01
OpPu_01 &lt;: YaoBlocks.ConstantGate{1, 3}</code></pre><p>Matrix expression:</p><p class="math-container">\[\mathrm{Pu}^{\mathrm{hf}} = 
\begin{pmatrix}
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L266-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.Pu_1r" href="#BloqadeExpr.Pu_1r"><code>BloqadeExpr.Pu_1r</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Pu_1r
OpPu_1r &lt;: YaoBlocks.ConstantGate{1, 3}</code></pre><p>Matrix expression:</p><p class="math-container">\[\mathrm{Pu}^{\mathrm{r}} = 
\begin{pmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L284-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.Pd_01" href="#BloqadeExpr.Pd_01"><code>BloqadeExpr.Pd_01</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Pd_01
OpPd_01 &lt;: YaoBlocks.ConstantGate{1, 3}</code></pre><p>Matrix expression:</p><p class="math-container">\[\mathrm{Pd}^{\mathrm{hf}} = 
\begin{pmatrix}
0 &amp; 0 &amp; 0 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L301-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.Pd_1r" href="#BloqadeExpr.Pd_1r"><code>BloqadeExpr.Pd_1r</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Pd_1r
OpPd_1r &lt;: YaoBlocks.ConstantGate{1, 3}</code></pre><p>Matrix expression:</p><p class="math-container">\[\mathrm{Pd}^{\mathrm{r}} = 
\begin{pmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L318-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.Z_01" href="#BloqadeExpr.Z_01"><code>BloqadeExpr.Z_01</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Z_01
OpZ_01 &lt;: YaoBlocks.ConstantGate{1, 3}</code></pre><p>Pauli Z operator act on |0⟩ and |1⟩ for 3-level Rydberg system.</p><p>Matrix expression:</p><p class="math-container">\[\sigma^{z,\mathrm{hf}} = 
\begin{pmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L190-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.Z_1r" href="#BloqadeExpr.Z_1r"><code>BloqadeExpr.Z_1r</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Z_1r
OpZ_1r &lt;: YaoBlocks.ConstantGate{1, 3}</code></pre><p>Pauli Z operator act on |1⟩ and |r⟩ for 3-level Rydberg system.</p><p>Matrix expression:</p><p class="math-container">\[\sigma^{z,\mathrm{r}} = 
\begin{pmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; -1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L209-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.XPhase_01" href="#BloqadeExpr.XPhase_01"><code>BloqadeExpr.XPhase_01</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">XPhase_01{T} &lt;: PrimitiveBlock{3}</code></pre><p>XPhase operator act on |0⟩ and |1⟩ for 3-level Rydberg system.</p><p class="math-container">\[e^{ϕ ⋅ i} |0⟩⟨1| + e^{-ϕ ⋅ i} |1⟩⟨0| = 
\begin{pmatrix}
0 &amp; e^{ϕ ⋅ im} &amp; 0 \\
e^{-ϕ ⋅ im} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L71-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.XPhase_1r" href="#BloqadeExpr.XPhase_1r"><code>BloqadeExpr.XPhase_1r</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">XPhase_1r{T} &lt;: PrimitiveBlock{3}</code></pre><p>XPhase operator act on |1⟩ and |r⟩ for 3-level Rydberg system.</p><p class="math-container">\[e^{ϕ ⋅ i} |1⟩⟨r| + e^{-ϕ ⋅ i} |r⟩⟨1| = 
\begin{pmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; e^{ϕ ⋅ im} \\
0 &amp; e^{-ϕ ⋅ im} &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L89-L102">source</a></section></article><h3 id="Sum-of-operators"><a class="docs-heading-anchor" href="#Sum-of-operators">Sum of operators</a><a id="Sum-of-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Sum-of-operators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.SumOfX_01" href="#BloqadeExpr.SumOfX_01"><code>BloqadeExpr.SumOfX_01</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SumOfX_01 &lt;: AbstractTerm{3}
SumOfX_01(nsites, Ω)</code></pre><p>Term for sum of <code>X_01</code> operators.</p><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Ω σ^{x,\mathrm{hf}}_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L416-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.SumOfX_1r" href="#BloqadeExpr.SumOfX_1r"><code>BloqadeExpr.SumOfX_1r</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SumOfX_1r &lt;: AbstractTerm{3}
SumOfX_1r(nsites, Ω)</code></pre><p>Term for sum of <code>X_1r</code> operators.</p><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Ω σ^{x,\mathrm{r}}_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L440-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.SumOfXPhase_01" href="#BloqadeExpr.SumOfXPhase_01"><code>BloqadeExpr.SumOfXPhase_01</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SumOfXPhase_01 &lt;: AbstractTerm{3}
SumOfXPhase_01(nsites, Ω, ϕ)</code></pre><p>Term for sum of <code>XPhase_01</code> operators.</p><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Ω ⋅ (e^{ϕ ⋅ i} |0⟩⟨1| + e^{-ϕ ⋅ i} |1⟩⟨0|)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L510-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.SumOfXPhase_1r" href="#BloqadeExpr.SumOfXPhase_1r"><code>BloqadeExpr.SumOfXPhase_1r</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SumOfXPhase_1r &lt;: AbstractTerm{3}
SumOfXPhase_1r(nsites, Ω, ϕ)</code></pre><p>Term for sum of <code>XPhase_1r</code> operators.</p><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Ω ⋅ (e^{ϕ ⋅ i} |1⟩⟨r| + e^{-ϕ ⋅ i} |r⟩⟨1|)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L537-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.SumOfN_1" href="#BloqadeExpr.SumOfN_1"><code>BloqadeExpr.SumOfN_1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SumOfN_1 &lt;: AbstractTerm{3}
SumOfN_1(;nsites[, Δ=1])</code></pre><p>Sum of N_1 operators. </p><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Δ ⋅ n^r_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L629-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.SumOfN_r" href="#BloqadeExpr.SumOfN_r"><code>BloqadeExpr.SumOfN_r</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SumOfN_r &lt;: AbstractTerm{3}
SumOfN_1(;nsites[, Δ=1])</code></pre><p>Sum of N_r operators. </p><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Δ ⋅ n^r_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L606-L617">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.SumOfZ_01" href="#BloqadeExpr.SumOfZ_01"><code>BloqadeExpr.SumOfZ_01</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SumOfZ_01 &lt;: AbstractTerm{2}
SumOfZ_01(;nsites, Δ=1)</code></pre><p>Sum of Pauli Z_01 operators.</p><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Δ ⋅ σ^{z,\mathrm{hf}}_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L691-L702">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.SumOfZ_1r" href="#BloqadeExpr.SumOfZ_1r"><code>BloqadeExpr.SumOfZ_1r</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SumOfZ_1r &lt;: AbstractTerm{2}
SumOfZ_1r(;nsites, Δ=1)</code></pre><p>Sum of Pauli Z_1r operators.</p><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Δ ⋅ σ^{z,\mathrm{r}}_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/99d0c71cd6164d270e9e04eb793bf6c915ccbe62/lib/BloqadeExpr/src/types.jl#L714-L725">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../cuda/">« GPU Acceleration</a><a class="docs-footer-nextpage" href="../schema/">Interacting with Neutral Atom Hardware »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 25 January 2023 22:29">Wednesday 25 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
