<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Emulation · Bloqade.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://QuEraComputing.github.io/Bloqade.jl/emulation/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Bloqade.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Bloqade.jl logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../julia/">The Julia Programming Language</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../lattices/">Lattices</a></li><li><a class="tocitem" href="../waveform/">Waveforms</a></li><li><a class="tocitem" href="../hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../registers/">Registers and Observables</a></li><li class="is-active"><a class="tocitem" href>Emulation</a><ul class="internal"><li><a class="tocitem" href="#Run-ODE-based-Emulation"><span>Run ODE-based Emulation</span></a></li><li><a class="tocitem" href="#Choose-an-ODE-Solver"><span>Choose an ODE Solver</span></a></li><li><a class="tocitem" href="#Adaptive-Steps-in-ODE-Solvers"><span>Adaptive Steps in ODE Solvers</span></a></li><li><a class="tocitem" href="#Run-Krylov-based-Emulation"><span>Run Krylov-based Emulation</span></a></li><li><a class="tocitem" href="#Krylov-vs-ODE-Solvers"><span>Krylov vs ODE Solvers</span></a></li></ul></li><li><a class="tocitem" href="../subspace/">Working with Subspace</a></li><li><a class="tocitem" href="../units/">Working with Units</a></li><li><a class="tocitem" href="../mis/">Maximum Independent Set</a></li><li><a class="tocitem" href="../cuda/">GPU Acceleration</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/1.blockade/main/">Rydberg Blockade</a></li><li><a class="tocitem" href="../tutorials/2.adiabatic/main/">Adiabatic Evolution</a></li><li><a class="tocitem" href="../tutorials/3.quantum-scar/main/">Quantum Scar</a></li><li><a class="tocitem" href="../tutorials/4.LGT/main/">Simulation of lattice gauge theory with Rydberg atoms</a></li><li><a class="tocitem" href="../tutorials/5.MIS/main/">The Maximum Independent Set Problem</a></li><li><a class="tocitem" href="../tutorials/6.MWIS/main/">Maximum Weight Independent Set</a></li></ul></li><li><a class="tocitem" href="../contrib/">Contributing to Bloqade</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Emulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Emulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuEraComputing/Bloqade.jl/blob/master/docs/src/emulation.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="emulation"><a class="docs-heading-anchor" href="#emulation">Emulation of the Quantum Dynamics</a><a id="emulation-1"></a><a class="docs-heading-anchor-permalink" href="#emulation" title="Permalink"></a></h1><p>After we create the Rydberg Hamiltonian and the register for storing the quantum information, we can  simulate the quantum many-body dynamics. The coherent dynamics of the system is governed by the Schrödinger equation. The emulation interface of Bloqade is designed in a   define-and-run style.  With Bloqade, we have two major types of emulation:</p><ul><li>ODE-solver based emulation for most of the problems.</li><li>Krylov based emulation for piecewise constant problems or QAOA-like problem.</li></ul><h3 id="Define-the-ODE-Emulation-Problem"><a class="docs-heading-anchor" href="#Define-the-ODE-Emulation-Problem">Define the ODE Emulation Problem</a><a id="Define-the-ODE-Emulation-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-ODE-Emulation-Problem" title="Permalink"></a></h3><p>ODE solvers are the major backend we use for most of the exact quantum  dynamics simulation. The ODE solvers for Bloqade are powered by the <a href="https://diffeq.sciml.ai/">DiffEq.jl package</a>.</p><p>Bloqade provides a special problem type <a href="#BloqadeODE.SchrodingerProblem"><code>SchrodingerProblem</code></a> that supports most of the  <a href="https://diffeq.sciml.ai/stable/basics/integrator/">integrator interface</a> of <code>DiffEq</code>, and most of <a href="https://diffeq.sciml.ai/stable/basics/common_solver_opts/">the solver options</a>. Here, we introduce some common use cases of the integrator and solver options. For more advanced usage of the solvers, please refer to the above link.</p><article class="docstring"><header><a class="docstring-binding" id="BloqadeODE.SchrodingerProblem" href="#BloqadeODE.SchrodingerProblem"><code>BloqadeODE.SchrodingerProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SchrodingerProblem
SchrodingerProblem(reg, tspan, hamiltonian; kw...)</code></pre><p>Define a Schrodinger equation problem that uses ODE solver from <code>OrdinaryDiffEq</code> to solve the dynamics.</p><p><strong>Arguments</strong></p><ul><li><code>register</code>: required, the evolution problem register, can be a <a href="../registers/#YaoSubspaceArrayReg.SubspaceArrayReg"><code>SubspaceArrayReg</code></a> or an <code>ArrayReg</code>   from <code>Yao</code>.</li><li><code>tspan</code>: required, a <code>(start, stop)</code> tuple or a single number <code>t</code>, the single value form <code>t</code> is equivalent   to <code>(zero(t), t)</code>.</li><li><code>hamiltonian</code>: required, the evolution hamiltonian, can be created via <a href="../hamiltonians/#BloqadeExpr.rydberg_h"><code>rydberg_h</code></a>.</li></ul><p><strong>Common Keyword Arguments</strong></p><ul><li><code>algo</code>: optional, algorithm to use, this only works for the <code>emulate!</code> interface.   for <code>solve</code> or integrator interface, one will need to specify the algorithm explicitly.</li><li><code>progress</code>: print progress bar or not, this may effect the performance when problem scale is small, default is <code>true</code>.</li><li><code>progress_steps</code>: steps to update the progress bar, default is <code>5</code>.</li><li><code>reltol</code>: relative tolerance, default is 1e-8.</li><li><code>abstol</code>: absolute tolerance, default is 1e-8.</li></ul><p><strong>Further References</strong></p><p>For more ODE options, please refer to <a href="https://diffeq.sciml.ai/stable/basics/common_solver_opts/">Common Solver Options</a>. The <code>SchrodingerProblem</code> type supports most of the standard DiffEq problem interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/6372cc76e13aa10aafc3ec7f830c07757b746d7d/lib/BloqadeODE/src/problem.jl#L35-L63">source</a></section></article><h2 id="Run-ODE-based-Emulation"><a class="docs-heading-anchor" href="#Run-ODE-based-Emulation">Run ODE-based Emulation</a><a id="Run-ODE-based-Emulation-1"></a><a class="docs-heading-anchor-permalink" href="#Run-ODE-based-Emulation" title="Permalink"></a></h2><p>To run the emulation, you need to define the exact evolution and solver you would like to run with via <a href="#BloqadeODE.SchrodingerProblem"><code>BloqadeODE.SchrodingerProblem</code></a>, and then feed the corresponding object to the <code>emulate!</code> function:</p><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.emulate!" href="#BloqadeExpr.emulate!"><code>BloqadeExpr.emulate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">emulate!(prob)</code></pre><p>Run emulation of a given problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/6372cc76e13aa10aafc3ec7f830c07757b746d7d/lib/BloqadeExpr/src/interface.jl#L8-L12">source</a></section></article><p>For example, we can simulate the quantum dynamics of a time-dependent Hamiltonian by the following codes:</p><pre><code class="language-julia hljs">using Bloqade
atoms = generate_sites(SquareLattice(), 3, 3; scale=5.1);
clocks = [0.0, 0.1, 0.2, 0.3, 0.4];
wf = piecewise_constant(;clocks, values=2π*[1.0, 2.0, 3.0, 4.0]);
h = rydberg_h(atoms; Δ=2π*2.0, Ω=wf); # create the Hamiltonian
reg = zero_state(length(atoms)); # create fullspace register
ev = SchrodingerProblem(reg, 0.3, h) # the second input is the total time
emulate!(ev)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SchrodingerProblem:
  register info:
    type: ArrayReg{2, ComplexF64, Matrix{ComplexF64}}
    storage size: 8 bytes

  time span (μs): (0.0, 0.3)

  equation: 
    storage size: 76.016 KiB
    expression:
nqubits: 9
+
├─ [+] ∑ 2π ⋅ 8.627e6.0/|r_i-r_j|^6 n_i n_j
├─ [+] Ω(t) ⋅ ∑ σ^x_i
└─ [-] 2π ⋅ 2.0 ⋅ ∑ n_i


  options:
    save_everystep: false
    save_start: false
    save_on: false
    dense: false
</code></pre><p>With <code>emulate!</code>, the quantum state stored in <code>reg</code> has been updated to the state after the time evolution. </p><p>If you want to do operations during the real-time evolution, such as measuring observables, you can instead using the integrator interface with <code>for</code> loop and with <code>TimeChoiceIterator</code> on your desired clocks, e.g.:</p><pre><code class="language-julia hljs">integrator = init(ev, Vern8())
for _ in TimeChoiceIterator(integrator, [0.1, 0.25])
    ev.reg # state at selected time
    @show measure(ev.reg)[] # measure the state at each time
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(measure(ev.reg))[] = 000001000 ₍₂₎
(measure(ev.reg))[] = 010100001 ₍₂₎</code></pre><p>You can use any function on the <code>reg</code> object.  For calculating observables,  please see the <a href="../registers/#observables">Registers and Observables</a> section.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Remember to make sure your operation does not mutate your state so that it won&#39;t affect the evolution itself, since the entire time evolution is simulated by mutating the state vector stored in <code>reg</code>. Thus, do not use any function that has a <code>!</code> in its name on the register <code>info.reg</code> unless you are certain about what you are doing.</p></div></div><h2 id="Choose-an-ODE-Solver"><a class="docs-heading-anchor" href="#Choose-an-ODE-Solver">Choose an ODE Solver</a><a id="Choose-an-ODE-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Choose-an-ODE-Solver" title="Permalink"></a></h2><p>One of the most powerful tool of the Julia ecosystem is the DiffEq ecosystem that implements many different solvers. These solvers have different advantages and trade-offs. Since simulating a quantum many-body Schrödinger equation has some special properties compared to a general ODE problem, we will discuss some general heuristics in this section on how to choose a good ODE solver and how to check if your simulation converges. Because many-body Schrödinger equation&#39;s stiffness is unknown, we will not be using stiff problem solvers, but instead using non-stiff problem algorithms or auto-switching algorithms.</p><p>For most of the cases, one can use the <code>VCABM</code> solver for a large system simulation. However, this method requires more memory, which can be a bottleneck with GPUs.</p><p>The <code>Vern</code> family is another set of solvers that is good for many-body Schrödinger equation, such as <code>Vern6</code>, <code>Vern7</code>, and <code>Vern8</code>. They also have relatively good memory usage when utilize GPUs.</p><p>For a more detailed list of solvers, please refer to <a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/#Full-List-of-Methods">DiffEq:Full list of solvers</a>. For more detailed explanation on ODE solvers, please refer to <a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/#Recommended-Methods">DiffEq:Recommended Methods</a>.</p><p>If you are familiar with MATLAB or Python, you may wish to compare the same methods that you use in MATLAB or Python; you can find the corresponding solvers in Julia in <a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/#Translations-from-MATLAB/Python/R">DiffEq:Translation from MATLAB/Python/R</a>.</p><h2 id="Adaptive-Steps-in-ODE-Solvers"><a class="docs-heading-anchor" href="#Adaptive-Steps-in-ODE-Solvers">Adaptive Steps in ODE Solvers</a><a id="Adaptive-Steps-in-ODE-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Steps-in-ODE-Solvers" title="Permalink"></a></h2><p>Our ODE solvers use adaptive steps by default. It provides a significant speedup compared to standard fixed-step methods (see <a href="#">our benchmark here</a>). However, if one expects to retrieve the results during the time evolution, e.g., plotting Rydberg densities with the evolution time, fixed-step methods are sometimes  preferred.</p><p>More specifically, when the adaptive steps are turned on, the time steps might be large, but if one is interested in measuring some observables in smaller time steps, then the adaptive step  method will not produce accurate results for the finer time step, but instead output results at the specific adaptive steps.  In this situation, it&#39;s better to use fixed-step methods at the clocks where the observables are measured.</p><p>One can use the code below to turn off the adaptive steps when setting up the <a href="#BloqadeODE.SchrodingerProblem"><code>SchrodingerProblem</code></a>:</p><pre><code class="language-julia hljs">atoms = generate_sites(SquareLattice(), 3, 3; scale=5.1);
h = rydberg_h(atoms; Δ=2π*2.0, Ω= 2π*1.0); # create the Hamiltonian
reg = zero_state(length(atoms));
prob = SchrodingerProblem(reg, 3.0, h, adaptive = false, dt=1e-3);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SchrodingerProblem:
  register info:
    type: ArrayReg{2, ComplexF64, Matrix{ComplexF64}}
    storage size: 8 bytes

  time span (μs): (0.0, 3.0)

  equation: 
    storage size: 83.992 KiB
    expression:
nqubits: 9
+
├─ [+] ∑ 2π ⋅ 8.627e6.0/|r_i-r_j|^6 n_i n_j
├─ [+] 2π ⋅ 0.5 ⋅ ∑ σ^x_i
└─ [-] 2π ⋅ 2.0 ⋅ ∑ n_i


  options:
    dt: 0.001
    adaptive: false
    save_everystep: false
    save_start: false
    save_on: false
    dense: false
</code></pre><p>Here, we&#39;ve specified the fixed time step as <code>dt = 1e-3</code>. If one only expects the final state of the evolution, or the intervals between each chosen clock is much larger than the maximum step size, then adaptive steps are preferred.</p><h3 id="Define-the-Krylov-Emulation-Problem"><a class="docs-heading-anchor" href="#Define-the-Krylov-Emulation-Problem">Define the Krylov Emulation Problem</a><a id="Define-the-Krylov-Emulation-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-Krylov-Emulation-Problem" title="Permalink"></a></h3><p>The Krylov-based method expects time-independent Hamiltonians. One can define such a time evolution via <a href="#BloqadeKrylov.KrylovEvolution"><code>KrylovEvolution</code></a> object.</p><article class="docstring"><header><a class="docstring-binding" id="BloqadeKrylov.KrylovEvolution" href="#BloqadeKrylov.KrylovEvolution"><code>BloqadeKrylov.KrylovEvolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct KrylovEvolution
KrylovEvolution(reg::AbstractRegister, clocks, h; kw...)</code></pre><p>Create a <code>KrylovEvolution</code> object that describes a time evolution using Krylov subspace methods.</p><p><strong>Arguments</strong></p><ul><li><code>reg</code>: a register, should be a subtype of <code>AbstractRegister</code>.</li><li><code>clocks</code>: the clocks of this time evolution at each step.</li><li><code>h</code>: a hamiltonian expression.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>progress</code>: show progress bar, default is <code>false</code>.</li><li><code>progress_name</code>: progress bar name, default is <code>&quot;emulating&quot;</code>.</li><li><code>normalize_step</code>: normalize the state every <code>normalize_step</code>.</li><li><code>normalize_finally</code>: wether normalize the state in the end of evolution, default is <code>true</code>.</li><li><code>tol</code>: tolerance of the Krylov method, default is <code>1e-7</code></li></ul><p><strong>Examples</strong></p><p>The following is the simplest way of using <code>KrylovEvolution</code> via <a href="#BloqadeExpr.emulate!"><code>emulate!</code></a>. For more advanced usage, please refer to documentation page <a href="#emulation">Emulation</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Bloqade

julia&gt; r = zero_state(5)
ArrayReg{2, ComplexF64, Array...}
    active qudits: 5/5
    nlevel: 2

julia&gt; atoms = [(i, ) for i in 1:5]
5-element Vector{Tuple{Int64}}:
 (1,)
 (2,)
 (3,)
 (4,)
 (5,)

julia&gt; h = rydberg_h(atoms; Ω=sin)
nqubits: 5
+
├─ [+] ∑ 5.42e6/|r_i-r_j|^6 n_i n_j
└─ [+] Ω(t) ⋅ ∑ σ^x_i


julia&gt; prob = KrylovEvolution(r, 0.0:1e-2:0.1, h);

julia&gt; emulate!(prob); # run the emulation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/6372cc76e13aa10aafc3ec7f830c07757b746d7d/lib/BloqadeKrylov/src/emulate.jl#L15-L69">source</a></section></article><h2 id="Run-Krylov-based-Emulation"><a class="docs-heading-anchor" href="#Run-Krylov-based-Emulation">Run Krylov-based Emulation</a><a id="Run-Krylov-based-Emulation-1"></a><a class="docs-heading-anchor-permalink" href="#Run-Krylov-based-Emulation" title="Permalink"></a></h2><p>We can run the Krylov-based emulation in a similar way using <a href="#BloqadeExpr.emulate!"><code>emulate!</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; emulate!(KrylovEvolution(reg, clocks, h))</code><code class="nohighlight hljs ansi" style="display:block;">KrylovEvolution:
  register info:
    type: ArrayReg{2, ComplexF64, Matrix{ComplexF64}}
    storage size: 8 bytes

  clocks
    start:0.0μs
     last:0.4μs

  Hamiltonian
    number of dynamic terms: 0
    storage size: 40 bytes

  Options:
    progress=false
    progress_step=1
    progress_name=&quot;emulating&quot;
    normalize_step=5
    normalize_finally=true
    tol=1.0e-7</code></pre><p>However, as its name suggests, the Krylov-based emulation is not a standard ODE problem that DiffEq  supports. Thus, it does not support the ODE problem interface, but it&#39;s more like a gate-based interface. For example, the object <code>KrylovEvolution</code> is iterable:</p><pre><code class="language-julia hljs">for (step, reg, duration) in KrylovEvolution(reg, clocks, h)
    @show step
    @show reg
    @show duration
    println(&quot;==========&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">step = 1
reg = ArrayReg{2, ComplexF64, Array...}
    active qubits: 9/9
    nlevel: 2
duration = 0.0
==========
step = 2
reg = ArrayReg{2, ComplexF64, Array...}
    active qubits: 9/9
    nlevel: 2
duration = 0.1
==========
step = 3
reg = ArrayReg{2, ComplexF64, Array...}
    active qubits: 9/9
    nlevel: 2
duration = 0.2
==========
step = 4
reg = ArrayReg{2, ComplexF64, Array...}
    active qubits: 9/9
    nlevel: 2
duration = 0.3
==========
step = 5
reg = ArrayReg{2, ComplexF64, Array...}
    active qubits: 9/9
    nlevel: 2
duration = 0.4
==========</code></pre><h2 id="Krylov-vs-ODE-Solvers"><a class="docs-heading-anchor" href="#Krylov-vs-ODE-Solvers">Krylov vs ODE Solvers</a><a id="Krylov-vs-ODE-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Krylov-vs-ODE-Solvers" title="Permalink"></a></h2><p>The <a href="#BloqadeKrylov.KrylovEvolution"><code>KrylovEvolution</code></a> uses the Krylov subspace methods to simulate the time evolution of time-independent operators <span>$\exp(i\Delta t_i H)$</span>, where <span>$\Delta t_i$</span> is the duration of time-independent Hamiltonian <span>$H$</span> at time <span>$t$</span>. This method is more efficient when the evolution itself is a discrete evolution, e.g. in QAOA and with <a href="../waveform/#BloqadeWaveforms.piecewise_constant"><code>piecewise_constant</code></a> waveforms. As for other cases, ODE solvers are usually more efficient than <a href="#BloqadeKrylov.KrylovEvolution"><code>KrylovEvolution</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../registers/">« Registers and Observables</a><a class="docs-footer-nextpage" href="../subspace/">Working with Subspace »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.21 on <span class="colophon-date" title="Saturday 23 July 2022 00:54">Saturday 23 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
