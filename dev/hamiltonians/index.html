<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hamiltonians · Bloqade.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://QuEraComputing.github.io/Bloqade.jl/hamiltonians/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Bloqade.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Bloqade.jl logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../julia/">The Julia Programming Language</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../lattices/">Lattices</a></li><li><a class="tocitem" href="../waveform/">Waveforms</a></li><li class="is-active"><a class="tocitem" href>Hamiltonians</a><ul class="internal"><li><a class="tocitem" href="#Building-Time-Independent-Hamiltonians"><span>Building Time-Independent Hamiltonians</span></a></li><li><a class="tocitem" href="#Building-Time-Dependent-Hamiltonians"><span>Building Time-Dependent Hamiltonians</span></a></li><li><a class="tocitem" href="#Building-Hamiltonians-with-Site-Dependent-Waveforms"><span>Building Hamiltonians with Site-Dependent Waveforms</span></a></li><li><a class="tocitem" href="#Hamiltonian-Expressions"><span>Hamiltonian Expressions</span></a></li><li><a class="tocitem" href="#Convert-Hamiltonians-to-Matrices"><span>Convert Hamiltonians to Matrices</span></a></li><li><a class="tocitem" href="#Diagonalization-of-the-Hamiltonian"><span>Diagonalization of the Hamiltonian</span></a></li><li><a class="tocitem" href="#Low-Level-Representation-of-the-Hamiltonian"><span>Low-Level Representation of the Hamiltonian</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../registers/">Registers and Observables</a></li><li><a class="tocitem" href="../emulation/">Emulation</a></li><li><a class="tocitem" href="../subspace/">Working with Subspace</a></li><li><a class="tocitem" href="../units/">Working with Units</a></li><li><a class="tocitem" href="../mis/">Maximum Independent Set</a></li><li><a class="tocitem" href="../cuda/">GPU Acceleration</a></li><li><a class="tocitem" href="../3-level/">3-Level Support and Quantum Gates</a></li><li><a class="tocitem" href="../schema/">Interacting with Neutral Atom Hardware</a></li><li><a class="tocitem" href="../capabilities/">Hardware Capabilities</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/1.blockade/main/">Rydberg Blockade</a></li><li><a class="tocitem" href="../tutorials/2.adiabatic/main/">Adiabatic Evolution</a></li><li><a class="tocitem" href="../tutorials/3.quantum-scar/main/">Quantum Scar</a></li><li><a class="tocitem" href="../tutorials/4.LGT/main/">Simulation of lattice gauge theory with Rydberg atoms</a></li><li><a class="tocitem" href="../tutorials/5.MIS/main/">The Maximum Independent Set Problem</a></li><li><a class="tocitem" href="../tutorials/6.MWIS/main/">Maximum Weight Independent Set</a></li><li><a class="tocitem" href="../tutorials/7.QMC/main/">Quantum Monte Carlo Method</a></li></ul></li><li><a class="tocitem" href="../contrib/">Contributing to Bloqade</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Hamiltonians</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hamiltonians</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuEraComputing/Bloqade.jl/blob/master/docs/src/hamiltonians.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Hamiltonians"><a class="docs-heading-anchor" href="#Hamiltonians">Hamiltonians</a><a id="Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians" title="Permalink"></a></h1><p>Quantum Hamiltonians encode the essential physical properties of a quantum system. For the analog mode of neutral-atom quantum computers, the quantum dynamics is governed by the Rydberg Hamiltonian <span>$\hat{\mathcal{H}}$</span>:</p><p class="math-container">\[i \hbar \dfrac{\partial}{\partial t} | \psi \rangle = \hat{\mathcal{H}}(t) | \psi \rangle,  \\

\frac{\mathcal{H}(t)}{\hbar} = \sum_j \frac{\Omega_j(t)}{2} \left( e^{i \phi_j(t) } | g_j \rangle  \langle r_j | + e^{-i \phi_j(t) } | r_j \rangle  \langle g_j | \right) - \sum_j \Delta_j(t) \hat{n}_j + \sum_{j &lt; k} V_{jk} \hat{n}_j \hat{n}_k,\]</p><p>where <span>$\Omega_j$</span>, <span>$\phi_j$</span>, and <span>$\Delta_j$</span>  denote the Rabi frequency, laser phase, and the detuning of the driving laser field on atom (qubit) <span>$j$</span> coupling the two states  <span>$| g_j \rangle$</span> (ground state) and <span>$| r_j \rangle$</span> (Rydberg state); <span>$\hat{n}_j = |r_j\rangle \langle r_j|$</span> is the number operator, and <span>$V_{jk} = C_6/|\mathbf{x}_j - \mathbf{x}_k|^6$</span> describes the Rydberg interaction (van der Waals interaction) between atoms <span>$j$</span> and <span>$k$</span> where <span>$\mathbf{x}_j$</span> denotes the position of the atom <span>$j$</span>; <span>$C_6$</span> is the Rydberg interaction constant that depends on the particular Rydberg state used. For Bloqade, the default <span>$C_6 = 862690 \times 2\pi \text{ MHz μm}^6$</span> for <span>$|r \rangle = \lvert 70S_{1/2} \rangle$</span> of the <span>$^{87}$</span>Rb atoms; <span>$\hbar$</span> is the reduced Planck&#39;s constant.</p><p>One can use the Rydberg Hamiltonian to  understand the ground state properties of the corresponding system and to generate interesting quantum dynamics.  The Rydberg Hamiltonian is generally specified by atom positions <span>$\mathbf{x}_j$</span>, Rabi frequencies <span>$\Omega_j$</span>, laser phase <span>$\phi_j$</span>, and detunings <span>$\Delta_j$</span>. In Bloqade,  we can easily create a Hamiltonian by inputting these variable parameters into the function <a href="#BloqadeExpr.rydberg_h"><code>rydberg_h</code></a>. Furthermore, by inputting waveforms for the Rabi frequency and  detuning, we can easily generate time-dependent Hamiltonians. </p><h2 id="Building-Time-Independent-Hamiltonians"><a class="docs-heading-anchor" href="#Building-Time-Independent-Hamiltonians">Building Time-Independent Hamiltonians</a><a id="Building-Time-Independent-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Building-Time-Independent-Hamiltonians" title="Permalink"></a></h2><p>To specify the Hamiltonian, we first need to specify the atom positions, which determine the Rydberg interactions strengths <span>$V_{jk}$</span> between pairs of atoms. Here, we generate a square lattice by using the code below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Bloqade</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = generate_sites(SquareLattice(), 3, 3, scale=6.3)</code><code class="nohighlight hljs ansi" style="display:block;">9-element AtomList{2, Float64}:
 (0.0, 0.0)
 (6.3, 0.0)
 (12.6, 0.0)
 (0.0, 6.3)
 (6.3, 6.3)
 (12.6, 6.3)
 (0.0, 12.6)
 (6.3, 12.6)
 (12.6, 12.6)</code></pre><p>Please refer to the <a href="../lattices/#Lattices">Lattices</a> page for more details on how to generate lattices and the relevant operations. </p><p>Then, the Hamiltonian can be simply built by inputting the generated atom positions <code>atoms</code> and by specifying the strength of the detuning <code>Δ</code>, Rabi frequency <code>Ω</code>, and laser phase <code>ϕ</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; h0 = rydberg_h(atoms; Δ=1.2*2π, Ω=1.1*2π, ϕ=2.1)</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 9
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] 2π ⋅ 0.55 ⋅ ∑ e^{2.1 ⋅ im} |0⟩⟨1| + e^{-2.1 ⋅ im} |1⟩⟨0|
└─ [-] 2π ⋅ 1.2 ⋅ ∑ n_i</code></pre><p>Note that the default value for the Rydberg interaction constant is <span>$C_6 = 2\pi \times 862690 \text{ MHz μm}^6$</span> to match the default unit used on the hardware. For more information about units, please  refer to <a href="../#Bloqade">Bloqade</a>. Instead of using the default value for <span>$C_6$</span>, the users are free to set their own values. For instance, if the users would like to have a chain lattice with nearest-neighbor atoms separated by 1 μm, and interaction strength to be a particular value, say, <span>$2\pi * 10.0^6 \text{ MHz μm}^6$</span>, it can be done with the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = generate_sites(ChainLattice(), 9, scale=1.0)</code><code class="nohighlight hljs ansi" style="display:block;">9-element AtomList{1, Float64}:
 (0.0,)
 (1.0,)
 (2.0,)
 (3.0,)
 (4.0,)
 (5.0,)
 (6.0,)
 (7.0,)
 (8.0,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h0 = rydberg_h(atoms; C=2π*10.0^6, Δ=1.2*2π, Ω=1.1*2π, ϕ=2.1)</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 9
+
├─ [+] ∑ 2π ⋅ 10.0e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] 2π ⋅ 0.55 ⋅ ∑ e^{2.1 ⋅ im} |0⟩⟨1| + e^{-2.1 ⋅ im} |1⟩⟨0|
└─ [-] 2π ⋅ 1.2 ⋅ ∑ n_i</code></pre><h2 id="Building-Time-Dependent-Hamiltonians"><a class="docs-heading-anchor" href="#Building-Time-Dependent-Hamiltonians">Building Time-Dependent Hamiltonians</a><a id="Building-Time-Dependent-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Building-Time-Dependent-Hamiltonians" title="Permalink"></a></h2><p>One can also directly use waveforms (instead of constant values of detuning, Rabi frequency, and laser phase) to build a time-dependent Hamiltonian.  First, let us again use the  <a href="../lattices/#BloqadeLattices.generate_sites"><code>generate_sites</code></a> to create a list of atom coordinates: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = generate_sites(ChainLattice(), 5, scale=5.72)</code><code class="nohighlight hljs ansi" style="display:block;">5-element AtomList{1, Float64}:
 (0.0,)
 (5.72,)
 (11.44,)
 (17.16,)
 (22.88,)</code></pre><p>Then, we generate the time-dependent pulses for <span>$\Omega$</span> and <span>$\Delta$</span> by using  <a href="../waveform/#BloqadeWaveforms.piecewise_linear"><code>piecewise_linear</code></a>. For details on how to create waveforms and the built-in functions, please refer to the page <a href="../waveform/#Waveforms">Waveforms</a>. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Ω1 = piecewise_linear(clocks=[0.0, 0.1, 2.1, 2.2], values=2π*[0.0, 6.0, 6.0, 0]);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Δ1 = piecewise_linear(clocks=[0.0, 0.6, 2.1, 2.2], values=2π*[-10.1, -10.1, 10.1, 10.1]);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>The time-dependent Hamiltonian can then be easily generated by inputting the waveforms into the function <a href="#BloqadeExpr.rydberg_h"><code>rydberg_h</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; h1 = rydberg_h(atoms; Δ=Δ1, Ω=Ω1)</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 5
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] Ω(t) ⋅ ∑ σ^x_i
└─ [-] Δ(t) ⋅ ∑ n_i</code></pre><p>By specifying the time of <code>h1</code>, we can access the Hamiltonian at a particular time, e.g.: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ht= h1 |&gt; attime(0.5)</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 5
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] 2π ⋅ 3.0 ⋅ ∑ σ^x_i
└─ [-] 2π ⋅ -10.1 ⋅ ∑ n_i</code></pre><h2 id="Building-Hamiltonians-with-Site-Dependent-Waveforms"><a class="docs-heading-anchor" href="#Building-Hamiltonians-with-Site-Dependent-Waveforms">Building Hamiltonians with Site-Dependent Waveforms</a><a id="Building-Hamiltonians-with-Site-Dependent-Waveforms-1"></a><a class="docs-heading-anchor-permalink" href="#Building-Hamiltonians-with-Site-Dependent-Waveforms" title="Permalink"></a></h2><p>In certain cases, the user may want to build a Hamiltonian that has site-dependent <span>$\Omega_j$</span>, <span>$\phi_j$</span>, and <span>$\Delta_j$</span>, which may or may not have time dependence.</p><p>For the time-independent Hamiltonian, one can for example build a Hamiltonian like: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; h0 = rydberg_h(atoms; Δ=1.2*2π*rand(length(atoms)), Ω=1.1*2π*rand(length(atoms)), ϕ=2.1)</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 5
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] ∑ Ω_i ⋅ (e^{2.1 ⋅ im} |0⟩⟨1| + e^{-2.1 ⋅ im} |1⟩⟨0|)
└─ [-] ∑ Δ_i ⋅ n_i</code></pre><p>For time-dependent Hamiltonians, here is an example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = generate_sites(ChainLattice(), 5, scale=5.72)</code><code class="nohighlight hljs ansi" style="display:block;">5-element AtomList{1, Float64}:
 (0.0,)
 (5.72,)
 (11.44,)
 (17.16,)
 (22.88,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Δ1 = map(1:length(atoms)) do idx
           Waveform(t-&gt; idx*sin(2π*t), duration = 2)
       end</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Waveform{Main.var&quot;#2#4&quot;{Int64}, Int64}}:
 Waveform(_, 2)
 Waveform(_, 2)
 Waveform(_, 2)
 Waveform(_, 2)
 Waveform(_, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h =rydberg_h(atoms; Δ=Δ1)</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 5
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
└─ [-] ∑ Δ_i ⋅ n_i</code></pre><h2 id="Hamiltonian-Expressions"><a class="docs-heading-anchor" href="#Hamiltonian-Expressions">Hamiltonian Expressions</a><a id="Hamiltonian-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian-Expressions" title="Permalink"></a></h2><p>Bloqade uses &quot;block&quot;s from <a href="https://yaoquantum.org/">Yao</a> to build symbolic hamiltonian expressions. This gives users the flexibility to define various   kinds of Hamiltonians by simply writing down the expression.</p><p>Please refer to the References section below for the types of operators supported by Bloqade.</p><p>As an example, we can explicitly add up some Hamiltonian terms to compose a new Hamiltonian, e.g.:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Bloqade</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h = 2π*1.1*SumOfX(5, 1.0) + 2π*1.2*SumOfZ(5, 1.0)</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 5
+
├─ [scale: 6.911503837897546] ∑ σ^x_i
└─ [scale: 7.5398223686155035] ∑ σ^z_i</code></pre><h2 id="Convert-Hamiltonians-to-Matrices"><a class="docs-heading-anchor" href="#Convert-Hamiltonians-to-Matrices">Convert Hamiltonians to Matrices</a><a id="Convert-Hamiltonians-to-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Convert-Hamiltonians-to-Matrices" title="Permalink"></a></h2><p>An Hamiltonian expression can be converted to a matrix via the <a href="https://docs.yaoquantum.org/dev/man/blocks.html#YaoAPI.mat-Tuple{AbstractBlock}"><code>mat</code></a> interface from Yao:</p><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.mat" href="#YaoAPI.mat"><code>YaoAPI.mat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mat([T=ComplexF64], blk)</code></pre><p>Returns the most compact matrix form of given block, e.g</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat(X)
2×2 LuxurySparse.SDPermMatrix{ComplexF64, Int64, Vector{ComplexF64}, Vector{Int64}}:
 0.0+0.0im  1.0+0.0im
 1.0+0.0im  0.0+0.0im

julia&gt; mat(Float64, X)
2×2 LuxurySparse.SDPermMatrix{Float64, Int64, Vector{Float64}, Vector{Int64}}:
 0.0  1.0
 1.0  0.0

julia&gt; mat(kron(X, X))
4×4 LuxurySparse.SDPermMatrix{ComplexF64, Int64, Vector{ComplexF64}, Vector{Int64}}:
 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im

julia&gt; mat(kron(X, X) + put(2, 1=&gt;X))
4×4 SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
     ⋅      1.0+0.0im      ⋅      1.0+0.0im
 1.0+0.0im      ⋅      1.0+0.0im      ⋅
     ⋅      1.0+0.0im      ⋅      1.0+0.0im
 1.0+0.0im      ⋅      1.0+0.0im      ⋅    </code></pre></div></section></article><p>This method will return the most compact matrix representation of the operator, e.g.:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mat(X) # will return a PermMatrix</code><code class="nohighlight hljs ansi" style="display:block;">2×2 LuxurySparse.SDPermMatrix{ComplexF64, Int64, Vector{ComplexF64}, Vector{Int64}}:
 0.0+0.0im  1.0+0.0im
 1.0+0.0im  0.0+0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mat(ht) # will return a SparseMatrixCSC</code><code class="nohighlight hljs ansi" style="display:block;">32×32 SparseMatrixCSC{ComplexF64, Int64} with 191 stored entries:
⢞⣵⠑⢄⠑⢄⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀
⠑⢄⢟⣵⠀⠀⠑⢄⠀⠀⠑⢄⠀⠀⠀⠀
⠑⢄⠀⠀⢟⣵⠑⢄⠀⠀⠀⠀⠑⢄⠀⠀
⠀⠀⠑⢄⠑⢄⢟⣵⠀⠀⠀⠀⠀⠀⠑⢄
⠑⢄⠀⠀⠀⠀⠀⠀⢟⣵⠑⢄⠑⢄⠀⠀
⠀⠀⠑⢄⠀⠀⠀⠀⠑⢄⢟⣵⠀⠀⠑⢄
⠀⠀⠀⠀⠑⢄⠀⠀⠑⢄⠀⠀⢟⣵⠑⢄
⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠑⢄⠑⢄⢟⣵</code></pre><p>The Hamiltonian matrix can also be created in a subspace, such as the blockade subspace (see also <a href="../subspace/#subspace">Working with Subspace</a>). This will allow one to simulate larger system sizes because of the smaller truncated Hilbert space.</p><p>For the Rydberg Hamiltonian, we can create a subspace via the <a href="../subspace/#BloqadeMIS.blockade_subspace"><code>blockade_subspace</code></a> method, e.g.:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; space = blockade_subspace(atoms, 7.5)</code><code class="nohighlight hljs ansi" style="display:block;">5-qubits 13-elements Subspace{Int64, Vector{Int64}}:
───┬───
  1│ 0
  2│ 1
  3│ 2
   ⋮│ ⋮
 11│ 18
 12│ 20
 13│ 21</code></pre><p>The above code means that the blockade subspace only includes states where there is only one Rydberg excitation  within the distance of 7.5 μm, which we call the subspace radius <span>$R_s$</span>. If we have a chain of atoms separated by 5.72 μm, the blockade subspace  does not contain states with nearest-neighbor atoms being simultaneously excited to the Rydberg state <span>$| r \rangle$</span>.</p><p>Once we have defined the space, we can convert the Hamiltonian to a matrix in a subspace basis via the codes below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; h_m = mat(ht, space)</code><code class="nohighlight hljs ansi" style="display:block;">13×13 SparseMatrixCSC{ComplexF64, Int64} with 52 stored entries:
         ⋅      18.8496+0.0im  18.8496+0.0im  …          ⋅              ⋅
 18.8496+0.0im  63.4602+0.0im          ⋅                 ⋅              ⋅
 18.8496+0.0im          ⋅      63.4602+0.0im             ⋅              ⋅
 18.8496+0.0im          ⋅              ⋅         18.8496+0.0im          ⋅
         ⋅      18.8496+0.0im          ⋅                 ⋅      18.8496+0.0im
 18.8496+0.0im          ⋅              ⋅      …          ⋅              ⋅
         ⋅      18.8496+0.0im          ⋅                 ⋅              ⋅
         ⋅              ⋅      18.8496+0.0im             ⋅              ⋅
 18.8496+0.0im          ⋅              ⋅         18.8496+0.0im          ⋅
         ⋅      18.8496+0.0im          ⋅                 ⋅      18.8496+0.0im
         ⋅              ⋅      18.8496+0.0im  …          ⋅              ⋅
         ⋅              ⋅              ⋅         129.338+0.0im  18.8496+0.0im
         ⋅              ⋅              ⋅         18.8496+0.0im  195.255+0.0im</code></pre><p>We can see that the size of the Hamiltonian matrix in the blockade subspace is much smaller than that in the full Hilbert space.</p><h2 id="Diagonalization-of-the-Hamiltonian"><a class="docs-heading-anchor" href="#Diagonalization-of-the-Hamiltonian">Diagonalization of the Hamiltonian</a><a id="Diagonalization-of-the-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonalization-of-the-Hamiltonian" title="Permalink"></a></h2><p>Bloqade doesn&#39;t provide any built-in diagonalization tool, as there are many existing  tools in the Julia ecosystem. Here, we demonstrate how to use the <a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit</a> package for this purpose as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using KrylovKit</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; vals, vecs, info = KrylovKit.eigsolve(h_m,  1, :SR)</code><code class="nohighlight hljs ansi" style="display:block;">([-23.53183367285095, 49.369907160338016, 51.29063792209709, 55.8910407150442, 61.44324863140747, 65.27248354593047, 124.97072996229849, 130.65930913081695, 133.53723395862136, 135.95163912164838, 139.99824815581474, 146.74962587152322, 210.19192698918917], Vector{ComplexF64}[[0.59357299859029 - 0.6292276823427363im, -0.15354480552521102 + 0.1627679196086245im, -0.14441013180340595 + 0.15308454521561776im, -0.14510817020618208 + 0.15382451331964067im, 0.038055625384583375 - 0.040341546899395404im, -0.14441013180340587 + 0.15308454521561776im, 0.0372769926728885 - 0.0395161433555335im, 0.035612762551789405 - 0.03775194642529715im, -0.15354480552521096 + 0.1627679196086251im, 0.03971428866211657 - 0.04209984259746132im, 0.03727699267288854 - 0.03951614335553431im, 0.03805562538458379 - 0.040341546899395196im, -0.009978957534498721 + 0.010578372561658883im], [0.1050054899884387 - 0.0161643390653257im, 0.3734001122971491 - 0.05748048052408777im, -0.4302241548209632 + 0.06622786211830986im, 0.38867373093732377 - 0.05983167140449902im, -0.19777183444730873 + 0.03044460808601594im, -0.43022415482096193 + 0.06622786211830445im, 0.013774053615846691 - 0.0021203507833234426im, 0.20281806517078846 - 0.03122141494082965im, 0.3734001122971473 - 0.05748048052407597im, -0.20012867873870677 + 0.03080741607114424im, 0.013774053615847022 - 0.0021203507833282564im, -0.1977718344473079 + 0.03044460808601389im, 0.07696601498363698 - 0.01184799730794514im], [3.798177050651219e-15 + 5.277354074573193e-17im, -0.08542419286375895 + 0.5500977323947388im, 0.05346849053127937 - 0.3443157542352786im, 1.817990202823694e-15 - 4.130810277169772e-16im, 0.020631042844469247 - 0.13285568765960865im, -0.053468490531289624 + 0.3443157542352822im, 0.034519996071523874 - 0.2222950071240904im, 2.0315780308033382e-15 - 5.999974822534782e-16im, 0.08542419286377698 - 0.5500977323947399im, -4.711508960753008e-15 + 3.982274579539258e-16im, -0.034519996071525894 + 0.2222950071240894im, -0.02063104284447474 + 0.13285568765960903im, 1.182214048878194e-15 - 1.6566609195578508e-16im], [0.16580194353578107 - 0.0044574700778289246im, 0.44587056397818153 - 0.011986920389093403im, 0.12710381769156165 - 0.0034170978461173086im, -0.6543274638582137 + 0.017591139338025755im, 0.048473216510720396 - 0.0013031687540283434im, 0.12710381769156404 - 0.00341709784611374im, -0.1516012229386959 + 0.004075693569094315im, -0.06523987697875663 + 0.0017539287737673003im, 0.4458705639781814 - 0.011986920389077844im, -0.24171543133018725 + 0.006498351463968502im, -0.15160122293869616 + 0.0040756935690920435im, 0.04847321651071977 - 0.0013031687540317662im, 0.01958067387768937 - 0.0005264128155085553im], [-1.6002824065886045e-16 - 1.5344171246101102e-15im, 0.06896476349353033 + 0.36368612934199746im, 0.10997258482601786 + 0.5799411421582663im, -6.579806144380029e-15 - 1.4146669946590862e-15im, -0.019146490756429713 - 0.10096914367497398im, -0.1099725848260201 - 0.5799411421582685im, 0.011767186105115339 + 0.06205433254648492im, 1.0664483619110543e-15 + 4.180683577104105e-16im, -0.06896476349352347 - 0.3636861293419984im, -1.9116652705264414e-15 + 3.847833510151055e-16im, -0.011767186105116593 - 0.06205433254648371im, 0.019146490756431045 + 0.10096914367497534im, 2.636779683484747e-16 - 2.0252896582029223e-16im], [-0.31780801276387605 - 0.3028343780634105im, -0.0690160808452611 - 0.06576436426944043im, -0.29998767471979126 - 0.2858536514243152im, -0.36250214385817414 - 0.34542272967642984im, 0.14147741639852368 + 0.13481165887688587im, -0.29998767471979093 - 0.28585365142430846im, 0.11244002621216159 + 0.10714237539596827im, 0.176525331157838 + 0.16820827898175286im, -0.06901608084526063 - 0.065764364269439im, 0.057254940745030916 + 0.05455735436243369im, 0.11244002621216152 + 0.10714237539597038im, 0.14147741639852293 + 0.13481165887688487im, -0.04933606280738406 - 0.04701157710416822im], [-0.010094755949612884 - 0.03140471205931781im, -0.027607708802859156 - 0.08588738052697127im, 0.011187627188928469 + 0.03480462650597877im, -0.03408709092419817 - 0.1060446910017068im, -0.05056974118534198 - 0.15732209562737692im, 0.01118762718892808 + 0.03480462650597915im, 0.14316605060655976 + 0.4453885382084647im, -0.09656342158150064 - 0.3004080995485919im, -0.027607708802858587 - 0.08588738052697201im, -0.17259203573902737 - 0.5369325631219478im, 0.14316605060656118 + 0.4453885382084648im, -0.05056974118534144 - 0.15732209562737853im, 0.07341259932769659 + 0.22838606053680893im], [2.7755575615628914e-16 - 3.0747973611688906e-16im, 0.017535750345755975 + 0.03486458211827803im, 0.05266017527179703 + 0.10469897032784602im, -3.094746681142624e-15 + 3.642919299551295e-16im, 0.25025022759874516 + 0.49754754933240336im, -0.05266017527179893 - 0.10469897032784539im, -0.18773483975346605 - 0.3732544435221029im, -4.7444687067965674e-15 + 6.973588373426765e-16im, -0.017535750345753054 - 0.03486458211827914im, 9.353628982466944e-15 - 1.8500825871292648e-15im, 0.18773483975346916 + 0.373254443522101im, -0.2502502275987578 - 0.49754754933240347im, 9.783840404509192e-16 + 5.863365348801608e-16im], [-0.030516647124664658 + 0.0014584899945069307im, 0.04336232804150081 - 0.0020724269389350673im, -0.011836148971113224 + 0.0005656881235121944im, -0.27924358639473135 + 0.01334596081683763im, -0.5038141229658756 + 0.024078918448515382im, -0.01183614897111131 + 0.0005656881235154912im, 0.09278557110318324 - 0.004434524754166461im, -0.10627221789999347 + 0.005079095546379631im, 0.043362328041500565 - 0.0020724269389338287im, 0.602753483082688 - 0.028807552829750033im, 0.09278557110317642 - 0.004434524754177341im, -0.50381412296587 + 0.024078918448530995im, 0.12365589727559503 - 0.005909918222715256im], [0.03928594956141936 - 0.018868362381061776im, 0.18859614178752857 - 0.09057946636503911im, -0.11081302677277005 + 0.053221580973168515im, 0.1277820493441272 - 0.061371509146042696im, 0.22606860373381715 - 0.10857684199694746im, -0.11081302677276895 + 0.053221580973166926im, 0.16625199068686639 - 0.07984795688719251im, -0.6317017694882175 + 0.3033954387389034im, 0.1885961417875268 - 0.09057946636503708im, 0.2936949508399939 - 0.14105660735713393im, 0.1662519906868618 - 0.07984795688718999im, 0.22606860373381504 - 0.10857684199694229im, -0.23706435207645152 + 0.11385790982643787im], [-4.0288952729561345e-16 - 2.598832607447754e-16im, 0.1844650344900553 - 0.13236714937010022im, -0.10413268655712038 + 0.07472281624493371im, -2.0816681711721685e-17 + 1.0993810029003015e-16im, 0.32618717498653826 - 0.2340631471618112im, 0.10413268655712207 - 0.07472281624493546im, 0.4228277614913254 - 0.30340983383581965im, 5.186606352736156e-15 - 3.4204410137572694e-15im, -0.18446503449006074 + 0.13236714937010055im, -4.3021142204224816e-15 + 6.166941957097549e-16im, -0.4228277614913299 + 0.30340983383581854im, -0.3261871749865402 + 0.23406314716181117im, 2.0964133207179714e-15 - 1.0668549377257364e-16im], [0.08441993884055482 + 0.09408402122996502im, 0.13537985590967955 + 0.15087764114082433im, 0.16595551191880853 + 0.18495348517236926im, 0.0545646120889274 + 0.06081096708533919im, 0.07834079533524475 + 0.087308959858574im, 0.1659555119188089 + 0.18495348517236834im, 0.2895468312040652 + 0.3226930816133811im, 0.35933135528985255 + 0.40046627993340694im, 0.13537985590967863 + 0.15087764114082525im, 0.14588765813995885 + 0.16258833770957157im, 0.28954683120406366 + 0.32269308161338417im, 0.07834079533524256 + 0.08730895985857438im, -0.11758180550009026 - 0.13104213574262308im], [0.015782149451729743 + 0.009320623338802667im, 0.05631957878481298 + 0.03326122224724858im, 0.004028027281987367 + 0.002378872739017712im, 0.05529197924101914 + 0.032654342409991946im, 0.2073152995412305 + 0.1224362895120801im, 0.004028027281987387 + 0.002378872739017882im, 0.013695343805547556 + 0.008088197459879334im, 0.0018781268056899494 + 0.0011091843092657207im, 0.05631957878481301 + 0.033261222247248576im, 0.2016191619516265 + 0.11907226402739716im, 0.013695343805547565 + 0.008088197459879307im, 0.2073152995412306 + 0.12243628951208019im, 0.7776486133273972 + 0.4592637927384865im]], ConvergenceInfo: 13 converged values after 1 iterations and 13 applications of the linear map;
norms of residuals are given by (1.3504851386989314e-37, 2.816948280035088e-32, 1.9093877358201896e-31, 5.763277148425516e-32, 1.4474266934629652e-31, 1.382714335801322e-32, 1.49195011793789e-31, 1.1195884182986139e-30, 3.595213863150019e-30, 6.247152405504507e-31, 1.7736284867501331e-31, 2.6878137162992593e-33, 2.6673453280312817e-38).
)</code></pre><p>where the <code>vals</code> and <code>vecs</code> store the calculated eigenvalues and eigenvectors respectively. </p><h2 id="Low-Level-Representation-of-the-Hamiltonian"><a class="docs-heading-anchor" href="#Low-Level-Representation-of-the-Hamiltonian">Low-Level Representation of the Hamiltonian</a><a id="Low-Level-Representation-of-the-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Low-Level-Representation-of-the-Hamiltonian" title="Permalink"></a></h2><p>Besides the symbolic representation, in order to achieve the best possible performance, we use a lower-level representation of the Hamiltonian in Bloqade, which is the <code>Hamiltonian</code> and <code>StepHamiltonian</code> type:</p><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.Hamiltonian" href="#BloqadeExpr.Hamiltonian"><code>BloqadeExpr.Hamiltonian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Hamiltonian</code></pre><p><code>Hamiltonian</code> stores the dynamic prefactors of each term. The actual hamiltonian is the sum of <code>f_i(t) * t_i</code> where <code>f_i</code> and <code>t_i</code> are entries of <code>fs</code> and <code>ts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/2c1ef8f632d0717650a05ac83cea0715f6c60462/lib/BloqadeExpr/src/types.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.StepHamiltonian" href="#BloqadeExpr.StepHamiltonian"><code>BloqadeExpr.StepHamiltonian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct StepHamiltonian</code></pre><p>A low-level linear-map object that encodes time-dependent hamiltonian at time step <code>t</code>. This object supports the linear map interface <code>mul!(Y, H, X)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/2c1ef8f632d0717650a05ac83cea0715f6c60462/lib/BloqadeExpr/src/types.jl#L25-L31">source</a></section></article><p>The <code>Hamiltonian</code> type represents the following Hamiltonian expression</p><p class="math-container">\[f_1(t) H_1 + f_2(t) H_2 + \cdots + f_n(t) H_n + H_c,\]</p><p>where <span>$f_i(t)$</span> are time-dependent parameters of the Hamiltonian, <span>$H_i$</span> are time-independent local terms of the Hamiltonian as linear operators (in Julia, this means objects that support <code>LinearAlgebra.mul!</code> interface), and <span>$H_c$</span> is the constant component of the Hamiltonian.</p><p>A <code>Hamiltonian</code> object supports callable methods, which will produce a <code>StepHamiltonian</code> that is time-independent, e.g.:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using BloqadeExpr</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h = BloqadeExpr.Hamiltonian(Float64, SumOfX(5, sin) + SumOfZ(5, cos))</code><code class="nohighlight hljs ansi" style="display:block;">Hamiltonian
  number of dynamic terms: 2
  storage size: 48 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h(0.1)</code><code class="nohighlight hljs ansi" style="display:block;">BloqadeExpr.StepHamiltonian{Float64, Tuple{typeof(sin), typeof(cos), typeof(one)}, Tuple{SparseMatrixCSC{Float64, Int64}, Diagonal{Float64, Vector{Float64}}}}(0.1, BloqadeExpr.Hamiltonian{Tuple{typeof(sin), typeof(cos), typeof(one)}, Tuple{SparseMatrixCSC{Float64, Int64}, Diagonal{Float64, Vector{Float64}}}}((sin, cos, one), (sparse([2, 3, 5, 9, 17, 1, 4, 6, 10, 18  …  15, 23, 27, 29, 32, 16, 24, 28, 30, 31], [1, 1, 1, 1, 1, 2, 2, 2, 2, 2  …  31, 31, 31, 31, 31, 32, 32, 32, 32, 32], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 32, 32), [5.0 0.0 … 0.0 0.0; 0.0 3.0 … 0.0 0.0; … ; 0.0 0.0 … -3.0 0.0; 0.0 0.0 … 0.0 -5.0])))</code></pre><p>Here, we see that the Hamiltonian expression written as Yao blocks are automatically analyzed into time-dependent terms and constant terms. A more complicated example can be <a href="#BloqadeExpr.SumOfXPhase"><code>SumOfXPhase</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using BloqadeExpr</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h = BloqadeExpr.Hamiltonian(Float64, SumOfXPhase(5, sin, cos) + SumOfZ(5, cos))</code><code class="nohighlight hljs ansi" style="display:block;">Hamiltonian
  number of dynamic terms: 3
  storage size: 88 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h(0.1)</code><code class="nohighlight hljs ansi" style="display:block;">BloqadeExpr.StepHamiltonian{Float64, Tuple{BloqadeExpr.var&quot;#74#108&quot;, BloqadeExpr.var&quot;#76#110&quot;, typeof(cos), typeof(one)}, Tuple{SparseMatrixCSC{Float64, Int64}, SparseMatrixCSC{Float64, Int64}, Diagonal{Float64, Vector{Float64}}}}(0.1, BloqadeExpr.Hamiltonian{Tuple{BloqadeExpr.var&quot;#74#108&quot;, BloqadeExpr.var&quot;#76#110&quot;, typeof(cos), typeof(one)}, Tuple{SparseMatrixCSC{Float64, Int64}, SparseMatrixCSC{Float64, Int64}, Diagonal{Float64, Vector{Float64}}}}((BloqadeExpr.var&quot;#74#108&quot;(Core.Box(cos), Core.Box(sin)), BloqadeExpr.var&quot;#76#110&quot;(Core.Box(cos), Core.Box(sin)), cos, one), (sparse([1, 1, 2, 3, 1, 2, 5, 3, 5, 4  …  29, 15, 23, 27, 29, 16, 24, 28, 30, 31], [2, 3, 4, 4, 5, 6, 6, 7, 7, 8  …  30, 31, 31, 31, 31, 32, 32, 32, 32, 32], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 32, 32), sparse([2, 3, 5, 9, 17, 4, 6, 10, 18, 4  …  29, 28, 30, 28, 31, 32, 30, 31, 32, 32], [1, 1, 1, 1, 1, 2, 2, 2, 2, 3  …  25, 26, 26, 27, 27, 28, 29, 29, 30, 31], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 32, 32), [5.0 0.0 … 0.0 0.0; 0.0 3.0 … 0.0 0.0; … ; 0.0 0.0 … -3.0 0.0; 0.0 0.0 … 0.0 -5.0])))</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.rydberg_h" href="#BloqadeExpr.rydberg_h"><code>BloqadeExpr.rydberg_h</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rydberg_h(atoms; [C=2π * 862690 * MHz*µm^6], Ω[, ϕ, Δ])</code></pre><p>Create a rydberg hamiltonian</p><p class="math-container">\[∑ \frac{C}{|x_i - x_j|^6} n_i n_j + \frac{Ω}{2} σ_x - Δ σ_n\]</p><p>shorthand for</p><pre><code class="language-julia hljs">RydInteract(C, atoms) + SumOfXPhase(length(atoms), Ω, ϕ) - SumOfN(length(atoms), Δ)</code></pre><p><strong>Arguments</strong></p><ul><li><code>atoms</code>: a collection of atom positions.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>C</code>: optional, default unit is <code>MHz*µm^6</code>, interation parameter,   see also <a href="#BloqadeExpr.RydInteract"><code>RydInteract</code></a>.</li><li><code>Ω</code>: optional, default unit is <code>MHz</code>, Rabi frequencies, divided by 2, see also <a href="#BloqadeExpr.SumOfX"><code>SumOfX</code></a>.</li><li><code>Δ</code>: optional, default unit is <code>MHz</code>, detuning parameter, see <a href="#BloqadeExpr.SumOfN"><code>SumOfN</code></a>.</li><li><code>ϕ</code>: optional, does not have unit, the phase, see <a href="#BloqadeExpr.SumOfXPhase"><code>SumOfXPhase</code></a>.</li></ul><div class="admonition is-category-tips"><header class="admonition-header">Tips</header><div class="admonition-body"><p>The rabi frequencies are divided by two in the Rydberg hamiltonian unlike directly constructing via <a href="#BloqadeExpr.SumOfX"><code>SumOfX</code></a> or <a href="#BloqadeExpr.SumOfXPhase"><code>SumOfXPhase</code></a>.</p></div></div><div class="admonition is-category-tips"><header class="admonition-header">Tips</header><div class="admonition-body"><p>The parameters of Hamiltonian have their own default units to match hardware, one can use <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.jl</code></a> to specify their units explicitly. If the units are specified explicitly, they will be converted to default units automatically.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Bloqade

julia&gt; atoms = [(1, ), (2, ), (3, ), (4, )]
4-element Vector{Tuple{Int64}}:
 (1,)
 (2,)
 (3,)
 (4,)

julia&gt; rydberg_h(atoms)
∑ 5.42e6/|x_i-x_j|^6 n_i n_j</code></pre><pre><code class="language-julia-repl hljs">julia&gt; rydberg_h(atoms; Ω=0.1)
nqubits: 4
+
├─ ∑ 5.42e6/|x_i-x_j|^6 n_i n_j
└─ 0.05 ⋅ ∑ σ^x_i</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/2c1ef8f632d0717650a05ac83cea0715f6c60462/lib/BloqadeExpr/src/interface.jl#L23-L84">source</a></section></article><p>Except the standard operators from Yao, the following operators are also supported by Bloqade:</p><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.RydInteract" href="#BloqadeExpr.RydInteract"><code>BloqadeExpr.RydInteract</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RydInteract{D} &lt;: AbstractTerm{D}
RydInteract(;atoms, C=2π * 862690MHz⋅μm^6)</code></pre><p>Type for Rydberg interactive term.</p><p><strong>Expression</strong></p><p class="math-container">\[\sum_{i, j} \frac{C}{|x_i - x_j|^6} n_i n_j\]</p><p><strong>Keyword Arguments</strong></p><ul><li><code>atoms</code>: a list of atom positions, must be type <code>RydAtom</code>, default unit is <code>μm</code>.</li><li><code>C</code>: the interaction strength, default unit is <code>MHz⋅μm^6</code>. default value is <code>2π * 862690 * MHz*µm^6</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/2c1ef8f632d0717650a05ac83cea0715f6c60462/lib/BloqadeExpr/src/types.jl#L349-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.SumOfX" href="#BloqadeExpr.SumOfX"><code>BloqadeExpr.SumOfX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SumOfX &lt;: AbstractTerm{2}
SumOfX(nsites, Ω)</code></pre><p>Term for sum of X operators.</p><p>The following two expressions are equivalent</p><pre><code class="language-julia-repl hljs">julia&gt; SumOfX(nsites=5)
∑ σ^x_i

julia&gt; sum([X for _ in 1:5])
nqudits: 1
+
├─ X
├─ X
├─ X
├─ X
└─ X</code></pre><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Ω σ^x_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/2c1ef8f632d0717650a05ac83cea0715f6c60462/lib/BloqadeExpr/src/types.jl#L376-L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.SumOfXPhase" href="#BloqadeExpr.SumOfXPhase"><code>BloqadeExpr.SumOfXPhase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SumOfXPhase &lt;: AbstractTerm{2}
SumOfXPhase(;nsites, Ω=1, ϕ)</code></pre><p>Sum of <code>XPhase</code> operators.</p><p>The following two expressions are equivalent</p><pre><code class="language-julia-repl hljs">julia&gt; SumOfXPhase(nsites=5, ϕ=0.1)
1.0 ⋅ ∑ e^{0.1 ⋅ im} |0⟩⟨1| + e^{-0.1 ⋅ im} |1⟩⟨0|

julia&gt; sum([XPhase(0.1) for _ in 1:5])
nqudits: 1
+
├─ XPhase(0.1)
├─ XPhase(0.1)
├─ XPhase(0.1)
├─ XPhase(0.1)
└─ XPhase(0.1)</code></pre><p>But may provide extra speed up.</p><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Ω ⋅ (e^{ϕ ⋅ i} |0⟩⟨1| + e^{-ϕ ⋅ i} |1⟩⟨0|)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/2c1ef8f632d0717650a05ac83cea0715f6c60462/lib/BloqadeExpr/src/types.jl#L465-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.SumOfZ" href="#BloqadeExpr.SumOfZ"><code>BloqadeExpr.SumOfZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SumOfZ &lt;: AbstractTerm{2}
SumOfZ(;nsites, Δ=1)</code></pre><p>Sum of Pauli Z operators.</p><p>The following two expression are equivalent</p><pre><code class="language-julia-repl hljs">julia&gt; SumOfZ(nsites=5)
∑ σ^z_i

julia&gt; sum([Z for _ in 1:5])
nqudits: 1
+
├─ Z
├─ Z
├─ Z
├─ Z
└─ Z</code></pre><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Δ ⋅ σ^z_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/2c1ef8f632d0717650a05ac83cea0715f6c60462/lib/BloqadeExpr/src/types.jl#L652-L679">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.SumOfN" href="#BloqadeExpr.SumOfN"><code>BloqadeExpr.SumOfN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SumOfN &lt;: AbstractTerm{2}
SumOfN(;nsites[, Δ=1])</code></pre><p>Sum of N operators. </p><p>The following two expression are equivalent</p><pre><code class="language-julia-repl hljs">julia&gt; SumOfN(nsites=5)
∑ n_i

julia&gt; sum([Op.n for _ in 1:5])
nqudits: 1
+
├─ P1
├─ P1
├─ P1
├─ P1
└─ P1</code></pre><p>But may provide extra speed up.</p><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Δ ⋅ n_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/2c1ef8f632d0717650a05ac83cea0715f6c60462/lib/BloqadeExpr/src/types.jl#L565-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.XPhase" href="#BloqadeExpr.XPhase"><code>BloqadeExpr.XPhase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">XPhase{T} &lt;: PrimitiveBlock{2}</code></pre><p>XPhase operator for 2-level Rydberg system.</p><p class="math-container">\[e^{ϕ ⋅ i} |0⟩⟨1| + e^{-ϕ ⋅ i} |1⟩⟨0|\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/2c1ef8f632d0717650a05ac83cea0715f6c60462/lib/BloqadeExpr/src/types.jl#L58-L66">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../waveform/">« Waveforms</a><a class="docs-footer-nextpage" href="../registers/">Registers and Observables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 28 January 2023 22:17">Saturday 28 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
