<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lattices · Bloqade.jl</title><meta name="title" content="Lattices · Bloqade.jl"/><meta property="og:title" content="Lattices · Bloqade.jl"/><meta property="twitter:title" content="Lattices · Bloqade.jl"/><meta name="description" content="Documentation for Bloqade.jl."/><meta property="og:description" content="Documentation for Bloqade.jl."/><meta property="twitter:description" content="Documentation for Bloqade.jl."/><meta property="og:url" content="https://QuEraComputing.github.io/Bloqade.jl/lattices/"/><meta property="twitter:url" content="https://QuEraComputing.github.io/Bloqade.jl/lattices/"/><link rel="canonical" href="https://QuEraComputing.github.io/Bloqade.jl/lattices/"/><script async src="https://www.googletagmanager.com/gtag/js?id=G-SRKGL6MJHS"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-SRKGL6MJHS', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Bloqade.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Bloqade.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../julia/">The Julia Programming Language</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Lattices</a><ul class="internal"><li><a class="tocitem" href="#Types-of-Lattices"><span>Types of Lattices</span></a></li><li><a class="tocitem" href="#Sorting-Sites-and-Other-Operations-on-Lattices"><span>Sorting Sites and Other Operations on Lattices</span></a></li><li><a class="tocitem" href="#User-Defined-Arbitrary-Geometries"><span>User-Defined Arbitrary Geometries</span></a></li><li><a class="tocitem" href="#Query-Neighbors"><span>Query Neighbors</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../waveform/">Waveforms</a></li><li><a class="tocitem" href="../hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../registers/">Registers and Observables</a></li><li><a class="tocitem" href="../emulation/">Emulation</a></li><li><a class="tocitem" href="../subspace/">Working with Subspace</a></li><li><a class="tocitem" href="../units/">Working with Units</a></li><li><a class="tocitem" href="../mis/">Maximum Independent Set</a></li><li><a class="tocitem" href="../multithreading/">CPU Acceleration</a></li><li><a class="tocitem" href="../cuda/">GPU Acceleration</a></li><li><a class="tocitem" href="../3-level/">3-Level Support and Quantum Gates</a></li><li><a class="tocitem" href="../schema/">Interacting with Neutral Atom Hardware</a></li><li><a class="tocitem" href="../capabilities/">Hardware Capabilities</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/1.blockade/main/">Rydberg Blockade</a></li><li><a class="tocitem" href="../tutorials/2.adiabatic/main/">Adiabatic Evolution</a></li><li><a class="tocitem" href="../tutorials/3.quantum-scar/main/">Quantum Scar</a></li><li><a class="tocitem" href="../tutorials/4.LGT/main/">Simulation of a Lattice Gauge Theory with Rydberg Atoms</a></li><li><a class="tocitem" href="../tutorials/5.MIS/main/">The Maximum Independent Set Problem</a></li><li><a class="tocitem" href="../tutorials/6.MWIS/main/">Maximum Weight Independent Set</a></li><li><a class="tocitem" href="../tutorials/7.QMC/main/">Quantum Monte Carlo Method</a></li><li><a class="tocitem" href="../tutorials/8.simulating noise/main/">Simulating Noise</a></li></ul></li><li><a class="tocitem" href="../contrib/">Contributing to Bloqade</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Lattices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lattices</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuEraComputing/Bloqade.jl/blob/master/docs/src/lattices.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lattices"><a class="docs-heading-anchor" href="#Lattices">Lattices</a><a id="Lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Lattices" title="Permalink"></a></h1><p>We can use Bloqade to simulate the quantum evolution of information stored in neutral atoms. Present-day neutral-atom hardware permits the arrangement of atoms in a regular lattice structure and even in nearly arbitrary geometries in 1D, 2D, and 3D. This makes neutral atom platform a natural playground for quantum simulation of statistical models and quantum matters. With Bloqade, we support several built-in lattice structures and also allow the users to specify atom positions by inputting coordinates. Please refer to the <a href="@ref blockade">Rydberg Blockade</a> page for recommendations on how to set the lattice constants for different lattices.</p><h2 id="Types-of-Lattices"><a class="docs-heading-anchor" href="#Types-of-Lattices">Types of Lattices</a><a id="Types-of-Lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-Lattices" title="Permalink"></a></h2><p>A crystal lattice is completely determined by a set of Bravais lattice vectors (in unit of μm) plus the locations of atoms within a unit cell. A <a href="https://en.wikipedia.org/wiki/Bravais_lattice">Bravais lattice</a> is an infinite array of discrete points generated by a set of discrete translation operations described by</p><p class="math-container">\[\mathbf{R} = n_1 \mathbf{a}_1 + n_2 \mathbf{a}_2 + \ldots + n_d \mathbf{a}_d,\]</p><p>where <span>$d$</span> is the dimension of space, <span>$n_1, \ldots, n_d \in Z$</span> are integers. The unit cell of a Bravais lattice is defined by specifying its lattice vectors <span>$(\mathbf{a}_1, \mathbf{a}_2, \ldots, \mathbf{a}_d)$</span>. To create a simple lattice, we first specify the locations of the atoms within a unit cell and then specify the lattice vectors of the Bravais lattice. For example, for a triangular lattice, we need just one site (atom) at the location <code>(0.0, 0.0)</code> in the unit cell and then lattice vectors <code>(1.0, 0.0)</code> and <code>(0.5, 0.5*sqrt(3))</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Bloqade</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; triangular = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))], [(0.0, 0.0)])</code><code class="nohighlight hljs ansi" style="display:block;">GeneralLattice{2, 1, Float64}(((1.0, 0.0), (0.5, 0.8660254037844386)), ((0.0, 0.0),))</code></pre><p>For composite lattices, one should provide multiple sites as the second argument to specify their locations in a unit cell. For example, the honeycomb lattice can be defined by:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; honeycomb = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))],
           [(0.0, 0.0), (0.5, 0.5/sqrt(3))])</code><code class="nohighlight hljs ansi" style="display:block;">GeneralLattice{2, 2, Float64}(((1.0, 0.0), (0.5, 0.8660254037844386)), ((0.0, 0.0), (0.5, 0.2886751345948129)))</code></pre><p>We provide a few shorthands for several useful lattices, including the <a href="#BloqadeLattices.ChainLattice"><code>ChainLattice</code></a>, <a href="#BloqadeLattices.SquareLattice"><code>SquareLattice</code></a>, <a href="#BloqadeLattices.HoneycombLattice"><code>HoneycombLattice</code></a>, <a href="#BloqadeLattices.TriangularLattice"><code>TriangularLattice</code></a>, <a href="#BloqadeLattices.LiebLattice"><code>LiebLattice</code></a>, and <a href="#BloqadeLattices.KagomeLattice"><code>KagomeLattice</code></a> shown below.  One can use <a href="#BloqadeLattices.lattice_vectors"><code>lattice_vectors</code></a> and <a href="#BloqadeLattices.lattice_sites"><code>lattice_sites</code></a> to access the lattice vectors and site locations in a unit cell as described in the above section.</p><h5 id="[ChainLattice](@ref)"><a class="docs-heading-anchor" href="#[ChainLattice](@ref)"><a href="#BloqadeLattices.ChainLattice"><code>ChainLattice</code></a></a><a id="[ChainLattice](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[ChainLattice](@ref)" title="Permalink"></a></h5><pre><code class="language-julia hljs">using Bloqade
chain = ChainLattice()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ChainLattice()</code></pre><pre><code class="language-julia hljs"># to make the plot look good in both light and dark backgrounds.
BloqadeLattices.DEFAULT_BACKGROUND_COLOR[] = &quot;#FFFFFF&quot;

# to show the lattice vectors (rescaled a bit to shrink the head).
unitvectors(lattice::AbstractLattice{2}) = [((0.0, 0.0), v) for v in lattice_vectors(lattice)]

Bloqade.plot(generate_sites(chain, 10); vectors=[((0.0, 0.0), (0.9, 0.0))], bond_linewidth=0.015)</code></pre><img src="44d5fe8b.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can see the above visualization in one of the following editors</p><ul><li>a <a href="https://github.com/julia-vscode/julia-vscode">VSCode</a> editor,</li><li>a <a href="https://github.com/JunoLab/Juno.jl">Jupyter</a> notebook,</li><li>or a <a href="https://github.com/fonsp/Pluto.jl">Pluto</a> notebook,</li></ul><p>but not in a Julia REPL which does not have a graphical display.</p></div></div><pre><code class="language-julia hljs">lattice_vectors(chain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((1.0,),)</code></pre><pre><code class="language-julia hljs">lattice_sites(chain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((0.0,),)</code></pre><p>Once we have defined certain lattice shapes (which have fixed lattice vectors and site positions in the unit cell), we can generate the atom positions by  specifying the number of atoms and the scale size of the lattice.  This is done by using the function <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a> , which will return a <a href="#BloqadeLattices.AtomList"><code>AtomList</code></a> instance containing the coordinates of each atom, e.g.:  </p><pre><code class="language-julia hljs">atoms = generate_sites(HoneycombLattice(), 3, 5; scale = 4.5)</code></pre><img src="4e5ada52.svg" alt="Example block output"/><p>where <code>scale</code> defines the unit distance in the unit μm of the lattice, and <code>3, 5</code> specifies the repetitions of unit cells in each lattice vector direction. The default <code>scale</code> is 1 μm.</p><p>Here are some examples of other lattices:</p><h5 id="[SquareLattice](@ref)"><a class="docs-heading-anchor" href="#[SquareLattice](@ref)"><a href="#BloqadeLattices.SquareLattice"><code>SquareLattice</code></a></a><a id="[SquareLattice](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[SquareLattice](@ref)" title="Permalink"></a></h5><pre><code class="language-julia hljs">square = SquareLattice()
Bloqade.plot(generate_sites(square, 10, 10); vectors=unitvectors(square), bond_linewidth=0.015)</code></pre><img src="1f977a00.svg" alt="Example block output"/><p>Note that the indices showing on the sites are consistent with the indices of the qubits for performing computation.  In other words, if we want to do measurement or apply operations on individual sites (qubits), we can refer to the numbering on the atoms for convenience.  For more details on how to generate Hamiltonians by using the lattice as an argument, please see the section <a href="../hamiltonians/#Hamiltonians">Hamiltonians</a>.</p><pre><code class="language-julia hljs">lattice_vectors(square)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((1.0, 0.0), (0.0, 1.0))</code></pre><pre><code class="language-julia hljs">lattice_sites(square)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((0.0, 0.0),)</code></pre><h5 id="[HoneycombLattice](@ref)"><a class="docs-heading-anchor" href="#[HoneycombLattice](@ref)"><a href="#BloqadeLattices.HoneycombLattice"><code>HoneycombLattice</code></a></a><a id="[HoneycombLattice](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[HoneycombLattice](@ref)" title="Permalink"></a></h5><pre><code class="language-julia hljs">honeycomb = HoneycombLattice()
Bloqade.plot(generate_sites(honeycomb, 5, 5); vectors=unitvectors(honeycomb), bond_linewidth=0.015)</code></pre><img src="5b0f2b6d.svg" alt="Example block output"/><h5 id="[TriangularLattice](@ref)"><a class="docs-heading-anchor" href="#[TriangularLattice](@ref)"><a href="#BloqadeLattices.TriangularLattice"><code>TriangularLattice</code></a></a><a id="[TriangularLattice](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[TriangularLattice](@ref)" title="Permalink"></a></h5><pre><code class="language-julia hljs">triangular = TriangularLattice()
Bloqade.plot(generate_sites(triangular, 8, 8); vectors=unitvectors(triangular), bond_linewidth=0.015)</code></pre><img src="c8808dba.svg" alt="Example block output"/><h5 id="[LiebLattice](@ref)"><a class="docs-heading-anchor" href="#[LiebLattice](@ref)"><a href="#BloqadeLattices.LiebLattice"><code>LiebLattice</code></a></a><a id="[LiebLattice](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[LiebLattice](@ref)" title="Permalink"></a></h5><pre><code class="language-julia hljs">lieb = LiebLattice()
Bloqade.plot(generate_sites(lieb, 5, 5); vectors=unitvectors(lieb), bond_linewidth=0.015)</code></pre><img src="455ebba3.svg" alt="Example block output"/><h5 id="[KagomeLattice](@ref)"><a class="docs-heading-anchor" href="#[KagomeLattice](@ref)"><a href="#BloqadeLattices.KagomeLattice"><code>KagomeLattice</code></a></a><a id="[KagomeLattice](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[KagomeLattice](@ref)" title="Permalink"></a></h5><pre><code class="language-julia hljs">kagome = KagomeLattice()
Bloqade.plot(generate_sites(kagome, 5, 5); vectors=unitvectors(kagome), bond_linewidth=0.015)</code></pre><img src="5d07366a.svg" alt="Example block output"/><h2 id="Sorting-Sites-and-Other-Operations-on-Lattices"><a class="docs-heading-anchor" href="#Sorting-Sites-and-Other-Operations-on-Lattices">Sorting Sites and Other Operations on Lattices</a><a id="Sorting-Sites-and-Other-Operations-on-Lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Sorting-Sites-and-Other-Operations-on-Lattices" title="Permalink"></a></h2><p>We also support different operations on the generated lattices. For instance, one can apply some predefined filters, e.g. <a href="#BloqadeLattices.rescale_axes"><code>rescale_axes</code></a>, <a href="#BloqadeLattices.clip_axes"><code>clip_axes</code></a>, <a href="#BloqadeLattices.offset_axes"><code>offset_axes</code></a>, to manipulate atom locations:</p><pre><code class="language-julia hljs">atoms = generate_sites(HoneycombLattice(), 3, 5; scale = 4.5)
rescale_axes(atoms, 0.8)</code></pre><img src="16afd7d9.svg" alt="Example block output"/><p>where the above operation rescales the coordinates of the original <code>sites</code> by a factor of <code>0.8</code>. </p><p>The code below restricts the atoms sitting in the window <code>(0.0, 5.0), (0.0, 6.0)</code> and throw away those outside this area: </p><pre><code class="language-julia hljs">clip_axes(atoms, (0.0, 5.0), (0.0, 6.0))</code></pre><img src="110d46c6.svg" alt="Example block output"/><p>Furthermore, we can shift the origin of the <code>atoms</code> by some vector <code>(5.0, 5.0)</code> simply by typing the code:</p><pre><code class="language-julia hljs">offset_axes(atoms, 5.0, 5.0)</code></pre><img src="58a09a3f.svg" alt="Example block output"/><p>To sort the atoms by their x-coordinates, one can convert these locations to a <a href="#BloqadeLattices.MaskedGrid"><code>MaskedGrid</code></a> representation of the atoms:</p><pre><code class="language-julia hljs">atoms_in_grid = make_grid(atoms)</code></pre><img src="b1ead467.svg" alt="Example block output"/><p>Then one can get the sorted atoms by typing:</p><pre><code class="language-julia hljs">sorted_atoms = collect_atoms(atoms_in_grid)</code></pre><img src="eb38a647.svg" alt="Example block output"/><p>Note that the sorting will change the index numbering of the atoms. </p><p>You can also delete atoms given their index number:</p><pre><code class="language-julia hljs">deleteat!(atoms, 8, 9, 13, 14, 18, 20, 23)
atoms</code></pre><img src="0c1422b5.svg" alt="Example block output"/><p>Note that this permanently changes the contents of <code>atoms</code> and just like sorting atoms, will change the index numbering albeit to preserve the integer sequence without gaps.</p><h2 id="User-Defined-Arbitrary-Geometries"><a class="docs-heading-anchor" href="#User-Defined-Arbitrary-Geometries">User-Defined Arbitrary Geometries</a><a id="User-Defined-Arbitrary-Geometries-1"></a><a class="docs-heading-anchor-permalink" href="#User-Defined-Arbitrary-Geometries" title="Permalink"></a></h2><p>One can also generate atoms located at arbitrary positions by directly inputting the coordinates of the atoms:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; atom_coordinate = AtomList([(0.0, 0.0), (0, 5), (0, 8), (5, 2), (6, 7), (9, 6)])</code><code class="nohighlight hljs ansi" style="display:block;">        ⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr97"><span class="sgr1">Approximate Atom Positions</span></span>⠀⠀⠀⠀⠀⠀⠀⠀
        <span class="sgr90">┌────────────────────────────────────────┐</span>
      <span class="sgr90">8</span> <span class="sgr90">│</span><span class="sgr32">⚬</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
        <span class="sgr90">│</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr32">⚬</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
        <span class="sgr90">│</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
        <span class="sgr90">│</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr32">⚬</span><span class="sgr90">│</span> 
        <span class="sgr90">│</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
        <span class="sgr90">│</span><span class="sgr32">⚬</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
        <span class="sgr90">│</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
   μm   <span class="sgr90">│</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
        <span class="sgr90">│</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
        <span class="sgr90">│</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
        <span class="sgr90">│</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
        <span class="sgr90">│</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr32">⚬</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
        <span class="sgr90">│</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
        <span class="sgr90">│</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
      <span class="sgr90">0</span> <span class="sgr90">│</span><span class="sgr32">⚬</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">│</span> 
        <span class="sgr90">└────────────────────────────────────────┘</span>
        ⠀<span class="sgr90">0</span>⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀<span class="sgr90">9</span>⠀
        ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀μm⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀</code></pre><h2 id="Query-Neighbors"><a class="docs-heading-anchor" href="#Query-Neighbors">Query Neighbors</a><a id="Query-Neighbors-1"></a><a class="docs-heading-anchor-permalink" href="#Query-Neighbors" title="Permalink"></a></h2><p>One can use <a href="@ref"><code>make_kdtree</code></a> to generate a <a href="https://en.wikipedia.org/wiki/K-d_tree">k-d tree</a> data type for the efficient querying of neighborhoods in a low-dimensional space.</p><pre><code class="language-julia hljs">tree = make_kdtree(sorted_atoms)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NearestNeighbors.KDTree{StaticArraysCore.SVector{2, Float64}, Distances.Euclidean, Float64, StaticArraysCore.SVector{2, Float64}}
  Number of points: 30
  Dimensions: 2
  Metric: Distances.Euclidean(0.0)
  Reordered: true</code></pre><p>The return value is a <code>KDTree</code> instance, which is defined in the package <a href="https://github.com/KristofferC/NearestNeighbors.jl"><code>NearestNeigbors</code></a>. One can use it to query the neighbors of an atom: e.g. one can find the 20 nearest neighbors of the 5-th site by typing:</p><pre><code class="language-julia hljs">neighbors = grouped_nearest(tree, 5, 20)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DistanceGroup([5, 8, 2, 3, 6, 11, 4, 10, 9, 7, 13, 14, 1, 12, 16, 17, 15, 19, 20, 18], [1, 2, 5, 9, 11, 14, 16, 17, 18, 19, 20, 21])</code></pre><p>The return value is a <a href="@ref"><code>DistanceGroup</code></a> instance, and the indices of the second nearest neighbors are:</p><pre><code class="language-julia hljs">neighbors[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Int64}:
  6
 11
  4
 10</code></pre><p>One can select and display these atoms with the correct labeling by typing:</p><pre><code class="language-julia hljs">Bloqade.plot(sorted_atoms[neighbors[2]]; texts=string.(neighbors[2]))</code></pre><img src="420bf3f9.svg" alt="Example block output"/><p>It shows the correct second nearest neighbors of the site 5. One can check the docstring of <a href="@ref"><code>Bloqade.plot</code></a> to know more about how to customize lattice visualization.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.AbstractLattice" href="#BloqadeLattices.AbstractLattice"><code>BloqadeLattices.AbstractLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractLattice{D}</code></pre><p>Supertype for all <code>D</code> dimensional lattices.</p><p><strong>Implementation</strong></p><p><a href="#BloqadeLattices.lattice_vectors"><code>lattice_vectors</code></a> and <a href="#BloqadeLattices.lattice_sites"><code>lattice_sites</code></a> functions must be defined which should both return an indexable iterable containing the Bravais lattice vectors and  lattice sites respectively. (e.g.: <a href="#BloqadeLattices.GeneralLattice"><code>GeneralLattice</code></a> returns a tuple of tuples containing the  Bravais lattice vectors and lattice sites).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.GeneralLattice" href="#BloqadeLattices.GeneralLattice"><code>BloqadeLattices.GeneralLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneralLattice{D,K,T} &lt;: AbstractLattice{D}
GeneralLattice(vectors, sites)</code></pre><p>The general lattice type for tiling the space. Type parameter <code>D</code> is the dimension, <code>K</code> is the number of sites in a unit cell and <code>T</code> is the data type for coordinates, e.g. <code>Float64</code>. Input arguments are</p><ul><li><code>vectors</code> is a vector/tuple of D-tuple. Its length is D, it specifies the Bravais lattice vectors.</li><li><code>sites</code> is a vector/tuple of D-tuple. Its length is K, it specifies the sites inside a Bravais cell.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L40-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.SquareLattice" href="#BloqadeLattices.SquareLattice"><code>BloqadeLattices.SquareLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SquareLattice &lt;: AbstractLattice{2}</code></pre><p>Type representing 2D Square Lattice.</p><p>Used as an argument of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a> function to produce tiling in a square pattern, with number of site repetitions being specified by additional arguments of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a>. Square is a 2D Lattice, so there must be two integer arguments as additional inputs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; generate_sites(SquareLattice(), 4, 4)
16-element AtomList{2, Float64}:
 (0.0, 0.0)
 (1.0, 0.0)
 ...
 (2.0, 3.0)
 (3.0, 3.0)
</code></pre><p>Overriden functions to return lattice vectors and sites exists as  <a href="#BloqadeLattices.lattice_vectors"><code>lattice_vectors(::SquareLattice)</code></a> and <a href="#BloqadeLattices.lattice_sites"><code>lattice_sites(::SquareLattice)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L121-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.RectangularLattice" href="#BloqadeLattices.RectangularLattice"><code>BloqadeLattices.RectangularLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct RectangularLattice &lt;: AbstractLattice{2}</code></pre><p>Type representing 2D Rectangular Lattice.</p><p>Used as an argument of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a> function to produce tiling in a Rectangular pattern,  with number of site repetitions being specified by additional arguments of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a>. Rectangular is a 2D Lattice, so there must be two integer arguments as additional inputs. This type also enables the user to modify the length of one of the Bravais lattice vectors,  by passing a single integer on construction as the aspect ratio.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; generate_sites(RectangularLattice(2.0), 2, 2)
4-element AtomList{2, Float64}:
 (0.0, 0.0)
 (1.0, 0.0)
 (0.0, 2.0)
 (1.0, 2.0)</code></pre><p>Overriden functions to return lattice vectors and sites exists as  <a href="#BloqadeLattices.lattice_vectors"><code>lattice_vectors(::RectangularLattice)</code></a> and <a href="#BloqadeLattices.lattice_sites"><code>lattice_sites(::RectangularLattice)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L371-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.HoneycombLattice" href="#BloqadeLattices.HoneycombLattice"><code>BloqadeLattices.HoneycombLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct HoneycombLattice &lt;: AbstractLattice{2}</code></pre><p>Type representing 2D Honeycomb Lattice.</p><p>Used as an argument of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a> function to produce tiling in a honeycomb pattern,  with number of site repetitions being specified by additional arguments of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a>. Honeycomb is a 2D Lattice, so there must be two integer arguments as additional inputs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; generate_sites(HoneycombLattice(), 5, 5)
50-element AtomList{2, Float64}:
 (0.0, 0.0)
 (0.5, 0.2886751345948129)
...
 (6.0, 3.4641016151377544)
 (6.5, 3.7527767497325675)
</code></pre><p>Overriden functions to return lattice vectors and sites exists as  <a href="#BloqadeLattices.lattice_vectors"><code>lattice_vectors(::HoneycombLattice)</code></a> and <a href="#BloqadeLattices.lattice_sites"><code>lattice_sites(::HoneycombLattice)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L70-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.TriangularLattice" href="#BloqadeLattices.TriangularLattice"><code>BloqadeLattices.TriangularLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TriangularLattice &lt;: AbstractLattice{2}</code></pre><p>Type representing 2D Square Lattice.</p><p>Used as an argument of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a> function to produce tiling in a triangle pattern,  with number of site repetitions being specified by additional arguments of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a>. Triangle is a 2D Lattice, so there must be two integer arguments as additional inputs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; generate_sites(TriangularLattice(), 3, 3)
9-element AtomList{2, Float64}:
 (0.0, 0.0)
 (1.0, 0.0)
 ...
 (2.0, 1.7320508075688772)
 (3.0, 1.7320508075688772)
</code></pre><p>Overriden functions to return lattice vectors and sites exists as  <a href="#BloqadeLattices.lattice_vectors"><code>lattice_vectors(::TriangularLattice)</code></a> and <a href="#BloqadeLattices.lattice_sites"><code>lattice_sites(::TriangularLattice)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L171-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.ChainLattice" href="#BloqadeLattices.ChainLattice"><code>BloqadeLattices.ChainLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ChainLattice &lt;: AbstractLattice{1}</code></pre><p>Type representing 1D Chain Lattice.</p><p>Used as an argument of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a> function to produce tiling in a chain pattern,  with number of site repetitions being specified by the additional argument of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a>. Chain is a 1D Lattice, so there must be one integer argument as additional inputs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; generate_sites(ChainLattice(), 5)
5-element AtomList{1, Float64}:
 (0.0,)
 (1.0,)
 (2.0,)
 (3.0,)
 (4.0,)</code></pre><p>Overriden functions to return lattice vectors and sites exists as  <a href="#BloqadeLattices.lattice_vectors"><code>lattice_vectors(::ChainLattice)</code></a> and <a href="#BloqadeLattices.lattice_sites"><code>lattice_sites(::ChainLattice)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L221-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.LiebLattice" href="#BloqadeLattices.LiebLattice"><code>BloqadeLattices.LiebLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LiebLattice &lt;: AbstractLattice{2}</code></pre><p>Type representing 2D Lieb Lattice.</p><p>Used as an argument of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a> function to produce tiling in a Lieb (square-depleted) pattern,  with number of site repetitions being specified by additional arguments of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a>. Lieb is a 2D Lattice, so there must be two integer arguments as additional inputs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; generate_sites(LiebLattice(), 3, 3)
27-element AtomList{2, Float64}:
 (0.0, 0.0)
 (0.5, 0.0)
...
 (2.5, 2.0)
 (2.0, 2.5)</code></pre><p>Overriden functions to return lattice vectors and sites exists as  <a href="#BloqadeLattices.lattice_vectors"><code>lattice_vectors(::LiebLattice)</code></a> and <a href="#BloqadeLattices.lattice_sites"><code>lattice_sites(::LiebLattice)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L269-L292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.KagomeLattice" href="#BloqadeLattices.KagomeLattice"><code>BloqadeLattices.KagomeLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct KagomeLattice &lt;: AbstractLattice{2}</code></pre><p>Type representing 2D Kagome Lattice.</p><p>Used as an argument of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a> function to produce tiling in a Kagome pattern,  with number of site repetitions being specified by additional arguments of <a href="#BloqadeLattices.generate_sites"><code>generate_sites</code></a>. Kagome is a 2D Lattice, so there must be two integer arguments as additional inputs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; generate_sites(KagomeLattice(), 3, 3)
27-element AtomList{2, Float64}:
 (0.0, 0.0)
 (0.25, 0.4330127018922193)
 ...
 (3.25, 2.1650635094610964)
 (3.75, 2.1650635094610964)</code></pre><p>Overriden functions to return lattice vectors and sites exists as  <a href="#BloqadeLattices.lattice_vectors"><code>lattice_vectors(::KagomeLattice)</code></a> and <a href="#BloqadeLattices.lattice_sites"><code>lattice_sites(::KagomeLattice)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L320-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.lattice_vectors" href="#BloqadeLattices.lattice_vectors"><code>BloqadeLattices.lattice_vectors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lattice_vectors(lattice::AbstractLattice)</code></pre><p>Returns Bravais lattice vectors as a D-Tuple of D-Tuple, where D is the space dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L56-L60">source</a></section><section><div><pre><code class="language-julia hljs">lattice_vectors(::HoneycombLattice)</code></pre><p>Returns the Bravais lattice vectors for a Honeycomb lattice as a Tuple of Tuples containing floats.</p><p>The vectors are defined as:</p><ul><li>𝐚₁ = (1.0, 0.0)</li><li>𝐚₂ = (0.5, 0.5√3)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L97-L106">source</a></section><section><div><pre><code class="language-julia hljs">lattice_vectors(::SquareLattice)</code></pre><p>Returns the Bravais lattice vectors for a Square lattice as a Tuple of Tuples containing floats.</p><p>The vectors are defined as:</p><ul><li>𝐚₁ = (1.0, 0.0)</li><li>𝐚₂ = (0.0, 1.0)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L148-L157">source</a></section><section><div><pre><code class="language-julia hljs">lattice_vectors(::TriangularLattice)</code></pre><p>Returns the Bravais lattice vectors for a Triangular lattice as a Tuple of Tuples containing floats.</p><p>The vectors are defined as:</p><ul><li>𝐚₁ = (1.0, 0.0)</li><li>𝐚₂ = (0.5, 0.5√3)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L198-L207">source</a></section><section><div><pre><code class="language-julia hljs">lattice_vectors(::ChainLattice)</code></pre><p>Returns the Bravais lattice vectors for a Chain lattice as a Tuple of Tuples containing floats.</p><p>The vectors are defined as:</p><ul><li>𝐚₁ = (1.0,)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L247-L255">source</a></section><section><div><pre><code class="language-julia hljs">lattice_vectors(::LiebLattice)</code></pre><p>Returns the Bravais lattice vectors for a Lieb lattice as a Tuple of Tuples containing floats.</p><p>The vectors are defined as:</p><ul><li>𝐚₁ = (1.0, 0.0)</li><li>𝐚₂ = (0.0, 1.0)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L295-L304">source</a></section><section><div><pre><code class="language-julia hljs">lattice_vectors(::KagomeLattice)</code></pre><p>Returns the Bravais lattice vectors for a Kagome lattice as a Tuple of Tuples containing floats.</p><p>The vectors are defined as:</p><ul><li>𝐚₁ = (1.0, 0.0)</li><li>𝐚₂ = (0.5, 0.5√3)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L346-L355">source</a></section><section><div><pre><code class="language-julia hljs">lattice_vectors(r::RectangularLattice)</code></pre><p>Returns the Bravais lattice vectors for a Rectangular lattice as a Tuple of Tuples containing floats.</p><p>The vectors are defined as:</p><ul><li>𝐚₁ = (1.0, 0.0)</li><li>𝐚₂ = (0.0, <code>r.aspect_ratio</code>), where <code>aspect_ratio</code> is a <code>Float64</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L400-L409">source</a></section><section><div><pre><code class="language-julia hljs">lattice_vectors(lattice::BoundedLattice{L,C})</code></pre><p>Returns the underlying Bravais lattice vectors of the <code>BoundedLattice</code></p><pre><code class="language-julia-repl hljs">julia&gt; bl = parallelepiped_region(SquareLattice(),(3,0),(0,2);) # create a 2D BoundedLattice

julia&gt; lattice_vectors(bl) # lattice vectors used in Bravais Lattice definition of underlying SquareLattice
((1.0, 0.0), (0.0, 1.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/bounded_lattice.jl#L96-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.lattice_sites" href="#BloqadeLattices.lattice_sites"><code>BloqadeLattices.lattice_sites</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lattice_sites(lattice::AbstractLattice)</code></pre><p>Returns sites in a Bravais lattice unit cell as a Tuple of D-Tuple, where D is the space dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L63-L67">source</a></section><section><div><pre><code class="language-julia hljs">lattice_sites(::HoneycombLattice)</code></pre><p>Returns the Bravais Lattice sites for a Honeycomb lattice as a Tuple of Tuples containing floats.</p><p>The sites are defined as:</p><ul><li>(0.0, 0.0)</li><li>(0.5, 0.5√3)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L109-L118">source</a></section><section><div><pre><code class="language-julia hljs">lattice_sites(::SquareLattice)</code></pre><p>Returns the Bravais Lattice sites for a Square lattice as a Tuple of Tuples containing floats.</p><p>The sites are defined as:</p><ul><li>(0.0, 0.0)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L160-L168">source</a></section><section><div><pre><code class="language-julia hljs">lattice_sites(::TriangularLattice)</code></pre><p>Returns the Bravais Lattice sites for a Triangular lattice as a Tuple of Tuples containing floats.</p><p>The sites are defined as:</p><ul><li>(0.0, 0.0)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L210-L218">source</a></section><section><div><pre><code class="language-julia hljs">lattice_sites(::ChainLattice)</code></pre><p>Returns the Bravais Lattice sites for a Chain lattice as a Tuple of Tuples containing floats.</p><p>The sites are defined as:</p><ul><li>(0.0,)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L258-L266">source</a></section><section><div><pre><code class="language-julia hljs">lattice_sites(::LiebLattice)</code></pre><p>Returns the Bravais Lattice sites for a Lieb lattice as a Tuple of Tuples containing floats.</p><p>The sites are defined as:</p><ul><li>(0.0, 0.0)</li><li>(0.5, 0.0)</li><li>(0.0, 0.5)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L307-L317">source</a></section><section><div><pre><code class="language-julia hljs">lattice_sites(::KagomeLattice)</code></pre><p>Returns the Bravais Lattice sites for a Lieb lattice as a Tuple of Tuples containing floats.</p><p>The sites are defined as:</p><ul><li>(0.0, 0.0)</li><li>(0.25, 0.25√3)</li><li>(0.75, 0.25√3)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L358-L368">source</a></section><section><div><pre><code class="language-julia hljs">lattice_sites(::RectangularLattice)</code></pre><p>Returns the Bravais Lattice sites for a Rectangular lattice as a Tuple of Tuples containing floats.</p><p>The sites are defined as:</p><ul><li>(0.0, 0.0)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L412-L420">source</a></section><section><div><pre><code class="language-julia hljs">lattice_sites(lattice::BoundedLattice{L,C})</code></pre><p>Returns the underlying site vectors that define the unit-cell of the <code>BoundedLattice</code></p><pre><code class="language-julia-repl hljs">julia&gt; bl = parallelepiped_region(SquareLattice(),(3,0),(0,2);) # create a 2D BoundedLattice

julia&gt; lattice_sites(bl) # lattice vectors used in Bravais Lattice definition of underlying SquareLattice
((0.0, 0.0), )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/bounded_lattice.jl#L110-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.dimension" href="#BloqadeLattices.dimension"><code>BloqadeLattices.dimension</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimension(::AbstractLattice{D})</code></pre><p>Returns the space dimension of target lattice. e.g. <a href="#BloqadeLattices.ChainLattice"><code>ChainLattice</code></a> is a 1D lattice, hence returns 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L15-L20">source</a></section><section><div><pre><code class="language-julia hljs">dimension(lattice::BoundedLattice{L,C})</code></pre><p>Returns the dimensions of the <code>BoundedLattice</code> (e.g.: <code>2</code> for 2D, <code>3</code> for 3D)</p><pre><code class="language-julia-repl hljs">julia&gt; bl = parallelepiped_region(ChainLattice(),(4,);pbc=true) # create a 1D BoundedLattice

julia&gt; dimension(bl)
1

julia&gt; bl = parallelepiped_region(SquareLattice(),(3,0),(0,2);) # create a 2D BoundedLattice

julia&gt; dimension(bl)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/bounded_lattice.jl#L77-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.generate_sites" href="#BloqadeLattices.generate_sites"><code>BloqadeLattices.generate_sites</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_sites(lattice::AbstractLattice{D}, repeats::Vararg{Int,D}; scale=1.0)</code></pre><p>Returns an <a href="#BloqadeLattices.AtomList"><code>AtomList</code></a> instance by tiling the specified <code>lattice</code>. The tiling repeat the <code>sites</code> of the lattice <code>m</code> times along the first dimension, <code>n</code> times along the second dimension, and so on. <code>scale</code> is a real number that re-scales the lattice constant and atom locations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L439-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.offset_axes" href="#BloqadeLattices.offset_axes"><code>BloqadeLattices.offset_axes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">offset_axes(sites::AtomList{D, T}, offsets::Vararg{T,D}) where {D, T}
offset_axes(offsets...)</code></pre><p>Offset the <code>sites</code> by distance specified by <code>offsets</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; sites = AtomList([(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)])
4-element AtomList{2, Float64}:
 (1.0, 2.0)
 (10.0, 3.0)
 (1.0, 12.0)
 (3.0, 5.0)

julia&gt; offset_axes(sites, 1.0, 3.0)
4-element AtomList{2, Float64}:
 (2.0, 5.0)
 (11.0, 6.0)
 (2.0, 15.0)
 (4.0, 8.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L454-L475">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.random_dropout" href="#BloqadeLattices.random_dropout"><code>BloqadeLattices.random_dropout</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_dropout(sites::AtomList{D, T}, ratio::Real) where {D, T}
random_dropout(ratio)</code></pre><p>Randomly drop out <code>ratio * number of sites</code> atoms from <code>sites</code>, where <code>ratio</code> ∈ [0, 1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L507-L512">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.rescale_axes" href="#BloqadeLattices.rescale_axes"><code>BloqadeLattices.rescale_axes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rescale_axes(sites::AtomList{D, T}, scale::Real) where {D, T}
rescale_axes(scale)</code></pre><p>Rescale the <code>sites</code> by a constant <code>scale</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; sites = AtomList([(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)])
4-element AtomList{2, Float64}:
 (1.0, 2.0)
 (10.0, 3.0)
 (1.0, 12.0)
 (3.0, 5.0)

julia&gt; rescale_axes(sites, 2.0)
4-element AtomList{2, Float64}:
 (2.0, 4.0)
 (20.0, 6.0)
 (2.0, 24.0)
 (6.0, 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L481-L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.clip_axes" href="#BloqadeLattices.clip_axes"><code>BloqadeLattices.clip_axes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clip_axes(sites::AtomList{D, T}, bounds::Vararg{Tuple{T,T},D}) where {D, T}
clip_axes(bounds...)</code></pre><p>Remove sites out of <code>bounds</code>, where <code>bounds</code> is specified by D D-tuples.</p><pre><code class="language-julia-repl hljs">julia&gt; sites = AtomList([(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)])
4-element AtomList{2, Float64}:
 (1.0, 2.0)
 (10.0, 3.0)
 (1.0, 12.0)
 (3.0, 5.0)

julia&gt; clip_axes(sites, (-5.0, 5.0), (-5.0, 5.0))
2-element AtomList{2, Float64}:
 (1.0, 2.0)
 (3.0, 5.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L519-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.MaskedGrid" href="#BloqadeLattices.MaskedGrid"><code>BloqadeLattices.MaskedGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MaskedGrid{T}
MaskedGrid(xs, ys, mask)</code></pre><p>Masked square lattice contains 3 fields, the x-coordinates, y-coordinates and a mask. e.g. <code>MaskedGrid([0.0, 1.0, 3.0], [0.0, 2.0,6.0], Bool[1 0 0; 0 1 1; 0 1 0])</code> specifies the following lattice:</p><pre><code class="nohighlight hljs">     y₁   y₂        y₃
     ↓    ↓         ↓
x₁ → ●    ⋅         ●
x₂ → ⋅    ●         ●

x₃ → ⋅    ●         ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L550-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.AtomList" href="#BloqadeLattices.AtomList"><code>BloqadeLattices.AtomList</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AtomList{D, T} &lt;: AbstractVector{NTuple{D, T}}
AtomList(atoms::Vector{&lt;:NTuple})</code></pre><p>A list of atoms in <code>D</code> dimensional space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L423-L428">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.make_grid" href="#BloqadeLattices.make_grid"><code>BloqadeLattices.make_grid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_grid(sites::AtomList; atol=...)</code></pre><p>Create a <a href="#BloqadeLattices.MaskedGrid"><code>MaskedGrid</code></a> from the sites. It is required by lattice preparation of Rydberg array. Because the grid will sort the sites by rows, we need <code>atol</code> (default value is 10 time sit data precision) determines up to what level of round off error, two atoms belong to the same row.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L573-L579">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.collect_atoms" href="#BloqadeLattices.collect_atoms"><code>BloqadeLattices.collect_atoms</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collect_atoms(maskedgrid::MaskedGrid)</code></pre><p>Returns an list of atoms in the <code>maskedgrid</code> in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/lattice.jl#L612-L616">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.img_atoms" href="#BloqadeLattices.img_atoms"><code>BloqadeLattices.img_atoms</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">img_atoms(atoms::Union{AtomList, BoundedLattice};
        colors = [DEFAULT_LINE_COLOR[], ...],
        texts = [&quot;1&quot;, &quot;2&quot;, ...],
        vectors = [],
        format = :svg,
        filename = nothing,
        kwargs...
    )</code></pre><p>Plots <code>atoms</code> or <code>bounded_lattice.site_positions</code> with colors specified by <code>colors</code> and texts specified by <code>texts</code>. You will need a <code>VSCode</code>, <code>Pluto</code> notebook or <code>Jupyter</code> notebook to show the image. If you want to write this image to the disk without displaying it in a frontend, please try</p><pre><code class="language-julia hljs">julia&gt; img_atoms(generate_sites(SquareLattice(), 5, 5); filename=&quot;test.png&quot;)</code></pre><p><strong>Keyword Arguments</strong></p><p><strong>features</strong></p><ul><li><code>colors</code> is a vector of colors for nodes</li><li><code>texts</code> is a vector of string displayed on nodes</li><li><code>vectors</code> is a vector of (start<em>loc, end</em>loc) pair to specify a list of arrows.</li></ul><p><strong>IO</strong></p><ul><li><code>format</code> can be <code>:svg</code>, <code>:pdf</code> or <code>:png</code></li><li><code>filename</code> can be a filename string with suffix <code>.svg</code>, <code>.png</code> or <code>.pdf</code></li></ul><p><strong>general</strong></p><ul><li><code>background_color = DEFAULT_BACKGROUND_COLOR[]</code></li><li><code>scale::Int = 60.0</code> is the number of pixels per unit length</li><li><code>xpad::Float64 = 2.5</code> is the padding space in x axis</li><li><code>ypad::Float64 = 1.5</code> is the padding space in y axis</li></ul><p><strong>axes</strong></p><ul><li><code>axes_text_color = DEFAULT_TEXT_COLOR[]</code></li><li><code>axes_text_fontsize::Float64 = 16.0</code></li><li><code>axes_num_of_xticks = 5</code></li><li><code>axes_num_of_yticks = 5</code></li><li><code>axes_x_offset::Float64 = 0.5</code></li><li><code>axes_y_offset::Float64 = 0.5</code></li><li><code>axes_unit::String = &quot;μm&quot;</code></li></ul><p><strong>node</strong></p><ul><li><code>node_text_fontsize::Float64 = 16.0</code></li><li><code>node_text_color = DEFAULT_TEXT_COLOR[]</code></li><li><code>node_stroke_color = DEFAULT_LINE_COLOR[]</code></li><li><code>node_stroke_linewidth = 1</code></li><li><code>node_fill_color = DEFAULT_NODE_COLOR[]</code></li></ul><p><strong>bond</strong></p><ul><li><code>bond_color = DEFAULT_LINE_COLOR[]</code></li><li><code>bond_linewidth::Float64 = 1.0</code></li></ul><p><strong>blockade</strong></p><ul><li><code>blockade_radius::Float64=0</code>, atoms within <code>blockade_radius</code> will be connected by edges.</li><li><code>blockade_style::String = &quot;none&quot;</code>, can be &quot;none&quot; or &quot;dashed&quot;</li><li><code>blockade_stroke_color = DEFAULT_LINE_COLOR[]</code></li><li><code>blockade_fill_color = &quot;transparent&quot;</code></li><li><code>blockade_fill_opacity::Float64 = 0.5</code></li><li><code>blockade_stroke_linewidth = 1.0</code>   # in pt</li></ul><p><strong>arrow</strong></p><ul><li><code>arrow_linewidth</code></li><li><code>arrow_color</code></li><li><code>arrow_head_length</code></li></ul><p><strong>grid</strong></p><ul><li><code>grid_stroke_color=&quot;#AAAAAA&quot;</code></li><li><code>grid_stroke_width::Float64=1</code></li><li><code>grid_stroke_style::String=&quot;dashed&quot;</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/visualize.jl#L135-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.img_maskedgrid" href="#BloqadeLattices.img_maskedgrid"><code>BloqadeLattices.img_maskedgrid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">img_maskedgrid(maskedgrid::MaskedGrid;
    colors=[DEFAULT_LINE_COLOR[], ...],
    texts=[&quot;1&quot;, &quot;2&quot;, ...],
    vectors=[],
    format=:svg,
    filename=nothing,
    kwargs...
    )</code></pre><p>Draw a <code>maskedgrid</code> with colors specified by <code>colors</code> and texts specified by <code>texts</code>. You will need a <code>VSCode</code>, <code>Pluto</code> notebook or <code>Jupyter</code> notebook to show the image.</p><p><strong>Keyword Arguments</strong></p><p><strong>features</strong></p><ul><li><code>colors</code> is a vector of colors for nodes</li><li><code>texts</code> is a vector of string displayed on nodes</li><li><code>vectors</code> is a vector of (start<em>loc, end</em>loc) pair to specify a list of arrows.</li></ul><p><strong>IO</strong></p><ul><li><code>format</code> can be <code>:svg</code>, <code>:pdf</code> or <code>:png</code></li><li><code>filename</code> can be a filename string with suffix <code>.svg</code>, <code>.png</code> or <code>.pdf</code></li></ul><p><strong>general</strong></p><ul><li><code>background_color = DEFAULT_BACKGROUND_COLOR[]</code></li><li><code>scale::Int = 60.0</code> is the number of pixels per unit length</li><li><code>xpad::Float64 = 2.5</code> is the padding space in x axis</li><li><code>ypad::Float64 = 1.5</code> is the padding space in y axis</li></ul><p><strong>axes</strong></p><ul><li><code>axes_text_color = DEFAULT_TEXT_COLOR[]</code></li><li><code>axes_text_fontsize::Float64 = 16.0</code></li><li><code>axes_num_of_xticks = 5</code></li><li><code>axes_num_of_yticks = 5</code></li><li><code>axes_x_offset::Float64 = 0.5</code></li><li><code>axes_y_offset::Float64 = 0.5</code></li><li><code>axes_unit::String = &quot;μm&quot;</code></li></ul><p><strong>node</strong></p><ul><li><code>node_text_fontsize::Float64 = 16.0</code></li><li><code>node_text_color = DEFAULT_TEXT_COLOR[]</code></li><li><code>node_stroke_color = DEFAULT_LINE_COLOR[]</code></li><li><code>node_stroke_linewidth = 1</code></li><li><code>node_fill_color = DEFAULT_NODE_COLOR[]</code></li></ul><p><strong>bond</strong></p><ul><li><code>bond_color = DEFAULT_LINE_COLOR[]</code></li><li><code>bond_linewidth::Float64 = 1.0</code></li></ul><p><strong>blockade</strong></p><ul><li><code>blockade_radius::Float64=0</code>, atoms within <code>blockade_radius</code> will be connected by edges.</li><li><code>blockade_style::String = &quot;none&quot;</code>, can be &quot;none&quot; or &quot;dashed&quot;</li><li><code>blockade_stroke_color = DEFAULT_LINE_COLOR[]</code></li><li><code>blockade_fill_color = &quot;transparent&quot;</code></li><li><code>blockade_fill_opacity::Float64 = 0.5</code></li><li><code>blockade_stroke_linewidth = 1.0</code>   # in pt</li></ul><p><strong>arrow</strong></p><ul><li><code>arrow_linewidth</code></li><li><code>arrow_color</code></li><li><code>arrow_head_length</code></li></ul><p><strong>grid</strong></p><ul><li><code>grid_stroke_color=&quot;#AAAAAA&quot;</code></li><li><code>grid_stroke_width::Float64=1</code></li><li><code>grid_stroke_style::String=&quot;dashed&quot;</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/visualize.jl#L297-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.ByDensity" href="#BloqadeLattices.ByDensity"><code>BloqadeLattices.ByDensity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ByDensity(values; colormap=&quot;Grays&quot;, vmin=minimum(values), vmax=maximum(values))</code></pre><p>For specifying the colors for density plots, where <code>values</code> are densities.</p><p><strong>Keyword arguments</strong></p><ul><li><code>colormap</code> is a string for specifying the color map, check the documentation of [<code>Colors</code>] package for the detailed description.</li><li><code>vmin</code> and <code>vmax</code> are the color range.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/visualize.jl#L276-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.AbstractRegion" href="#BloqadeLattices.AbstractRegion"><code>BloqadeLattices.AbstractRegion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractRegion{D}</code></pre><p>Supertype for all <code>D</code> dimensional regions used to define bounds on lattices.</p><p><strong>Implementation</strong></p><p>The following should be overriden:</p><ul><li><code>Base.in</code>: Returns <code>Bool</code> on whether a point exists in the region</li><li><code>Base.mod</code>: Maps points outside the region back into the region</li><li><code>distance</code>: Calculates distance between points with periodic boundary conditions enabled</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/region.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.Parallelepiped" href="#BloqadeLattices.Parallelepiped"><code>BloqadeLattices.Parallelepiped</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Parallelepiped{D, T} &lt;: AbstractRegion{D}</code></pre><p>Region that is a Parallelogram/Parallelepiped</p><p>See also <a href="#BloqadeLattices.Parallelepiped-Tuple{Any}"><code>Parallelepiped(vecs)</code></a>, <a href="#BloqadeLattices.Parallelepiped-Tuple{T} where T&lt;:Real"><code>Parallelepiped(vecs::T) where {T&lt;:Real}</code></a></p><p><strong>Fields</strong></p><ul><li><code>vecs::Matrix{T}</code>: Matrix with column vectors defining Parallelogram/Parallelepiped </li><li><code>vecs_inv::Matrix{T}</code>: Inverse of <code>vecs</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/region.jl#L100-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.Parallelepiped-Tuple{Any}" href="#BloqadeLattices.Parallelepiped-Tuple{Any}"><code>BloqadeLattices.Parallelepiped</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Parallelepiped(vecs)
Parallelepiped(vecs::T) where {T&lt;:Real}</code></pre><p>Define a region (either a line segment, parallelogram, or parallelepiped depending on the dimensions of <code>vecs</code>) using a single value or column vectors in a matrix that can be used to create a <a href="#BloqadeLattices.BoundedLattice"><code>BoundedLattice</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; Parallelepiped(2.0) # can bound a 1D lattice
Parallelepiped{1, Float64}([2.0;;], [0.5;;])

julia&gt; bounds = zeros((2,2)); # Create 2x2 matrix to store vectors defining 2D region

julia&gt; bounds[:,1] .= (3,3); bounds[:,2] .= (4,0); # Column Vectors define the Parallelogram

julia&gt; Parallelepiped(bounds)
Parallelepiped{2, Float64}([3.0 4.0; 3.0 0.0], [0.0 0.3333333333333333; 0.25 -0.25])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/region.jl#L117-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.Parallelepiped-Tuple{T} where T&lt;:Real" href="#BloqadeLattices.Parallelepiped-Tuple{T} where T&lt;:Real"><code>BloqadeLattices.Parallelepiped</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Parallelepiped(vecs)
Parallelepiped(vecs::T) where {T&lt;:Real}</code></pre><p>Define a region (either a line segment, parallelogram, or parallelepiped depending on the dimensions of <code>vecs</code>) using a single value or column vectors in a matrix that can be used to create a <a href="#BloqadeLattices.BoundedLattice"><code>BoundedLattice</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; Parallelepiped(2.0) # can bound a 1D lattice
Parallelepiped{1, Float64}([2.0;;], [0.5;;])

julia&gt; bounds = zeros((2,2)); # Create 2x2 matrix to store vectors defining 2D region

julia&gt; bounds[:,1] .= (3,3); bounds[:,2] .= (4,0); # Column Vectors define the Parallelogram

julia&gt; Parallelepiped(bounds)
Parallelepiped{2, Float64}([3.0 4.0; 3.0 0.0], [0.0 0.3333333333333333; 0.25 -0.25])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/region.jl#L117-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.distance" href="#BloqadeLattices.distance"><code>BloqadeLattices.distance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance(x, y)
distance(region::Parallelepiped{D,T},x,y)</code></pre><p>Distance between two points. </p><p>If just points <code>x</code> and <code>y</code> are provided, the Euclidean distance is calculated. </p><p>If a <code>region</code> is provided, then it is automatically assumed periodic boundary conditions are enabled and the smallest possible distance between the two points is returned.</p><pre><code class="language-julia-repl hljs">julia&gt; distance((0.0, 0.0), (1.0, 1.0))
1.4142135623730951

julia&gt; bounds = zeros(2,2); bounds[:,1] .= (3, 0); bounds[:,2] .= (0, 3);

julia&gt; distance(Parallelepiped(bounds), (0.5, 0.5), (2.5, 2.5))
1.4142135623730951</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/region.jl#L206-L226">source</a></section><section><div><pre><code class="language-julia hljs">distance(lattice::BoundedLattice,x,y)</code></pre><p>Returns the distance between two points in the <a href="#BloqadeLattices.BoundedLattice"><code>BoundedLattice</code></a>. </p><p>Points <code>x</code> and <code>y</code> can be any iterable and must have the same dimensions as the <a href="#BloqadeLattices.BoundedLattice"><code>BoundedLattice</code></a>  (ex: <code>(x,y)</code> for a 2D lattice, <code>(x,y,z)</code> for a 3D lattice).</p><p>If the Periodic Boundary Condition option has been set to <code>true</code> for the <a href="#BloqadeLattices.BoundedLattice"><code>BoundedLattice</code></a>, the smallest distance between points (modulo the region) is returned, otherwise the standard Euclidean metric is used.</p><pre><code class="language-julia-repl hljs">julia&gt; bl = parallelepiped_region(SquareLattice(), (1,0),(0,1);) # Define 2D BoundedLattice

julia&gt; distance(bl, (0.1, 0.1), (0.5, 1.1)) # distance between two points
1.077032961426901

julia&gt; bl_pbc = parallelepiped_region(SquareLattice(), (1,0),(0,1);pbc=true) # Define 2D BoundedLattice with Periodic Boundary Condition

julia&gt; distance(bl_pbc, (0.1, 0.1), (0.5, 1.1)) # distance with periodic boundary condition enabled
0.4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/bounded_lattice.jl#L133-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.generate_sites_in_region" href="#BloqadeLattices.generate_sites_in_region"><code>BloqadeLattices.generate_sites_in_region</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_sites_in_region(lattice::AbstractLattice{D}, region::AbstractRegion{D})</code></pre><p>Generates sites from the <code>lattice</code> that are present in the <code>region</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; generate_sites_in_region(ChainLattice(), Parallelepiped(4.0))
4-element Vector{Tuple{Float64}}:
 (0.0,)
 (1.0,)
 (2.0,)
 (3.0,)

julia&gt; bounds = zeros(2,2)
2×2 Matrix{Float64}:
 0.0  0.0
 0.0  0.0

julia&gt; bounds[:,1] .= (0.0, 2.0); bounds[:,2] .= (2.0, 0.0);

julia&gt; generate_sites_in_region(SquareLattice(), Parallelepiped(bounds))
4-element Vector{Tuple{Float64, Float64}}:
 (0.0, 0.0)
 (1.0, 0.0)
 (0.0, 1.0)
 (1.0, 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/region.jl#L43-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.BoundedLattice" href="#BloqadeLattices.BoundedLattice"><code>BloqadeLattices.BoundedLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BoundedLattice{L&lt;:AbstractLattice, R&lt;:AbstractRegion}</code></pre><p>Defines a lattice bounded by a region with the option for periodic boundary conditions.</p><p><strong>Fields</strong></p><ul><li><code>lattice &lt;: AbstractLattice</code>: Lattice to be bounded.</li><li><code>region &lt;: AbstractRegion</code>: Region that bounds the underlying <code>lattice</code>.</li><li><code>site_positions::AtomList</code>: Positions of the atoms inside <code>region</code>.</li><li><code>pbc::Bool</code>: Enable/Disable behavior for Periodic Boundary Conditions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/bounded_lattice.jl#L2-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.parallelepiped_region" href="#BloqadeLattices.parallelepiped_region"><code>BloqadeLattices.parallelepiped_region</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parallelepiped_region(lattice::AbstractLattice{D},M::Vararg{NTuple{D,Int},D};pbc::Bool=false;scale::Real=1)</code></pre><p>Create a <code>BoundedLattice</code> given an existing lattice and tuples defining a parallelogram/paralelepiped /line segment defined by vectors that are integer multiples of the lattice vectors in <code>lattice</code>.</p><p>Periodic Boundary Conditions can be enable/disabled via <code>pbc</code>. Tuples must be the same length and quantity as the dimensions of the lattice argument.</p><pre><code class="language-julia-repl hljs">julia&gt; parallelepiped_region(SquareLattice(),(2,0),(0,2);pbc=true);

julia&gt; parallelepiped_region(KagomeLattice(),(2,2),(-2,2));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/bounded_lattice.jl#L39-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.two_body_interaction_matrix" href="#BloqadeLattices.two_body_interaction_matrix"><code>BloqadeLattices.two_body_interaction_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">two_body_interaction_matrix(f, atoms)</code></pre><p>Generates an interaction matrix given a function <code>f</code> that accepts two atom positions at a time  and an indexable iterable <code>atoms</code> containing atom positions.</p><p>See also <a href="#BloqadeLattices.rydberg_interaction_matrix"><code>rydberg_interaction_matrix</code></a></p><pre><code class="language-julia-repl hljs">julia&gt; atoms = [(0.0,), (1.0,), (2.0,), (3.0,)]; # 1D chain, can also be AtomList

julia&gt; two_body_interaction_matrix(atoms) do x,y return 1/distance(x,y) end
4×4 UpperTriangular{Float64, Matrix{Float64}}:
 0.0  1.0  0.5  0.333333
  ⋅   0.0  1.0  0.5
  ⋅    ⋅   0.0  1.0
  ⋅    ⋅    ⋅   0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/interact.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BloqadeLattices.rydberg_interaction_matrix" href="#BloqadeLattices.rydberg_interaction_matrix"><code>BloqadeLattices.rydberg_interaction_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rydberg_interaction_matrix(atoms, C::Real)
rydberg_interaction_matrix(lattice::BoundedLattice{L,R},C::Real)</code></pre><p>Generate the interaction matrix given an indexable iterable <code>atoms</code> containg atom positions and the Rydberg interaction constant <code>C</code>.</p><p>A <code>BoundedLattice</code> can be used in place of <code>atoms</code> which generates the Rydberg interaction matrix for the lattice, factoring in Periodic Boundary Conditions.</p><p>See also <a href="#BloqadeLattices.two_body_interaction_matrix"><code>two_body_interaction_matrix</code></a></p><pre><code class="language-julia-repl hljs">julia&gt; atoms = [(0.0,), (1.0,), (2.0,), (3.0,)]; # 1D chain of atoms

julia&gt; rydberg_interaction_matrix(atoms, 2π * 862690) # provide Rydberg constant
4×4 UpperTriangular{Float64, Matrix{Float64}}:
 0.0  5.42044e6  84694.4         7435.45
  ⋅   0.0            5.42044e6  84694.4
  ⋅    ⋅             0.0            5.42044e6
  ⋅    ⋅              ⋅             0.0

julia&gt; bl = parallelepiped_region(SquareLattice(),(2,0),(0,2);pbc=true); 

julia&gt; rydberg_interaction_matrix(bl, 2π * 862690)
4×4 UpperTriangular{Float64, Matrix{Float64}}:
 0.0  5.42044e6  5.42044e6  6.77555e5
  ⋅   0.0        6.77555e5  5.42044e6
  ⋅    ⋅         0.0        5.42044e6
  ⋅    ⋅          ⋅         0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/a08355caf4403e8215a672b2cf1641065d213742/lib/BloqadeLattices/src/interact.jl#L34-L65">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../julia/">« The Julia Programming Language</a><a class="docs-footer-nextpage" href="../waveform/">Waveforms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 7 November 2024 16:01">Thursday 7 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
