<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Maximum Independent Set · Bloqade.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://QuEraComputing.github.io/Bloqade.jl/mis/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Bloqade.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Bloqade.jl logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../julia/">The Julia Programming Language</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../lattices/">Lattices</a></li><li><a class="tocitem" href="../waveform/">Waveforms</a></li><li><a class="tocitem" href="../hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../registers/">Registers and Observables</a></li><li><a class="tocitem" href="../emulation/">Emulation</a></li><li><a class="tocitem" href="../subspace/">Working with Subspace</a></li><li><a class="tocitem" href="../units/">Working with Units</a></li><li class="is-active"><a class="tocitem" href>Maximum Independent Set</a><ul class="internal"><li><a class="tocitem" href="#The-Maximum-Independent-Set-Problem"><span>The Maximum Independent Set Problem</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../cuda/">GPU Acceleration</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/1.blockade/main/">Rydberg Blockade</a></li><li><a class="tocitem" href="../tutorials/2.adiabatic/main/">Adiabatic Evolution</a></li><li><a class="tocitem" href="../tutorials/3.quantum-scar/main/">Quantum Scar</a></li><li><a class="tocitem" href="../tutorials/4.LGT/main/">Simulation of lattice gauge theory with Rydberg atoms</a></li><li><a class="tocitem" href="../tutorials/5.MIS/main/">The Maximum Independent Set Problem</a></li><li><a class="tocitem" href="../tutorials/6.MWIS/main/">Maximum Weight Independent Set</a></li></ul></li><li><a class="tocitem" href="../contrib/">Contributing to Bloqade</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Maximum Independent Set</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Maximum Independent Set</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuEraComputing/Bloqade.jl/blob/master/docs/src/mis.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="mis"><a class="docs-heading-anchor" href="#mis">Maximum Independent Set</a><a id="mis-1"></a><a class="docs-heading-anchor-permalink" href="#mis" title="Permalink"></a></h1><p><a href="../tutorials/1.blockade/main/#blockade">Rydberg Blockade</a> is one of the most important properties of neutral-atom quantum computing based on Rydberg states.  It naturally encodes the <a href="https://en.wikipedia.org/wiki/Independent_set_(graph_theory)">independent set</a> constraint.  More specifically, Rydberg blockade implies that two atoms cannot be both excited to the Rydberg state <span>$|r\rangle$</span> if they are close to each other,  whereas independent set constraint means two vertices cannot be both in the independent set when they are connected by an edge. Thus, one can consider atoms in the Rydberg state as vertices in an independent set. See the proposal in <a href="https://arxiv.org/pdf/1808.10816.pdf">H. Pichler, et al.</a> for more details. </p><p>In particular, one can use the ground state of the <a href="../hamiltonians/#Hamiltonians">Rydberg Hamiltonian</a> to encode the <a href="https://en.wikipedia.org/wiki/Independent_set_(graph_theory)">maximum independent set problem</a>,  which is to find the largest independent set of a given graph.  For a particular subclass of geometric graphs, the so-called unit disk graphs,  the Rydberg Hamiltonian can encode the solution without any overhead in the number of qubits.  In fact, an experimental demonstration of quantum optimization has been realized in solving the maximum independent set problem up to 289 qubits in <a href="https://arxiv.org/abs/2202.09372">S. Ebadi, et al.</a>.</p><p>In Bloqade, we provide several functions to support the simulation of solving independent set problems on neutral-atom quantum computers. We list them here in this section.</p><h2 id="The-Maximum-Independent-Set-Problem"><a class="docs-heading-anchor" href="#The-Maximum-Independent-Set-Problem">The Maximum Independent Set Problem</a><a id="The-Maximum-Independent-Set-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Maximum-Independent-Set-Problem" title="Permalink"></a></h2><p>In graph theory, an independent set is a set of vertices in a graph such that no two of which are connected by an edge. The problem of finding maximum independent sets (MIS) is NP-hard, i.e., it is unlikely to be solved in a time polynomial to the problem size. However, for a graph with a small to intermediate size, various solution space properties, including finding the MIS size and enumerating all MISs, can be computed using the package <a href="https://github.com/QuEraComputing/GenericTensorNetworks.jl"><code>GenericTensorNetworks</code></a>; please also refer to the related manual pages <a href="https://queracomputing.github.io/GenericTensorNetworks.jl/dev/tutorials/IndependentSet/">the independent set problem</a> and <a href="https://queracomputing.github.io/GenericTensorNetworks.jl/dev/tutorials/MaximalIS/">the maximal independent set problem</a>.</p><p>A tutorial on how to solve the MIS problem using Bloqade is detailed in the <a href="../tutorials/5.MIS/main/#mis-tutorial">MIS tutorial</a> page.</p><p>In the following, we list the APIs in the module <code>BloqadeMIS</code>, many of which support the simulation of variational quantum algorithms for solving the MIS problem.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.add_random_vertices" href="#BloqadeMIS.add_random_vertices"><code>BloqadeMIS.add_random_vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_random_vertices([rng=GLOBAL_RNG], config::AbstractVector, graph::AbstractGraph, ntrials::Int = 10)</code></pre><p>Add vertices randomly to given configuration for <code>ntrials</code> times and pick the one that has largest <a href="#BloqadeMIS.count_vertices-Tuple{Integer}"><code>count_vertices</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: optional, Random Number Generator.</li><li><code>config</code>: configuration to tweak.</li><li><code>graph</code>: problem graph.</li><li><code>ntrials</code>: number of trials to use, default is <code>10</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/loss.jl#L249-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.anyone-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer" href="#BloqadeMIS.anyone-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>BloqadeMIS.anyone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">anyone(index::Integer, mask::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if any masked position of index is 1.</p><p><strong>Example</strong></p><p><code>true</code> if any masked positions is 1.</p><pre><code class="language-julia-repl hljs">julia&gt; anyone(0b1011, 0b1001)
true
julia&gt; anyone(0b1011, 0b1100)
true
julia&gt; anyone(0b1011, 0b0100)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/bsubspace.jl#L33-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.blockade_subspace" href="#BloqadeMIS.blockade_subspace"><code>BloqadeMIS.blockade_subspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">blockade_subspace(atoms[, radius=1.0])</code></pre><p>Create a blockade approximation subspace from given atom positions and radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/subspace.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.bmask" href="#BloqadeMIS.bmask"><code>BloqadeMIS.bmask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bmask(::Type{T}) where T &lt;: Integer -&gt; zero(T)
bmask([T::Type], positions::Int...) -&gt; T
bmask([T::Type], range::UnitRange{Int}) -&gt; T</code></pre><p>Return an integer mask of type <code>T</code> where <code>1</code> is the position masked according to <code>positions</code> or <code>range</code>. Directly use <code>T</code> will return an empty mask <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/bsubspace.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.count_vertices-Tuple{Integer}" href="#BloqadeMIS.count_vertices-Tuple{Integer}"><code>BloqadeMIS.count_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_vertices(config::Integer)</code></pre><p>counter the number of vertices in a spin configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/loss.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.create_subspace_from_mis-Union{Tuple{T}, Tuple{Type{T}, Int64, AbstractVector}} where T" href="#BloqadeMIS.create_subspace_from_mis-Union{Tuple{T}, Tuple{Type{T}, Int64, AbstractVector}} where T"><code>BloqadeMIS.create_subspace_from_mis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_subspace_from_mis(T, n::Int, mis::AbstractVector)</code></pre><p>Create <code>Subspace</code> from given list of maximal cliques/maximal independent set.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: number of vertices of the graph.</li><li><code>mis</code>: the list of maximal independent set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/subspace.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.exact_solve_mis-Tuple{Graphs.AbstractGraph}" href="#BloqadeMIS.exact_solve_mis-Tuple{Graphs.AbstractGraph}"><code>BloqadeMIS.exact_solve_mis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exact_solve_mis(g::AbstractGraph)</code></pre><p>Return the exact MIS size of a graph <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/loss.jl#L242-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.gibbs_loss-Tuple{Any, Real}" href="#BloqadeMIS.gibbs_loss-Tuple{Any, Real}"><code>BloqadeMIS.gibbs_loss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gibbs_loss([f], reg_or_samples, α::Real)</code></pre><p>The Gibbs loss for maximum independent set defined as</p><p class="math-container">\[L = -1/α \log(\langle ψ|\exp(α \sum(n))|ψ\rangle),\]</p><p>where <code>n</code> is the vertex set size.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: optional, postprocessing callback function <code>f(config) -&gt; config</code>.   The input <code>config</code> is an integer of type <code>Int</code>, the output   <code>config</code> can be a type supports <a href="#BloqadeMIS.count_vertices-Tuple{Integer}"><code>count_vertices</code></a>   e.g, an <code>AbstractVector</code> or an <code>Integer</code>.</li><li><code>reg_or_samples</code> can be a register (<code>Yao.ArrayReg</code> or <a href="../registers/#YaoSubspaceArrayReg.SubspaceArrayReg"><code>SubspaceArrayReg</code></a>)   or a list of measurement result (config) in <code>AbstractVector</code>.</li><li><code>α::Real</code>: the parameter of Gibbs loss.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/loss.jl#L119-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.independent_set_probabilities" href="#BloqadeMIS.independent_set_probabilities"><code>BloqadeMIS.independent_set_probabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">independent_set_probabilities([f], reg::YaoAPI.AbstractRegister, graph_or_mis)</code></pre><p>Calculate the probabilities of independent sets with given postprocessing function <code>f(config) -&gt; config</code>. The default postprocessing function <code>f</code> will only reduce all configurations to independent set.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: optional, postprocessing function, default is <a href="#BloqadeMIS.to_independent_set-Tuple{Integer, Graphs.AbstractGraph}"><code>to_independent_set</code></a>.</li><li><code>reg</code>: required, the register object.</li><li><code>graph_or_mis</code>: a problem graph or the MIS size of the problem   graph (can be calculated via <a href="#BloqadeMIS.exact_solve_mis-Tuple{Graphs.AbstractGraph}"><code>exact_solve_mis</code></a>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/loss.jl#L303-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.independent_set_subspace-Union{Tuple{T}, Tuple{Type{T}, Graphs.SimpleGraphs.SimpleGraph}} where T" href="#BloqadeMIS.independent_set_subspace-Union{Tuple{T}, Tuple{Type{T}, Graphs.SimpleGraphs.SimpleGraph}} where T"><code>BloqadeMIS.independent_set_subspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">independent_set_subspace([T, ]graph)</code></pre><p>Create a subspace from given graph&#39;s maximal independent set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/subspace.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.is_independent_set-Tuple{Any, Graphs.AbstractGraph}" href="#BloqadeMIS.is_independent_set-Tuple{Any, Graphs.AbstractGraph}"><code>BloqadeMIS.is_independent_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_independent_set(config, graph::AbstractGraph)</code></pre><p>Return <code>true</code> if <code>config</code> is an independent set of graph. <code>config</code> can be a <code>BitStr</code>, a vector, or any iterable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/loss.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.ismatch-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer" href="#BloqadeMIS.ismatch-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer"><code>BloqadeMIS.ismatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ismatch(index::Integer, mask::Integer, target::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if bits at positions masked by <code>mask</code> equal to <code>1</code> are equal to <code>target</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; n = 0b11001; mask = 0b10100; target = 0b10000;

julia&gt; ismatch(n, mask, target)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/bsubspace.jl#L51-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.mis_postprocessing-Tuple{Any, Graphs.AbstractGraph}" href="#BloqadeMIS.mis_postprocessing-Tuple{Any, Graphs.AbstractGraph}"><code>BloqadeMIS.mis_postprocessing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mis_postprocessing(config, graph::AbstractGraph; ntrials::Int=10)</code></pre><p>The postprocessing protocal used in Harvard experiment for finding MISs: <a href="https://arxiv.org/abs/2202.09372">arxiv:2202.09372</a>, which includes a combination of <a href="#BloqadeMIS.to_independent_set-Tuple{Integer, Graphs.AbstractGraph}"><code>to_independent_set</code></a> and <a href="#BloqadeMIS.add_random_vertices"><code>add_random_vertices</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>config</code>: configuration to postprocess.</li><li><code>graph</code>: the problem graph.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ntrials</code>: number of trials to use.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/loss.jl#L367-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.mis_postprocessing-Tuple{Graphs.AbstractGraph}" href="#BloqadeMIS.mis_postprocessing-Tuple{Graphs.AbstractGraph}"><code>BloqadeMIS.mis_postprocessing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mis_postprocessing(graph::AbstractGraph; ntrials::Int = 10)</code></pre><p>Curried version of <a href="#BloqadeMIS.mis_postprocessing-Tuple{Any, Graphs.AbstractGraph}"><code>mis_postprocessing</code></a>.</p><p><strong>Example</strong></p><p>to calculate <code>rydberg_density_sum</code> loss with postprocessing used in Harvard experiment: <a href="https://arxiv.org/abs/2202.09372">arxiv:2202.09372</a>.</p><pre><code class="language-julia hljs">rydberg_density_sum(mis_postprocessing(graph), reg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/loss.jl#L388-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.num_mis_violation-Tuple{Any, Graphs.AbstractGraph, Int64}" href="#BloqadeMIS.num_mis_violation-Tuple{Any, Graphs.AbstractGraph, Int64}"><code>BloqadeMIS.num_mis_violation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_mis_violation(config, graph::AbstractGraph, i::Int)</code></pre><p>Calculate the number of MIS violations for <code>i</code>-th vertex in <code>graph</code> and configuration <code>config</code>. The <code>config</code> should be a subtype of <code>AbstractVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/loss.jl#L226-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.rydberg_density_sum" href="#BloqadeMIS.rydberg_density_sum"><code>BloqadeMIS.rydberg_density_sum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rydberg_density_sum([f], reg_or_samples)</code></pre><p>Sum of rydberg density.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: optional, postprocessing callback function <code>f(config) -&gt; config</code>.   The input <code>config</code> is an integer of type <code>Int</code>, the output   <code>config</code> can be a type supports <a href="#BloqadeMIS.count_vertices-Tuple{Integer}"><code>count_vertices</code></a>   e.g, an <code>AbstractVector</code> or an <code>Integer</code>.</li><li><code>reg_or_samples</code> can be a register (<code>Yao.ArrayReg</code> or <a href="../registers/#YaoSubspaceArrayReg.SubspaceArrayReg"><code>SubspaceArrayReg</code></a>)   or a list of measurement result (config) in <code>AbstractVector</code>.</li></ul><p><strong>Example</strong></p><p>To implement the postprocessing protocal in MIS experiment:</p><ol><li>calculating <code>rydberg_density_sum</code> by first reducing the configuration</li></ol><p>to independent set using <a href="#BloqadeMIS.to_independent_set-Tuple{Integer, Graphs.AbstractGraph}"><code>to_independent_set</code></a></p><ol><li>randomly adding vertices then pick the largest <a href="#BloqadeMIS.count_vertices-Tuple{Integer}"><code>count_vertices</code></a></li></ol><p>using <a href="#BloqadeMIS.add_random_vertices"><code>add_random_vertices</code></a>.</p><pre><code class="language-julia hljs">rydberg_density_sum(r) do config
    config = to_independent_set(config, graph)
    add_random_vertices(config, graph, 10)
    return config
end</code></pre><p>Or one can also just add vertice by atom order</p><pre><code class="language-julia hljs">rydberg_density_sum(r) do config
    config = to_independent_set(config, graph)
    add_vertices!(config, graph)
    return config
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/loss.jl#L9-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.to_independent_set!-Tuple{AbstractVector, Graphs.AbstractGraph}" href="#BloqadeMIS.to_independent_set!-Tuple{AbstractVector, Graphs.AbstractGraph}"><code>BloqadeMIS.to_independent_set!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_independent_set!(config::AbstractVector, graph::AbstractGraph)</code></pre><p>Eliminate vertices in <code>config</code> so that remaining vertices do not have connected edges. This algorithm is a naive vertex elimination that does not nesesarily give the maximum possible vertex set.</p><pre><code class="language- hljs"># run the following code in Atom/VSCode
atoms = [(0.0, 1.0), (1.0, 0.), (2.0, 0.0), (1.0, 1.0), (1.0, 2.0), (2.0, 2.0)]
graph = unit_disk_graph(atoms, 1.5)

config = [1, 1, 1, 0, 1, 1]
viz_config(atoms, graph, config)

to_independent_set!(config, graph)
viz_config(atoms, graph, config)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/loss.jl#L180-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.to_independent_set-Tuple{Integer, Graphs.AbstractGraph}" href="#BloqadeMIS.to_independent_set-Tuple{Integer, Graphs.AbstractGraph}"><code>BloqadeMIS.to_independent_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_independent_set(config::Integer, graph::AbstractGraph)</code></pre><p>Eliminate vertices in <code>config</code> so that remaining vertices do not have connected edges without changing the original config, see also <a href="#BloqadeMIS.to_independent_set!-Tuple{AbstractVector, Graphs.AbstractGraph}"><code>to_independent_set!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/loss.jl#L212-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeMIS.unit_disk_graph" href="#BloqadeMIS.unit_disk_graph"><code>BloqadeMIS.unit_disk_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unit_disk_graph(atoms::AbstractVector, radius=1)</code></pre><p>Create a unit disk graph from atom positions <code>atoms</code>. It returns a <code>Graphs.SimpleGraph</code> instance.</p><ul><li><code>atoms</code> is vector of atoms positions.</li><li><code>radius</code> is the unit in the unit disk graph definition.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/fe99235c373f6448331931a127b745c569eb2208/lib/BloqadeMIS/src/unit_disk_graph.jl#L1-L7">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../units/">« Working with Units</a><a class="docs-footer-nextpage" href="../cuda/">GPU Acceleration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Monday 22 August 2022 23:25">Monday 22 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
