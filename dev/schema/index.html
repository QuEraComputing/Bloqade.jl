<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interacting with Neutral Atom Hardware · Bloqade.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-SRKGL6MJHS"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-SRKGL6MJHS', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://QuEraComputing.github.io/Bloqade.jl/schema/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Bloqade.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Bloqade.jl logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../julia/">The Julia Programming Language</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../lattices/">Lattices</a></li><li><a class="tocitem" href="../waveform/">Waveforms</a></li><li><a class="tocitem" href="../hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../registers/">Registers and Observables</a></li><li><a class="tocitem" href="../emulation/">Emulation</a></li><li><a class="tocitem" href="../subspace/">Working with Subspace</a></li><li><a class="tocitem" href="../units/">Working with Units</a></li><li><a class="tocitem" href="../mis/">Maximum Independent Set</a></li><li><a class="tocitem" href="../multithreading/">CPU Acceleration</a></li><li><a class="tocitem" href="../cuda/">GPU Acceleration</a></li><li><a class="tocitem" href="../3-level/">3-Level Support and Quantum Gates</a></li><li class="is-active"><a class="tocitem" href>Interacting with Neutral Atom Hardware</a><ul class="internal"><li><a class="tocitem" href="#Transforming-Hamiltonians-to-Hardware-Compatible-Form"><span>Transforming Hamiltonians to Hardware Compatible Form</span></a></li><li><a class="tocitem" href="#Validating-Hamiltonians"><span>Validating Hamiltonians</span></a></li><li><a class="tocitem" href="#Converting-Between-Formats"><span>Converting Between Formats</span></a></li><li><a class="tocitem" href="#Submitting-to-Amazon-Braket"><span>Submitting to Amazon Braket</span></a></li><li><a class="tocitem" href="#Inspecting-Results-from-Braket"><span>Inspecting Results from Braket</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../capabilities/">Hardware Capabilities</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/1.blockade/main/">Rydberg Blockade</a></li><li><a class="tocitem" href="../tutorials/2.adiabatic/main/">Adiabatic Evolution</a></li><li><a class="tocitem" href="../tutorials/3.quantum-scar/main/">Quantum Scar</a></li><li><a class="tocitem" href="../tutorials/4.LGT/main/">Simulation of a Lattice Gauge Theory with Rydberg Atoms</a></li><li><a class="tocitem" href="../tutorials/5.MIS/main/">The Maximum Independent Set Problem</a></li><li><a class="tocitem" href="../tutorials/6.MWIS/main/">Maximum Weight Independent Set</a></li><li><a class="tocitem" href="../tutorials/7.QMC/main/">Quantum Monte Carlo Method</a></li></ul></li><li><a class="tocitem" href="../contrib/">Contributing to Bloqade</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Interacting with Neutral Atom Hardware</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interacting with Neutral Atom Hardware</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuEraComputing/Bloqade.jl/blob/master/docs/src/schema.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="schema"><a class="docs-heading-anchor" href="#schema">Interacting with Neutral Atom Hardware</a><a id="schema-1"></a><a class="docs-heading-anchor-permalink" href="#schema" title="Permalink"></a></h1><p>Bloqade contains its own schema used to represent Hamiltonians in an IR (Intermediate Representation) that can then be executed via simulator/hardware as well as converted to and from other formats. Furthermore, tools such as <a href="#BloqadeSchema.hardware_transform"><code>hardware_transform</code></a> and <a href="#BloqadeSchema.validate"><code>validate</code></a> are available to check that user-defined Hamiltonians are capable of being executed on hardware and if not, transform them to be able to do so.</p><div class="admonition is-warning"><header class="admonition-header">3-Level Support</header><div class="admonition-body"><p>The schema and conversion capabilities are currently not available for 3-level Hamiltonians</p></div></div><h2 id="Transforming-Hamiltonians-to-Hardware-Compatible-Form"><a class="docs-heading-anchor" href="#Transforming-Hamiltonians-to-Hardware-Compatible-Form">Transforming Hamiltonians to Hardware Compatible Form</a><a id="Transforming-Hamiltonians-to-Hardware-Compatible-Form-1"></a><a class="docs-heading-anchor-permalink" href="#Transforming-Hamiltonians-to-Hardware-Compatible-Form" title="Permalink"></a></h2><p>We start with creating a hamiltonian:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Bloqade, BloqadeSchema</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Δ = constant(;duration=1.1, value=1.2*2π);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Ω = linear_ramp(duration=1.1, start_value=0.0, stop_value=2π*1.0);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ϕ = Waveform(t-&gt;2.2*2π*sin(t)^2, duration=1.1);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = generate_sites(ChainLattice(), 4, scale=1.0);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h = rydberg_h(atoms; Δ = Δ, Ω = Ω, ϕ = ϕ)</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 4
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] Ω(t) ⋅∑ e^{ϕ(t) ⋅ im} |0⟩⟨1| + e^{-ϕ(t) ⋅ im} |1⟩⟨0|
└─ [-] Δ(t) ⋅ ∑ n_i</code></pre><p>To transform the Hamiltonian into something the hardware is capable of supporting, we can pass it through <a href="#BloqadeSchema.hardware_transform"><code>hardware_transform</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Limitations on Transformations</header><div class="admonition-body"><p>While <code>hardware_transform</code> may attempt to adjust atom positions so that they conform to hardware position resolution capabilities, the function will NOT move atoms such that they satisfy minimum spacing constraints. The <code>validate</code> function presented later will explicitly indicate which atoms are in violation of the position constraints but will require the user to make the necessary changes.</p><p>Furthermore, <code>hardware_transform</code> requires that all waveforms the Hamiltonian could use (Rabi frequency, detuning, and phase) are explicitly specified even if they are not used. To indicate non-use of a waveform, <a href="../waveform/#BloqadeWaveforms.constant"><code>BloqadeWaveforms.constant</code></a> should be used with the value set to zero.</p></div></div><p><code>hardware_transform</code> accepts information from <a href="#BloqadeSchema.get_device_capabilities"><code>get_device_capabilities</code></a> (already called as a default argument) which provides information on the machine&#39;s capabilities and returns the transformed hamiltonian along with additional information regarding the difference (error) between the originally defined lattice geometry and waveforms versus their transformed versions through a <a href="#BloqadeSchema.HardwareTransformInfo"><code>HardwareTransformInfo</code></a> instance.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; transformed_h, transform_info = hardware_transform(h);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transformed_h</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 4
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] Ω(t) ⋅∑ e^{ϕ(t) ⋅ im} |0⟩⟨1| + e^{-ϕ(t) ⋅ im} |1⟩⟨0|
└─ [-] Δ(t) ⋅ ∑ n_i</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transform_info</code><code class="nohighlight hljs ansi" style="display:block;">HardwareTransformInfo(0.19634919330815342, 0.13983001873346415, 3.452294642629581e-8, (Δ = Waveform(_, 1.1), δ = nothing, Δi = 1.0), 0.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dump(transform_info)</code><code class="nohighlight hljs ansi" style="display:block;">HardwareTransformInfo
  ϕ_error: Float64 0.19634919330815342
  Ω_error: Float64 0.13983001873346415
  Δ_error: Float64 3.452294642629581e-8
  Δ_mask: NamedTuple{(:Δ, :δ, :Δi), Tuple{Waveform{BloqadeWaveforms.var&quot;#39#40&quot;{Float64}, Float64}, Nothing, Float64}}
    Δ: Waveform{BloqadeWaveforms.var&quot;#39#40&quot;{Float64}, Float64}
      f: #39 (function of type BloqadeWaveforms.var&quot;#39#40&quot;{Float64})
        value: Float64 7.5398223686155035
      duration: Float64 1.1
    δ: Nothing nothing
    Δi: Float64 1.0
  mse_atoms: Float64 0.0</code></pre><h2 id="Validating-Hamiltonians"><a class="docs-heading-anchor" href="#Validating-Hamiltonians">Validating Hamiltonians</a><a id="Validating-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Validating-Hamiltonians" title="Permalink"></a></h2><p>We can see if this hamiltonian or any other hamiltonian we create will run on hardware with the help of <a href="#BloqadeSchema.validate"><code>validate</code></a>. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; validate(transformed_h)</code><code class="nohighlight hljs ansi" style="display:block;">The following validation violations occured:

1. positions 3 =&gt; (2.0, 0.0) and 4 =&gt; (3.0, 0.0) are a distance of 1.0 μm apart which is below minimum value of 4.0 μm
2. positions 2 =&gt; (1.0, 0.0) and 3 =&gt; (2.0, 0.0) are a distance of 1.0 μm apart which is below minimum value of 4.0 μm
3. positions 2 =&gt; (1.0, 0.0) and 4 =&gt; (3.0, 0.0) are a distance of 2.0 μm apart which is below minimum value of 4.0 μm
4. positions 1 =&gt; (0.0, 0.0) and 4 =&gt; (3.0, 0.0) are a distance of 3.0 μm apart which is below minimum value of 4.0 μm
5. positions 1 =&gt; (0.0, 0.0) and 2 =&gt; (1.0, 0.0) are a distance of 1.0 μm apart which is below minimum value of 4.0 μm
6. positions 1 =&gt; (0.0, 0.0) and 3 =&gt; (2.0, 0.0) are a distance of 2.0 μm apart which is below minimum value of 4.0 μm</code></pre><p>In this case, the waveforms have been successfully transformed but there are still some issues with the atom positions. We can rescale their positions, regenerate the Hamiltonian and validate again to make sure the changes are correct.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = generate_sites(ChainLattice(), 4, scale=4.0);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fixed_h = rydberg_h(atoms; Δ = Δ, Ω = Ω, ϕ = ϕ) # Keep older waveforms with new atom geometry</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 4
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] Ω(t) ⋅∑ e^{ϕ(t) ⋅ im} |0⟩⟨1| + e^{-ϕ(t) ⋅ im} |1⟩⟨0|
└─ [-] Δ(t) ⋅ ∑ n_i</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transformed_h, _ = hardware_transform(fixed_h)</code><code class="nohighlight hljs ansi" style="display:block;">(nqubits: 4
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] Ω(t) ⋅∑ e^{ϕ(t) ⋅ im} |0⟩⟨1| + e^{-ϕ(t) ⋅ im} |1⟩⟨0|
└─ [-] Δ(t) ⋅ ∑ n_i
, HardwareTransformInfo(0.19634919330815342, 0.13983001873346415, 3.452294642629581e-8, (Δ = Waveform(_, 1.1), δ = nothing, Δi = 1.0), 0.0))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; validate(transformed_h)</code><code class="nohighlight hljs ansi" style="display:block;">The following validation violations occured:</code></pre><p>No violations are present meaning the new Hamiltonian has passed validation and can now be executed on hardware.</p><h2 id="Converting-Between-Formats"><a class="docs-heading-anchor" href="#Converting-Between-Formats">Converting Between Formats</a><a id="Converting-Between-Formats-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-Between-Formats" title="Permalink"></a></h2><p>You can convert the Hamiltonian to and from:</p><ul><li>JSON Object format</li><li>Julia Dictionary representation</li><li>Schema representation</li><li>Amazon Braket representation</li></ul><p>to store the Hamiltonian for other applications or execute it in Bloqade/Neutral Atom hardware. </p><div class="admonition is-info"><header class="admonition-header">Internal Validation</header><div class="admonition-body"><p>By default, all conversion functions invoke <a href="#BloqadeSchema.validate"><code>validate</code></a> internally to ensure the Hamiltonian is capable of being run on hardware. If a violation is detected, the Hamiltonian is not converted. For JSON and Schema representations, this can be bypassed by invoking the &quot;no validation&quot; variants <a href="#BloqadeSchema.to_schema_no_validation"><code>to_schema_no_validation</code></a> and <a href="#BloqadeSchema.to_json_no_validation"><code>to_json_no_validation</code></a> respectively. This bypass ability is not available for dictionary representation and Amazon Braket representation (which requires the Hamiltonian is already in <a href="@ref"><code>TaskSpecification</code></a> format).</p></div></div><h3 id="Schema"><a class="docs-heading-anchor" href="#Schema">Schema</a><a id="Schema-1"></a><a class="docs-heading-anchor-permalink" href="#Schema" title="Permalink"></a></h3><p><a href="#BloqadeSchema.to_schema"><code>to_schema</code></a> allows you to convert a Hamiltonian to Bloqade&#39;s native schema format (<a href="@ref"><code>TaskSpecification</code></a>) along with an optional <a href="@ref"><code>SchemaTranslationParams</code></a> argument to specify the number of shots and device capabilities for validation.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; h_schema = to_schema(transformed_h)</code><code class="nohighlight hljs ansi" style="display:block;">QuEraTaskSpecification(
  nshots = 1,
  lattice = BloqadeSchema.Lattice(
    sites = [(
        0.0,
        0.0,
      ), (
        4.0e-6,
        0.0,
      ), (
        8.0e-6,
        0.0,
      ), (
        1.2e-5,
        0.0,
      )],
    filling = Int32[1, 1, 1, 1],
  ),
  effective_hamiltonian = BloqadeSchema.EffectiveHamiltonian(
    rydberg = BloqadeSchema.RydbergHamiltonian(
      rabi_frequency_amplitude = BloqadeSchema.RabiFrequencyAmplitude(
        global_value = BloqadeSchema.GlobalField(
          times = [0.0, 5.5e-7, 8.25e-7, 9.63e-7, 1.031e-6, 1.1e-6],
          values = [0.0, 3.1416e6, 4.7124e6, 5.4976e6, 5.8904e6, 0.0],
        ),
      ),
      rabi_frequency_phase = BloqadeSchema.RabiFrequencyPhase(
        global_value = BloqadeSchema.GlobalField(
          times = [
            0.0,
            1.38e-7,
            2.06e-7,
            2.75e-7,
            3.44e-7,
            4.12e-7,
            4.81e-7,
            5.5e-7,
            6.19e-7,
            6.88e-7,
            7.56e-7,
            8.25e-7,
            8.94e-7,
            9.63e-7,
            1.031e-6,
            1.1e-6,
          ],
          values = [
            0.0,
            0.4094655,
            0.7898545,
            1.2857985,
            1.887936,
            2.584901,
            3.363537,
            4.2091465,
            5.1057665,
            6.0364725,
            6.983696,
            7.929557,
            8.8562005,
            9.7461355,
            10.582562,
            10.582562,
          ],
        ),
      ),
      detuning = BloqadeSchema.Detuning(
        global_value = BloqadeSchema.GlobalField(
          times = [0.0, 1.1e-6],
          values = [7.5398224e6, 7.5398224e6],
        ),
      ),
    ),
  ),
)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; from_schema(h_schema) # to convert back to Hamiltonian</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 4
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] Ω(t) ⋅∑ e^{ϕ(t) ⋅ im} |0⟩⟨1| + e^{-ϕ(t) ⋅ im} |1⟩⟨0|
└─ [-] Δ(t) ⋅ ∑ n_i</code></pre><h3 id="JSON"><a class="docs-heading-anchor" href="#JSON">JSON</a><a id="JSON-1"></a><a class="docs-heading-anchor-permalink" href="#JSON" title="Permalink"></a></h3><p><a href="#BloqadeSchema.to_json"><code>to_json</code></a> allows you to convert a Hamiltonian to a JSON Object along with an optional <a href="@ref"><code>SchemaTranslationParams</code></a> argument to specify the number of shots and device capabilities for validation.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; h_json = to_json(transformed_h)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;{\&quot;nshots\&quot;:1,\&quot;lattice\&quot;:{\&quot;sites\&quot;:[[0.0,0.0],[4.0e-6,0.0],[8.0e-6,0.0],[1.2e-5,0.0]],\&quot;filling\&quot;:[1,1,1,1]},\&quot;effective_hamiltonian\&quot;:{\&quot;rydberg\&quot;:{\&quot;rabi_frequency_amplitude\&quot;:{\&quot;global\&quot;:{\&quot;times\&quot;:[0.0,5.5e-7,8.25e-7,9.63e-7,1.031e-6,1.1e-6],\&quot;values\&quot;:[0.0,3.1416e6,4.7124e6,5.4976e6,&quot; ⋯ 157 bytes ⋯ &quot;,9.63e-7,1.031e-6,1.1e-6],\&quot;values\&quot;:[0.0,0.4094655,0.7898545,1.2857985,1.887936,2.584901,3.363537,4.2091465,5.1057665,6.0364725,6.983696,7.929557,8.8562005,9.7461355,10.582562,10.582562]}},\&quot;detuning\&quot;:{\&quot;global\&quot;:{\&quot;times\&quot;:[0.0,1.1e-6],\&quot;values\&quot;:[7.5398224e6,7.5398224e6]}}}}}&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; from_json(h_json) # to convert back to Hamiltonian</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 4
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] Ω(t) ⋅∑ e^{ϕ(t) ⋅ im} |0⟩⟨1| + e^{-ϕ(t) ⋅ im} |1⟩⟨0|
└─ [-] Δ(t) ⋅ ∑ n_i</code></pre><h3 id="Dictionary"><a class="docs-heading-anchor" href="#Dictionary">Dictionary</a><a id="Dictionary-1"></a><a class="docs-heading-anchor-permalink" href="#Dictionary" title="Permalink"></a></h3><p><a href="#BloqadeSchema.to_dict"><code>to_dict</code></a> allows you to convert a Hamiltonian to a Julia dictionary along with an optional  <a href="@ref"><code>SchemaTranslationParams</code></a> argument to specify the number of shots and device capabilities for validation.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; h_dict = to_dict(transformed_h)</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Any} with 3 entries:
  &quot;nshots&quot;                =&gt; 1
  &quot;lattice&quot;               =&gt; OrderedDict{String, Vector}(&quot;sites&quot;=&gt;[[0.0, 0.0], …
  &quot;effective_hamiltonian&quot; =&gt; OrderedDict{String, Any}(&quot;rydberg&quot;=&gt;OrderedDict{St…</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; from_dict(h_dict) # to convert back to Hamiltonian</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 4
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] Ω(t) ⋅∑ e^{ϕ(t) ⋅ im} |0⟩⟨1| + e^{-ϕ(t) ⋅ im} |1⟩⟨0|
└─ [-] Δ(t) ⋅ ∑ n_i</code></pre><h3 id="Amazon-Braket"><a class="docs-heading-anchor" href="#Amazon-Braket">Amazon Braket</a><a id="Amazon-Braket-1"></a><a class="docs-heading-anchor-permalink" href="#Amazon-Braket" title="Permalink"></a></h3><p><a href="#BloqadeSchema.to_braket_ahs_ir"><code>to_braket_ahs_ir</code></a> allows you to convert a <a href="@ref"><code>TaskSpecification</code></a> instance into an <a href="https://github.com/awslabs/Braket.jl/blob/main/src/raw_schema.jl#L604"><code>Braket.IR.AHSProgram</code></a> that can be submitted for execution on Neutral Atom hardware such as <a href="https://www.quera.com/aquila">QuEra&#39;s 256-qubit Aquila machine</a> via <a href="https://aws.amazon.com/braket/">Amazon Braket</a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; h_schema = to_schema(transformed_h)</code><code class="nohighlight hljs ansi" style="display:block;">QuEraTaskSpecification(
  nshots = 1,
  lattice = BloqadeSchema.Lattice(
    sites = [(
        0.0,
        0.0,
      ), (
        4.0e-6,
        0.0,
      ), (
        8.0e-6,
        0.0,
      ), (
        1.2e-5,
        0.0,
      )],
    filling = Int32[1, 1, 1, 1],
  ),
  effective_hamiltonian = BloqadeSchema.EffectiveHamiltonian(
    rydberg = BloqadeSchema.RydbergHamiltonian(
      rabi_frequency_amplitude = BloqadeSchema.RabiFrequencyAmplitude(
        global_value = BloqadeSchema.GlobalField(
          times = [0.0, 5.5e-7, 8.25e-7, 9.63e-7, 1.031e-6, 1.1e-6],
          values = [0.0, 3.1416e6, 4.7124e6, 5.4976e6, 5.8904e6, 0.0],
        ),
      ),
      rabi_frequency_phase = BloqadeSchema.RabiFrequencyPhase(
        global_value = BloqadeSchema.GlobalField(
          times = [
            0.0,
            1.38e-7,
            2.06e-7,
            2.75e-7,
            3.44e-7,
            4.12e-7,
            4.81e-7,
            5.5e-7,
            6.19e-7,
            6.88e-7,
            7.56e-7,
            8.25e-7,
            8.94e-7,
            9.63e-7,
            1.031e-6,
            1.1e-6,
          ],
          values = [
            0.0,
            0.4094655,
            0.7898545,
            1.2857985,
            1.887936,
            2.584901,
            3.363537,
            4.2091465,
            5.1057665,
            6.0364725,
            6.983696,
            7.929557,
            8.8562005,
            9.7461355,
            10.582562,
            10.582562,
          ],
        ),
      ),
      detuning = BloqadeSchema.Detuning(
        global_value = BloqadeSchema.GlobalField(
          times = [0.0, 1.1e-6],
          values = [7.5398224e6, 7.5398224e6],
        ),
      ),
    ),
  ),
)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h_braket = to_braket_ahs_ir(h_schema)</code><code class="nohighlight hljs ansi" style="display:block;">Braket.IR.AHSProgram(Braket.braketSchemaHeader(&quot;braket.ir.ahs.program&quot;, &quot;1&quot;), Braket.IR.Setup(Braket.IR.AtomArrangement(Vector{DecFP.Dec128}[[0.0, 0.0], [4.0e-6, 0.0], [8.0e-6, 0.0], [1.2e-5, 0.0]], [1, 1, 1, 1])), Braket.IR.Hamiltonian(Braket.IR.DrivingField[Braket.IR.DrivingField(Braket.IR.PhysicalField(Braket.IR.TimeSeries(DecFP.Dec128[0.0, 3.1416e6, 4.7124e6, 5.4976e6, 5.8904e6, 0.0], DecFP.Dec128[0.0, 5.5e-7, 8.25e-7, 9.63e-7, 1.031e-6, 1.1e-6]), &quot;uniform&quot;), Braket.IR.PhysicalField(Braket.IR.TimeSeries(DecFP.Dec128[0.0, 0.4094655, 0.7898545, 1.2857985, 1.887936, 2.584901, 3.363537, 4.2091465, 5.1057665, 6.0364725, 6.983696, 7.929557, 8.8562005, 9.7461355, 10.582562, 10.582562], DecFP.Dec128[0.0, 1.38e-7, 2.06e-7, 2.75e-7, 3.44e-7, 4.12e-7, 4.81e-7, 5.5e-7, 6.19e-7, 6.88e-7, 7.56e-7, 8.25e-7, 8.94e-7, 9.63e-7, 1.031e-6, 1.1e-6]), &quot;uniform&quot;), Braket.IR.PhysicalField(Braket.IR.TimeSeries(DecFP.Dec128[7.5398224e6, 7.5398224e6], DecFP.Dec128[0.0, 1.1e-6]), &quot;uniform&quot;))], Braket.IR.ShiftingField[]))</code></pre><div class="admonition is-info"><header class="admonition-header">One-Way Conversion</header><div class="admonition-body"><p>Unlike the previous conversion functions, <code>from_braket_ahs_ir</code> does not exist meaning it is not possible to obtain a <a href="@ref"><code>TaskSpecification</code></a> from a <code>Braket.IR.AHSProgram</code>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">No Validation</header><div class="admonition-body"><p><a href="#BloqadeSchema.to_braket_ahs_ir"><code>to_braket_ahs_ir</code></a> does no validation on its input. It is assumed that the <a href="@ref"><code>TaskSpecification</code></a> given to it is already validated. Therefore, it is possible to produce a <code>Braket.IR.AHSProgram</code> that is incapable of being run on Neutral Atom hardware and may cause the Braket API to reject it.</p></div></div><h2 id="Submitting-to-Amazon-Braket"><a class="docs-heading-anchor" href="#Submitting-to-Amazon-Braket">Submitting to Amazon Braket</a><a id="Submitting-to-Amazon-Braket-1"></a><a class="docs-heading-anchor-permalink" href="#Submitting-to-Amazon-Braket" title="Permalink"></a></h2><p>To submit to Neutral Atom hardware on Amazon Braket, Bloqade provides <a href="#BloqadeSchema.submit_to_braket"><code>submit_to_braket</code></a> which can submit BOTH the native Bloqade representation of Hamiltonians (<code>BloqadeExpr.RydbergHamiltonian</code>) as well as the <a href="@ref"><code>TaskSpecification</code></a> representation.</p><div class="admonition is-warning"><header class="admonition-header">Implicit Transformation and No Validation for TaskSpecification</header><div class="admonition-body"><p>For any <code>BloqadeExpr.RydbergHamiltonian</code> passed in, <a href="#BloqadeSchema.hardware_transform"><code>hardware_transform</code></a> is invoked to ensure it is compatible with hardware. On the other hand, <a href="@ref"><code>TaskSpecification</code></a> types are assumed to already be valid.</p></div></div><p><a href="#BloqadeSchema.submit_to_braket"><code>submit_to_braket</code></a> requires that AWS credentials are given either explicitly through an <a href="https://github.com/JuliaCloud/AWS.jl/blob/master/src/AWSCredentials.jl#L32"><code>AWS.AWSCredentials</code></a> type or by setting the environment variables in the shell running Bloqade with the credentials. The credentials (and instructions for setting environment variables!) can be found through your AWS account&#39;s &quot;Command line or programmatic access&quot; option.</p><p>Let us try to submit the Hamiltonian we made earlier. We remind ourselves that our Hamiltonian is currently the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fixed_h</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 4
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] Ω(t) ⋅∑ e^{ϕ(t) ⋅ im} |0⟩⟨1| + e^{-ϕ(t) ⋅ im} |1⟩⟨0|
└─ [-] Δ(t) ⋅ ∑ n_i</code></pre><p>(Recall we had to modify the atom positions in order to pass validation!)</p><p>Now we define the number of shots (how many times the Hamiltonian will be executed on hardware) as well as the credentials, allowing <a href="#BloqadeSchema.submit_to_braket"><code>submit_to_braket</code></a> to automatically handle transforming the Hamiltonian to fit within hardware capabilities. By default, <a href="#BloqadeSchema.submit_to_braket"><code>submit_to_braket</code></a> will submit to QuEra&#39;s Aquila Neutral Atom hardware and take into account its capabilities for Hamiltonian transformation.</p><pre><code class="language-julia hljs">using AWS
access_key_id = &quot;your_access_key_id&quot;
secret_key = &quot;your_secret_key&quot;
token = &quot;your_token&quot;
credentials = AWS.AWSCredentials(access_key_id, secret_key, token)
task = submit_to_braket(fixed_h, 100; credentials=credentials)</code></pre><p>If submission was successful you will see something like </p><pre><code class="language-julia hljs">AwsQuantumTask(...)</code></pre><p>in the REPL with the Task ARN (Amazon Resource Name) as a string in the parentheses.</p><h2 id="Inspecting-Results-from-Braket"><a class="docs-heading-anchor" href="#Inspecting-Results-from-Braket">Inspecting Results from Braket</a><a id="Inspecting-Results-from-Braket-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-Results-from-Braket" title="Permalink"></a></h2><p>To see the status of our task we can use <code>state</code> from the <code>Braket.jl</code> package.</p><pre><code class="language-julia hljs">using Braket
Braket.state(task)</code></pre><p><code>state</code> can return a <code>String</code> that is either: <code>&quot;CANCELLED&quot;</code>, <code>&quot;FAILED&quot;</code>, <code>&quot;COMPLETED&quot;</code>, <code>&quot;QUEUED&quot;</code>, or <code>&quot;RUNNING&quot;</code>.</p><p>To obtain results, the <code>result</code> function from <code>Braket.jl</code> can be used</p><pre><code class="language-julia hljs">res = Braket.result(task)</code></pre><div class="admonition is-info"><header class="admonition-header">Braket.result is Blocking</header><div class="admonition-body"><p>Per the docstring for <a href="https://github.com/awslabs/Braket.jl/blob/main/src/task.jl#L292"><code>result</code></a>, the function is <strong>BLOCKING</strong> &quot;until a result is available, in which case the result is returned, or the task enters a terminal state without a result (<code>&quot;FAILED&quot;</code> or <code>&quot;CANCELLED&quot;</code>)...&quot;.</p></div></div><p>To obtain the raw measurements (pre- and post-Hamiltonian application) of the atoms, the <code>measurements</code> field can be accessed:</p><pre><code class="language-julia hljs">res.measurements</code></pre><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.get_device_capabilities" href="#BloqadeSchema.get_device_capabilities"><code>BloqadeSchema.get_device_capabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_device_capabilities(capabilities_file=nothing)</code></pre><p>Generates a <code>DeviceCapabilities</code> struct from either an explicitly provided path to a capabilities JSON file or using the default JSON provided in &quot;lib/BloqadeSchema/config/capabilities-qpu1-mock.json&quot;.</p><p>By default, the units for capabilities JSON file are specified by the  &quot;lib/BloqadeSchema/config/capabilities-qpu1-mock-units.json&quot; file this function gives a <code>DeviceCapabilities</code> struct with <em>non-SI base</em> (e.g. μm, μs) units.</p><p>See also <a href="#BloqadeSchema.get_device_capabilities_SI"><code>get_device_capabilities_SI</code></a></p><pre><code class="language-julia-repl hljs">julia&gt; get_device_capabilities()
BloqadeSchema.DeviceCapabilities(BloqadeSchema.TaskCapabilities(1, 1000), BloqadeSchema.LatticeCapabilities(BloqadeSchema.LatticeAreaCapabilities(75.0, 76.0), BloqadeSchema.LatticeGeometryCapabilities(4.0, 4.0, 0.1, 256), 256), BloqadeSchema.RydbergCapabilities(5.42e6, BloqadeSchema.RydbergGlobalCapabilities(0.0, 15.8, 0.0004, 250.0, -125.0, 125.0, 2.0e-7, 2500.0, -99.0, 99.0, 5.0e-7, 0.0, 4.0, 0.001, 0.05), nothing))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/capabilities.jl#L46-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.get_device_capabilities_SI" href="#BloqadeSchema.get_device_capabilities_SI"><code>BloqadeSchema.get_device_capabilities_SI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_device_capabilities_SI(capabilities_file=nothing)</code></pre><p>Generates a <code>DeviceCapabilities</code> struct from either an explicitly provided path to a capabilities JSON file or using the default JSON provided in &quot;lib/BloqadeSchema/config/capabilities-qpu1-mock.json&quot;.</p><p>The values returned are in Base SI units: m, s, rad/s, etc.</p><pre><code class="language-julia-repl hljs">julia&gt; get_device_capabilities_SI()
BloqadeSchema.DeviceCapabilities(BloqadeSchema.TaskCapabilities(1, 1000), BloqadeSchema.LatticeCapabilities(BloqadeSchema.LatticeAreaCapabilities(7.5e-5, 7.6e-5), BloqadeSchema.LatticeGeometryCapabilities(4.0e-6, 4.0e-6, 1.0e-7, 256), 256), BloqadeSchema.RydbergCapabilities(5.42e-24, BloqadeSchema.RydbergGlobalCapabilities(0.0, 1.58e7, 400.0, 2.5e14, -1.25e8, 1.25e8, 0.2, 2.5e15, -99.0, 99.0, 5.0e-7, 0.0, 4.0e-6, 1.0e-9, 5.0e-8), nothing))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/capabilities.jl#L81-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.hardware_transform_Ω" href="#BloqadeSchema.hardware_transform_Ω"><code>BloqadeSchema.hardware_transform_Ω</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hardware_transform_Ω(Ω,device_capabilities::DeviceCapabilities=get_device_capabilities())</code></pre><p>Given the <code>device_capabilities</code> of the machine and a Rabi frequency (Ω) <a href="../waveform/#BloqadeWaveforms.Waveform"><code>Waveform</code></a>, return a transformed Ω capable of being implemented by the machine along with the error between the original (<span>$A$</span>) and transformed (<span>$B$</span>) waveforms calculated as <span>$\Vert A - B\Vert_1$</span>. If the waveform durations are different, the shorter waveform is padded with zeros for values to make the durations equal in error calculation.</p><p><strong>Logs/Warnings/Exceptions</strong></p><p>Exceptions are thrown if Ω is:</p><ul><li>Not of type <a href="@ref"><code>BloqadWaveforms.Waveform</code></a></li><li>Not present (<code>nothing</code> was passed in)</li><li>Not a global drive (e.g.: Vector of Waveforms, localized Ω is not supported)</li><li>the maximum slope allowed for the waveform from <code>device_capabilities</code> is set to infinity </li><li>the minimum time step allowed for the waveform from <code>device_capabilities</code> is set to zero</li></ul><p>Debug logs are issued if the following are encountered in Ω:</p><ul><li>duration may be rounded due to time resolution from <code>device_capabilities</code></li><li>the initial waveform does not start/end in zero for its value</li><li>the values in the waveform exceed <code>device_capabilities</code> supported values, and must be clipped </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; wf = sinusoidal(duration=2, amplitude=1.3*π);

julia&gt; hardware_transform_Ω(wf)
(Waveform(_, 2.0), 2.632451578170084)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/transform.jl#L273-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.hardware_transform_ϕ" href="#BloqadeSchema.hardware_transform_ϕ"><code>BloqadeSchema.hardware_transform_ϕ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hardware_transform_ϕ(ϕ,device_capabilities::DeviceCapabilities=get_device_capabilities())</code></pre><p>Given the <code>device_capabilities</code> of the machine and a phase <a href="../waveform/#BloqadeWaveforms.Waveform"><code>Waveform</code></a>, return a transformed ϕ capable of being implemented by the machine along with the error between the original (<span>$A$</span>) and transformed (<span>$B$</span>) waveforms calculated as <span>$\Vert A - B\Vert_1$</span>. If the waveform durations are different, the shorter waveform is padded with zeros for values to make the durations equal in error calculation.</p><p><strong>Logs/Warnings/Exceptions</strong></p><p>Exceptions are thrown if ϕ is:</p><ul><li>Not of type <a href="@ref"><code>BloqadWaveforms.Waveform</code></a></li><li>Not present (<code>nothing</code> was passed in)</li><li>Not a global drive (e.g.: Vector of Waveforms, localized ϕ is not supported)</li><li>the maximum slope allowed for the waveform from <code>device_capabilities</code> is set to infinity </li><li>the minimum time step allowed for the waveform from <code>device_capabilities</code> is set to zero</li></ul><p>Debug logs are issued if the following are encountered in ϕ:</p><ul><li>duration may be rounded due to time resolution from <code>device_capabilities</code></li><li>the initial waveform does not start/end in zero for its value</li><li>the values in the waveform exceed <code>device_capabilities</code> supported values, and must be clipped </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; wf = sinusoidal(duration=2, amplitude=1.3*π);

julia&gt; hardware_transform_ϕ(wf)
(Waveform(_, 2.0), 0.5386117854062276)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/transform.jl#L339-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.hardware_transform_Δ" href="#BloqadeSchema.hardware_transform_Δ"><code>BloqadeSchema.hardware_transform_Δ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hardware_transform_Δ(Δ,device_capabilities::DeviceCapabilities=get_device_capabilities())</code></pre><p>Given the <code>device_capabilities</code> of the machine and a detuning waveform Δ, return a transformed Δ capable of being implemented by the machine along with the error between the original (<span>$A$</span>) and transformed (<span>$B$</span>) waveforms calculated as <span>$\Vert A - B\Vert_1$</span>. If the waveform durations are different, the shorter waveform is padded with zeros for values to make the durations equal in error calculation.</p><p><strong>Logs/Warnings/Exceptions</strong></p><p>Exceptions are thrown if Δ is:</p><ul><li>Not of type <a href="@ref"><code>BloqadWaveforms.Waveform</code></a></li><li>Not present (<code>nothing</code> was passed in)</li><li>Not a global drive (e.g. Vector of Waveforms, localized Δ is not supported)</li><li>the maximum slope allowed for the waveform from <code>device_capabilities</code> is set to infinity </li><li>the minimum time step allowed for the waveform from <code>device_capabilities</code> is set to zero</li></ul><p>Debug logs are issued if the following are encountered in Δ:</p><ul><li>duration may be rounded due to time resolution from <code>device_capabilities</code></li><li>the initial waveform does not start/end in zero for its value</li><li>the values in the waveform exceed <code>device_capabilities</code> supported values, and must be clipped </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; wf = sinusoidal(duration=2, amplitude=1.3*π);

julia&gt; hardware_transform_Δ(wf)
(Waveform(_, 2.0), 0.06492452289703464)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/transform.jl#L409-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.hardware_transform_atoms" href="#BloqadeSchema.hardware_transform_atoms"><code>BloqadeSchema.hardware_transform_atoms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hardware_transform_atoms(atoms,device_capabilities::DeviceCapabilities=get_device_capabilities())</code></pre><p>Given the constraints of the hardware from <code>device_capabilities</code> (specifically the position resolution) and an iterable containing the atom positions <code>atoms</code>, returns a Tuple containing the adjusted  atom positions the machine is capable of resolving and the mean squared error between the  desired atom positions and newly generated ones.</p><p>Note that other constraints such as the maximum width, height, and minimum supported spacings are not taken into account in adjusting the atoms. This may result in the <a href="@ref"><code>validation</code></a>  function failing and requiring user intervention to modify the atom positions such that  they satisfy the other constraints.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; atom_positions = ((1.12,), (2.01,), (3.01,));

julia&gt; hardware_transform_atoms(atom_positions) # by default, calls get_device_capabilities()
([(1.1,), (2.0,), (3.0,)], 0.013333333333333197)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/transform.jl#L515-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.hardware_transform" href="#BloqadeSchema.hardware_transform"><code>BloqadeSchema.hardware_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hardware_transform(h::BloqadeExpr.RydbergHamiltonian;device_capabilities::DeviceCapabilities=get_device_capabilities())</code></pre><p>Given the constraints of the hardware via <code>device_capabilities</code>, transforms <code>h</code> into one the machine is capable of executing as well as:</p><ul><li>The mean squared error between original positions of the atoms and the transformed ones</li><li>The 1-norm of the difference between the original and transformed waveforms</li></ul><p>which are all stored in a <a href="#BloqadeSchema.HardwareTransformInfo"><code>HardwareTransformInfo</code></a> struct.</p><p><code>hardware_transform</code> expects that ALL waveforms <code>h</code> can have specified (Ω, Δ, ϕ) are explicitly defined. If there is a waveform that is not being used, a <a href="../waveform/#BloqadeWaveforms.constant"><code>BloqadeWaveforms.constant</code></a> waveform should be created with value zero to indicate non-use.</p><p>Note that not all atom position constraints are accounted for, such as the maximum lattice width, lattice height,  and minimum supported spacings. Only position resolution is automatically accounted for. This may result in the <a href="@ref"><code>validation</code></a> function failing and requiring user intervention to modify the atom  positions such that they satisfy the other constraints.</p><p><strong>Logs/Warnings/Exceptions</strong></p><p>Debug logs are <em>always</em> emitted containing the error (defined as the 1-norm of the difference between the original waveform and the transformed waveform) across all waveforms (Ω, Δ, ϕ) as well as the  Mean Squared Error between the original atom positions and the adjusted atom positions.</p><p>The debug logs/warnings from constituent functions <a href="#BloqadeSchema.hardware_transform_Ω"><code>hardware_transform_Ω</code></a>, <a href="#BloqadeSchema.hardware_transform_Δ"><code>hardware_transform_Δ</code></a>, <a href="#BloqadeSchema.hardware_transform_ϕ"><code>hardware_transform_ϕ</code></a> are also emitted should the  waveforms in <code>h</code> cause them to.</p><p>See also <a href="#BloqadeSchema.hardware_transform_atoms"><code>hardware_transform_atoms</code></a>, <a href="#BloqadeSchema.hardware_transform_Ω"><code>hardware_transform_Ω</code></a>, <a href="#BloqadeSchema.hardware_transform_Δ"><code>hardware_transform_Δ</code></a>, <a href="#BloqadeSchema.hardware_transform_ϕ"><code>hardware_transform_ϕ</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; atom_positions = AtomList([(1.12,), (2.01,), (3.01,)]);

julia&gt; Δ = Ω = ϕ = sinusoidal(duration=2, amplitude=1.3*π);

julia&gt; h = rydberg_h(atom_positions; Ω=Ω,Δ=Δ,ϕ=ϕ)
nqubits: 3
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] Ω(t) ⋅∑ e^{ϕ(t) ⋅ im} |0⟩⟨1| + e^{-ϕ(t) ⋅ im} |1⟩⟨0|
└─ [-] Δ(t) ⋅ ∑ n_i


julia&gt; hardware_transform(h)
(nqubits: 3
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] Ω(t) ⋅∑ e^{ϕ(t) ⋅ im} |0⟩⟨1| + e^{-ϕ(t) ⋅ im} |1⟩⟨0|
└─ [-] Δ(t) ⋅ ∑ n_i
, BloqadeSchema.HardwareTransformInfo(0.5386117854062276, 2.632451578170084, 0.06492452289703464, (Δ = Waveform(_, 2), δ = nothing, Δi = 1.0), 0.013333333333333197))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/transform.jl#L548-L601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.HardwareTransformInfo" href="#BloqadeSchema.HardwareTransformInfo"><code>BloqadeSchema.HardwareTransformInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct HardwareTransformInfo &lt;: QuEraSchema</code></pre><p>Contains the calculated differences (error) betwen the original and transformed waveforms and atoms from invoking <a href="#BloqadeSchema.hardware_transform"><code>hardware_transform</code></a> on a <a href="@ref"><code>BloqadeExpr.RydbergHamiltonian</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>ϕ_error</code>: Error between the original laser phase waveform (<span>$A$</span>) and transformed one (<span>$B$</span>) waveforms calculated as <span>$\Vert A - B\Vert_1$</span>. </li><li><code>Ω_error</code>: Error between the original Rabi frequency waveform (<span>$A$</span>) and transformed one (<span>$B$</span>) waveforms calculated as <span>$\Vert A - B\Vert_1$</span>.</li><li><code>Δ_error</code>: Error between the global detuning waveform (<span>$A$</span>) and transformed one (<span>$B$</span>) waveforms calculated as <span>$\Vert A - B\Vert_1$</span>.</li><li><code>Δ_mask</code>: Decoupling of local detuning field inferred from the detuning value specified in Δ.</li></ul><div class="admonition is-info"><header class="admonition-header">Local Detuning Support</header><div class="admonition-body"><p>Local Detunings are currently not supported by Bloqade but will be in future releases.</p></div></div><ul><li><code>mse_atoms</code>: Mean Squared Error between original atom positions and transformed ones.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/types.jl#L24-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.validate" href="#BloqadeSchema.validate"><code>BloqadeSchema.validate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">validate(H::BloqadeExpr.RydbergHamiltonian;device_capabilities::DeviceCapabilities=get_device_capabilities())</code></pre><p>Checks if <code>H</code> is capable of being represented as part of the internal schema as well as if it falls in the capabilities of what the machine can do via <code>device_capabilities</code>.</p><p>Returns <a href="#BloqadeSchema.ValidationViolations"><code>ValidationViolations</code></a> with each field containing a set of strings indicating which constraints were violated for which part of <code>H</code>.</p><p>Violations include:</p><p><strong>Waveform Type</strong></p><ul><li>ϕ is not of type <code>PiecewiseConstantWaveform</code></li><li>Ω and Δ are not of type <code>PiecewiseLinearWaveform</code></li></ul><p><strong>Atom Position</strong></p><ul><li>Number of qubits requested exceeds what is supported by the device</li><li>Atom positions exceed position resolution supported by the device</li><li>The total width/height of the atom arrangement exceeds what is supported by the device</li><li>The radial spacing between atoms is smaller than what is supported by the device</li><li>The vertical row spacing between atoms is smaller than what is supported by the device</li></ul><p><strong>General Waveform Constraints (apply to Ω, Δ, ϕ)</strong></p><ul><li>duration exceeds device supported duration</li><li>duration is smaller than device supported minimum time step</li><li>smallest time step is smaller than supported smallest time step</li><li>value is smaller than smallest supported value</li><li>value is larger than largest supported value</li></ul><p><strong>Ω Waveform specific constraints</strong></p><ul><li>Slope exceeds largest supported slope</li><li>Start and end values are not equal to 0.0 rad/μs</li></ul><p><strong>Δ Waveform specific constraints</strong></p><ul><li>Slope exceeds largest supported slope</li></ul><p><strong>ϕ Waveform specific constraints</strong></p><ul><li>start value is not equal to 0.0 rad/μs</li></ul><p><strong>Logs/Warnings/Exceptions</strong></p><p>The following exceptions can be thrown:</p><ul><li>ϕ is not of type <code>PiecewiseConstantWaveform</code></li><li>Ω and Δ are not of type <code>PiecewiseLinearWaveform</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Δ = Ω = ϕ = sinusoidal(duration=2, amplitude=1.3*π);

julia&gt; h = rydberg_h(atom_positions; Ω=Ω,Δ=Δ,ϕ=ϕ)

julia&gt; transformed_h, _ = transform(h); # transform returns error info

julia&gt; validate(transformed_h) # constrained by default value of `device_capabilities` argument
The following validation violations occurred:

1. positions 2 =&gt; (2.0, 0.0) and 3 =&gt; (3.0, 0.0) are a distance of 1.0 μm apart which is below minimum value of 4.0 μm
2. positions 1 =&gt; (1.1, 0.0) and 2 =&gt; (2.0, 0.0) are a distance of 0.8999999999999999 μm apart which is below minimum value of 4.0 μm
3. positions 1 =&gt; (1.1, 0.0) and 3 =&gt; (3.0, 0.0) are a distance of 1.9 μm apart which is below minimum value of 4.0 μm</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/validate.jl#L327-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.to_json" href="#BloqadeSchema.to_json"><code>BloqadeSchema.to_json</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_json(h::AbstractBlock; kw...)
to_json(h::BloqadeExpr.RydbergHamiltonian,params::SchemaTranslationParams)</code></pre><p>Converts <code>h</code> and associated <code>params</code> into a JSON object. If <code>params</code> is not explicitly provided as a <code>SchemaTranslationParams</code> instance, it is automatically built from <code>nshots</code> and <code>device_capabilities</code>.</p><p>Validation is performed to ensure <code>h</code> is capable of being run on the machine. This can cause an exception to be thrown should any violations be caught. Refer to Logs/Warnings/Exceptions below.</p><p><strong>Logs/Warnings/Exceptions</strong></p><p>A <code>ValidationException</code> can be thrown which wraps a <a href="#BloqadeSchema.ValidationViolations"><code>ValidationViolations</code></a> instance.</p><p><code>ValidationViolations</code> contains any constraint violations detected from <a href="#BloqadeSchema.to_schema"><code>to_schema</code></a></p><p>Violations include:</p><p><strong>Waveform Type</strong></p><ul><li>ϕ is not of type <code>PiecewiseConstantWaveform</code></li><li>Ω and Δ are not of type <code>PiecewiseLinearWaveform</code></li></ul><p><strong>Atom Position</strong></p><ul><li>Number of qubits requested exceeds what is supported by the device</li><li>Atom positions exceed position resolution supported by the device</li><li>The total width/height of the atom arrangement exceeds what is supported by the device</li><li>The radial spacing between atoms is smaller than what is supported by the device</li><li>The vertical row spacing between atoms is smaller than what is supported by the device</li></ul><p><strong>General Waveform Constraints (apply to Ω, Δ, ϕ)</strong></p><ul><li>duration exceeds device supported duration</li><li>duration is smaller than device supported minimum time step</li><li>smallest time step is smaller than supported smallest time step</li><li>value is smaller than smallest supported value</li><li>value is larger than largest supported value</li></ul><p><strong>Ω Waveform specific constraints</strong></p><ul><li>Slope exceeds largest supported slope</li><li>Start and end values are not equal to 0.0 rad/μs</li></ul><p><strong>Δ Waveform specific constraints</strong></p><ul><li>Slope exceeds largest supported slope</li></ul><p><strong>ϕ Waveform specific constraints</strong></p><ul><li>start value is not equal to 0.0 rad/μs</li></ul><p><strong>Miscellaneous Violations</strong></p><ul><li>Number of shots is below minimum supported</li><li>Number of shots exceeds maximum supported</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Ω = BloqadeWaveforms.piecewise_constant(; clocks=[0, 2, 4, 6, 7], values=[5, 3, 4, 6]);

julia&gt; Δ = BloqadeWaveforms.piecewise_linear(; clocks=[0.0, 0.6, 2.1, 2.2], values=[-10.1, -10.1, 10.1, 10.1]);

julia&gt; ϕ = BloqadeWaveforms.piecewise_linear(; clocks=[0, 5], values=[33, 0]);

julia&gt; atoms = [(0, 0), (1, 3), (4, 2), (6, 3), (0, 5), (2, 5)];

julia&gt; block = BloqadeExpr.rydberg_h(atoms; Δ=Δ, Ω=Ω, ϕ=ϕ);

julia&gt; BloqadeSchema.to_json(block; n_shots=10)
&quot;{&quot;nshots&quot;:10,&quot;lattice&quot;:{&quot;sites&quot;:[[0.0,0.0],[1.0,3.0],[4.0,2.0],[6.0,3.0],[0.0,5.0],[2.0,5.0]],&quot;filling&quot;:[1,1,1,1,1,1]},&quot;effective_hamiltonian&quot;:{&quot;rydberg&quot;:{&quot;rabi_frequency_amplitude&quot;:{&quot;global&quot;:{&quot;times&quot;:[0.0,-18.0,2.0,-6.0,4.0,-14.0,7.0],&quot;values&quot;:[5.0,5.0,3.0,3.0,4.0,4.0,6.0]}},&quot;rabi_frequency_phase&quot;:{&quot;global&quot;:{&quot;times&quot;:[0.0,5.0],&quot;values&quot;:[33.0,0.0]}},&quot;detuning&quot;:{&quot;global&quot;:{&quot;times&quot;:[0.0,0.6,2.1,2.2],&quot;values&quot;:[-10.1,-10.1,10.1,10.1]}}}}}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/execute.jl#L149-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.to_json_no_validation" href="#BloqadeSchema.to_json_no_validation"><code>BloqadeSchema.to_json_no_validation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_json_no_validation(lattice::Union{Vector,Lattice};
    ϕ::Maybe{PiecewiseConstantWaveform}=nothing,
    Ω::Maybe{PiecewiseLinearWaveform}=nothing,
    Δ::Maybe{PiecewiseLinearWaveform}=nothing,
    δ::Maybe{PiecewiseLinearWaveform}=nothing,
    Δi::Maybe{Vector{Number}}=nothing,kw...)</code></pre><p>Converts <code>lattice</code>, <code>ϕ</code>, <code>Δ</code>, <code>δ</code>, and <code>Δi</code> to a JSON representation of a <code>QuEraTaskSpecification</code> instance WITHOUT ensuring the provided values are capable of being executed on the machine (fit within the  constraints of the device&#39;s capabilities)</p><p>See also <a href="#BloqadeSchema.to_json"><code>to_json</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/execute.jl#L359-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.to_dict" href="#BloqadeSchema.to_dict"><code>BloqadeSchema.to_dict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_dict(h::BloqadeExpr.RydbergHamiltonian; nshots::Int, device_capabilities::DeviceCapabilities=get_device_capabilities())
to_dict(h::BloqadeExpr.RydbergHamiltonian,params::SchemaTranslationParams)</code></pre><p>Converts <code>h</code> and associated <code>params</code> into the dictionary representation of a <a href="@ref"><code>QuEraTaskSpecification</code></a>. If <code>params</code> is not explicitly provided as a <code>SchemaTranslationParams</code> instance, it is automatically built from <code>nshots</code> and <code>device_capabilities</code>.</p><p>Validation is performed to ensure <code>h</code> is capable of being run on the machine. This can cause an exception to be thrown should any violations be caught. Refer to Logs/Warnings/Exceptions below.</p><p><strong>Logs/Warnings/Exceptions</strong></p><p>A <code>ValidationException</code> can be thrown which wraps a <a href="#BloqadeSchema.ValidationViolations"><code>ValidationViolations</code></a> instance.</p><p><code>ValidationViolations</code> contains any constraint violations detected from <a href="#BloqadeSchema.to_schema"><code>to_schema</code></a></p><p>Violations include:</p><p><strong>Waveform Type</strong></p><ul><li>ϕ is not of type <code>PiecewiseConstantWaveform</code></li><li>Ω and Δ are not of type <code>PiecewiseLinearWaveform</code></li></ul><p><strong>Atom Position</strong></p><ul><li>Number of qubits requested exceeds what is supported by the device</li><li>Atom positions exceed position resolution supported by the device</li><li>The total width/height of the atom arrangement exceeds what is supported by the device</li><li>The radial spacing between atoms is smaller than what is supported by the device</li><li>The vertical row spacing between atoms is smaller than what is supported by the device</li></ul><p><strong>General Waveform Constraints (apply to Ω, Δ, ϕ)</strong></p><ul><li>duration exceeds device supported duration</li><li>duration is smaller than device supported minimum time step</li><li>smallest time step is smaller than supported smallest time step</li><li>value is smaller than smallest supported value</li><li>value is larger than largest supported value</li></ul><p><strong>Ω Waveform specific constraints</strong></p><ul><li>Slope exceeds largest supported slope</li><li>Start and end values are not equal to 0.0 rad/μs</li></ul><p><strong>Δ Waveform specific constraints</strong></p><ul><li>Slope exceeds largest supported slope</li></ul><p><strong>ϕ Waveform specific constraints</strong></p><ul><li>start value is not equal to 0.0 rad/μs</li></ul><p><strong>Miscellaneous Violations</strong></p><ul><li>Number of shots is below minimum supported</li><li>Number of shots exceeds maximum supported</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/execute.jl#L213-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.to_schema" href="#BloqadeSchema.to_schema"><code>BloqadeSchema.to_schema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_schema(h::BloqadeExpr.RydbergHamiltonian; nshots::Int, device_capabilities::DeviceCapabilities=get_device_capabilities())
to_schema(h::BloqadeExpr.RydbergHamiltonian, params::SchemaTranslationParams)</code></pre><p>Converts <code>h</code> to a <code>QuEraTaskSpecification</code> instance with <code>params</code>. If params is not explicitly constructed,  it will be built automatically from <code>nshots</code> and <code>device_capabilities</code>. </p><p>Validation is performed to ensure <code>h</code> is capable of being run on the machine. This can cause an exception to be thrown should any violations be caught. Refer to Logs/Warnings/Exceptions below.</p><p><strong>Logs/Warnings/Exceptions</strong></p><p>If any violations of <code>device_capabilities</code> are detected, a <code>ValidationException</code> is thrown which wraps a <a href="#BloqadeSchema.ValidationViolations"><code>ValidationViolations</code></a> instance.</p><p>Violations include:</p><p><strong>Waveform Type</strong></p><ul><li>ϕ is not of type <code>PiecewiseConstantWaveform</code></li><li>Ω and Δ are not of type <code>PiecewiseLinearWaveform</code></li></ul><p><strong>Atom Position</strong></p><ul><li>Number of qubits requested exceeds what is supported by the device</li><li>Atom positions exceed position resolution supported by the device</li><li>The total width/height of the atom arrangement exceeds what is supported by the device</li><li>The vertical row spacing between atoms is smaller than what is supported by the device</li><li>The radial spacing between atoms is smaller than what is supported by the device</li></ul><p><strong>General Waveform Constraints (apply to Ω, Δ, ϕ)</strong></p><ul><li>duration exceeds device supported duration</li><li>duration is smaller than device supported minimum time step</li><li>smallest time step is smaller than supported smallest time step</li><li>value is smaller than smallest supported value</li><li>value is larger than largest supported value</li></ul><p><strong>Ω Waveform specific constraints</strong></p><ul><li>Slope exceeds largest supported slope</li><li>Start and end values are not equal to 0.0 rad/μs</li></ul><p><strong>Δ Waveform specific constraints</strong></p><ul><li>Slope exceeds largest supported slope</li></ul><p><strong>ϕ Waveform specific constraints</strong></p><ul><li>start value is not equal to 0.0 rad/μs</li></ul><p><strong>Miscellaneous Violations</strong></p><ul><li>Number of shots is below minimum supported</li><li>Number of shots exceeds maximum supported</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/execute.jl#L261-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.to_schema_no_validation" href="#BloqadeSchema.to_schema_no_validation"><code>BloqadeSchema.to_schema_no_validation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_schema_no_validation(lattice::Union{Vector,Lattice};
    ϕ::Maybe{PiecewiseConstantWaveform}=nothing,
    Ω::Maybe{PiecewiseLinearWaveform}=nothing,
    Δ::Maybe{PiecewiseLinearWaveform}=nothing,
    δ::Maybe{PiecewiseLinearWaveform}=nothing,
    Δi::Maybe{Vector{Number}}=nothing, 
    nshots::Int,
    device_capabilities::DeviceCapabilities=get_device_capabilities())
to_schema_no_validation(lattice::Union{Vector,Lattice},
    ϕ::Maybe{PiecewiseConstantWaveform},
    Ω::Maybe{PiecewiseLinearWaveform},
    Δ::Maybe{PiecewiseLinearWaveform},
    δ::Maybe{PiecewiseLinearWaveform},
    Δi::Maybe{Vector{Number}}, 
    params::SchemaTranslationParams)</code></pre><p>Converts <code>lattice</code>, <code>ϕ</code>, <code>Δ</code>, <code>δ</code>, and <code>Δi</code> to a <code>QuEraTaskSpecification</code> instance WITHOUT ensuring the provided values are capable of being executed on the machine (fit within the  constraints of the device&#39;s capabilities).</p><p>If <code>params</code> is not already provided, it is constructed automatically from <code>nshots::Int</code> and <code>device_capabilities</code>.</p><p>See also <a href="#BloqadeSchema.to_schema"><code>to_schema</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/execute.jl#L383-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.to_braket_ahs_ir" href="#BloqadeSchema.to_braket_ahs_ir"><code>BloqadeSchema.to_braket_ahs_ir</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function to_braket_ahs_ir(local_value::BloqadeSchema.LocalField)</code></pre><p>Converts <code>local_value</code> to <code>Braket.IR.PhysicalField</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/to_braket_ahs_ir.jl#L1-L5">source</a></section><section><div><pre><code class="nohighlight hljs">function to_braket_ahs_ir(global_values::BloqadeSchema.GlobalField)</code></pre><p>Converts <code>global_values</code> to <code>Braket.IR.PhysicalField</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/to_braket_ahs_ir.jl#L20-L24">source</a></section><section><div><pre><code class="nohighlight hljs">function to_braket_ahs_ir(amplitude_or_phase::Union{BloqadeSchema.RabiFrequencyAmplitude,
BloqadeSchema.RabiFrequencyPhase})</code></pre><p>Unwraps <code>amplitude_or_phase</code> to extract their <code>global_value</code> fields which are  immediately evaluated by <code>function to_braket_ahs_ir(global_values::BloqadeSchema.GlobalField)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/to_braket_ahs_ir.jl#L38-L44">source</a></section><section><div><pre><code class="nohighlight hljs">function to_braket_ahs_ir(detuning::BloqadeSchema.Detuning)</code></pre><p>Converts <code>detuning</code> to <code>Braket.IR.PhysicalField</code>&#39;s for the <code>global_value</code> and <code>local_value</code> fields of <code>detuning</code>. Returns the converted <code>global_value</code> first  followed by the <code>local_value</code>.  ``</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/to_braket_ahs_ir.jl#L48-L55">source</a></section><section><div><pre><code class="nohighlight hljs">function to_braket_ahs_ir(rydberg_hamiltonian::BloqadeSchema.RydbergHamiltonian)</code></pre><p>Converts <code>rydberg_hamiltonian</code> to <code>Braket.IR.Hamiltonian</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/to_braket_ahs_ir.jl#L68-L72">source</a></section><section><div><pre><code class="nohighlight hljs">function to_braket_ahs_ir(lattice::BloqadeSchema.Lattice)</code></pre><p>Converts <code>lattice</code> to a <code>Braket.IR.Setup</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/to_braket_ahs_ir.jl#L91-L95">source</a></section><section><div><pre><code class="nohighlight hljs">function to_braket_ahs_ir(hamiltonian::BloqadeSchema.EffectiveHamiltonian)</code></pre><p>Unwraps the <code>BloqadeSchema.RydbergHamiltonian</code> contained inside <code>hamiltonian</code> and immediately evaluates it using  <code>to_braket_ahs_ir(rydberg_hamiltonian::BloqadeSchema.RydbergHamiltonian)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/to_braket_ahs_ir.jl#L115-L121">source</a></section><section><div><p>function to<em>braket</em>ahs<em>ir(bloqade</em>task::BloqadeSchema.QuEraTaskSpecification)</p><p>Converts a <code>bloqade_task</code> into a <code>Braket.IR.AHSProgram</code> capable of being submitted to AWS Braket for execution on a QPU.</p><p>NOTE: <code>BloqadeSchema.QuEraTaskSpecification</code> contains a field <code>nshots</code> which does not have a corresponding field in <code>Braket.IR.AHSProgram</code>. This value must be fed as a keyword argument to a <code>Braket.AwsDevice</code> instance separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/to_braket_ahs_ir.jl#L125-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.submit_to_braket" href="#BloqadeSchema.submit_to_braket"><code>BloqadeSchema.submit_to_braket</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">submit_to_braket(h::BloqadeExpr.Hamiltonian, n_shots::Int; &lt;keyword arguments&gt;)</code></pre><p>Submits a <code>BloqadeExpr.RydbergHamiltonian</code> instance to Braket with <code>n_shots</code> defining the number of times the Hamiltonian should be executed. </p><p>Credentials can be passed in explicitly through an <code>AWS.AWSCredentials</code> struct or by passing in  <code>nothing</code>, in which case credentials will be sought in the standard AWS locations.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>arn=&quot;arn:aws:braket:us-east-1::device/qpu/quera/Aquila&quot;</code>: ARN for the machine</li><li><code>region=&quot;us-east-1&quot;</code>: AWS Region machine is located in</li><li><code>credentials::Union{AWSCredentials, Nothing}=nothing</code>: <code>AWS.AWSCredentials</code> instance you can create to login.</li></ul><p><strong>Logs/Warnings/Exceptions</strong></p><p>An <code>AWS.NoCredentials</code> exception is thrown containing a <code>message</code> string &quot;Can&#39;t find AWS credentials!&quot; if the credentials given are invalid.</p><p><a href="#BloqadeSchema.hardware_transform"><code>BloqadeSchema.hardware_transform</code></a> is always invoked, meaning its debug logs are also always emitted containing the difference (error) between the original waveforms in <code>h</code> and the newly generated ones compatible with hardware as well as the same transformation for atom positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/submit_to_braket.jl#L1-L21">source</a></section><section><div><pre><code class="nohighlight hljs">submit_to_braket(h::BloqadeExpr.RydbergHamiltonian, translation_params::BloqadeSchema.SchemaTranslationParams; &lt;keyword arguments&gt;)</code></pre><p>Submits a <code>BloqadeExpr.RydbergHamiltonian</code> instance to Braket with <code>BloqadeSchema.SchemaTranslationParams</code> containing the number of shots and  device capabilities. Returns an <code>AWS.AwsQuantumTask</code> upon converting the Hamiltonian to one the hardware can execute and submitting it.</p><p>Credentials can be passed in explicitly through an <code>AWS.AWSCredentials</code> struct or by passing in  <code>nothing</code>, in which case credentials will be sought in the standard AWS locations.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>arn=&quot;arn:aws:braket:us-east-1::device/qpu/quera/Aquila&quot;</code>: ARN for the machine</li><li><code>region=&quot;us-east-1&quot;</code>: AWS Region machine is located in</li><li><code>credentials::Union{AWSCredentials, Nothing}=nothing</code>: <code>AWS.AWSCredentials</code> instance you can create to login.</li></ul><p><strong>Logs/Warnings/Exceptions</strong></p><p>An <code>AWS.NoCredentials</code> exception is thrown containing a <code>message</code> string &quot;Can&#39;t find AWS credentials!&quot; if the credentials given are invalid.</p><p><a href="#BloqadeSchema.hardware_transform"><code>hardware_transform</code></a> is always invoked internally, meaning its debug logs are also always emitted containing the difference (error) between the original waveforms in <code>h</code> and the newly generated ones compatible with hardware as well as the same transformation for atom positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/submit_to_braket.jl#L37-L57">source</a></section><section><div><pre><code class="nohighlight hljs">sumbit_to_braket(ts:BloqadeSchema.QuEraTaskSpecification; &lt;keyword arguments&gt;)</code></pre><p>Submits a <code>BloqadeSchema.QuEraTaskSpecification</code> instance to Braket, returning an <code>AWS.AwsQuantumTask</code>.</p><p>Credentials can be passed in explicitly through an <code>AWS.AWSCredentials</code> struct or by passing in  <code>nothing</code>, in which case credentials will be sought in the standard AWS locations.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>arn=&quot;arn:aws:braket:us-east-1::device/qpu/quera/Aquila&quot;</code>: ARN for the machine</li><li><code>region=&quot;us-east-1&quot;</code>: AWS Region machine is located in</li><li><code>credentials::Union{AWSCredentials, Nothing}=nothing</code>: <code>AWS.AWSCredentials</code> instance you can create to login.</li></ul><p><strong>Logs/Warnings/Exceptions</strong></p><p>An <code>AWS.NoCredentials</code> exception is thrown containing a <code>message</code> string &quot;Can&#39;t find AWS credentials!&quot; if the credentials given are invalid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/submit_to_braket.jl#L72-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.from_json" href="#BloqadeSchema.from_json"><code>BloqadeSchema.from_json</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">from_json(j::String)</code></pre><p>Convert the JSON representation of a <a href="@ref"><code>QuEraTaskSpecification</code></a> instance to a  <a href="@ref"><code>QuEraTaskSpecification</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/execute.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.from_dict" href="#BloqadeSchema.from_dict"><code>BloqadeSchema.from_dict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">from_dict(d::AbstractDict{String})</code></pre><p>Convert the dictionary representation of a <a href="@ref"><code>QuEraTaskSpecification</code></a> instance,  into a <a href="@ref"><code>QuEraTaskSpecification</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/execute.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.from_schema" href="#BloqadeSchema.from_schema"><code>BloqadeSchema.from_schema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">from_schema(t::QuEraTaskSpecification)</code></pre><p>Converts <code>t</code> into valid <code>BloqadeExpr.RydbergHamiltonian</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/execute.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.execute" href="#BloqadeSchema.execute"><code>BloqadeSchema.execute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">execute(j::Dict)</code></pre><p>Executes a task given as a Dict in the task specification API format, and returns a JSON string of the result</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/execute.jl#L29-L33">source</a></section><section><div><pre><code class="nohighlight hljs">execute(j::QuEraTaskSpecification)</code></pre><p>Executes a task given as a QuEraTaskSpecification object in the task specification API format, and returns a JSON string of the result</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/execute.jl#L39-L43">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>TaskSpecification</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.TaskOutput" href="#BloqadeSchema.TaskOutput"><code>BloqadeSchema.TaskOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TaskOutput &lt;: QuEraSchema</code></pre><p>The result of executing a <code>QuEraTaskSpecification</code> on the machine.</p><p>Output of <a href="#BloqadeSchema.execute"><code>execute</code></a> function.</p><p><strong>Fields</strong></p><ul><li><code>task_status_code::Int</code>: Task Status</li><li><code>shot_outputs::Vector{ShotOutput}</code>: Contains pre- and post- shot </li></ul><p>sequence in binary of if atoms are in Rydberg/Ground state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/types.jl#L55-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BloqadeSchema.ValidationViolations" href="#BloqadeSchema.ValidationViolations"><code>BloqadeSchema.ValidationViolations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ValidationViolations &lt;: QuEraSchema</code></pre><p>Stores violations of hardware constraints from the user-supplied <a href="@ref"><code>BloqadeExpr.RydbergHamiltonian</code></a> as strings in sets. This is returned by <a href="#BloqadeSchema.validate"><code>validate</code></a> and <a href="#BloqadeSchema.to_schema"><code>to_schema</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>lattice_violations::Set</code>: violations of hardware-supported lattice geometry</li><li><code>misc_violations::Set</code>: violations that do not fall into other categories (e.g. number of shots)</li><li><code>Δ_violations::Set</code>: violations of detuning waveform</li><li><code>Ω_violations::Set</code>: violations of Rabi frequency waveform</li><li><code>ϕ_violations::Set</code>: violations of Phase waveform</li><li><code>δ_violations::Set</code>: violations of local detuning waveforms</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuEraComputing/Bloqade.jl/blob/d3f2ab7ca1cf3d7941ae4ad6d42cdc86ac9937bd/lib/BloqadeSchema/src/types.jl#L72-L86">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../3-level/">« 3-Level Support and Quantum Gates</a><a class="docs-footer-nextpage" href="../capabilities/">Hardware Capabilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 9 May 2023 21:12">Tuesday 9 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
