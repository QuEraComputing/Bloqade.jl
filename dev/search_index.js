var documenterSearchIndex = {"docs":
[{"location":"units/#Working-with-Units","page":"Working with Units","title":"Working with Units","text":"","category":"section"},{"location":"units/","page":"Working with Units","title":"Working with Units","text":"Unit conversion can be both tedious and prone to errors when working with simulation of real quantum hardware.  In Bloqade, the physical variables can support units explicitly from the Unitful package. Explicit units will be converted to our default units set automatically.  In other words,  you can use a different unit set to create the Hamiltonian other than the default units, and not worry about conversion yourself.  For detailed information about  the default unit of the Hamiltonian, please refer to the Bloqade page.","category":"page"},{"location":"units/","page":"Working with Units","title":"Working with Units","text":"using Bloqade\nusing Unitful: kHz, µm\nrydberg_h([(1, ), (2, )], C = 2π * 109.2kHz * µm^6)","category":"page"},{"location":"units/","page":"Working with Units","title":"Working with Units","text":"In the above example, we have assigned the parameter C_6 with the unit kHz * μm^6, which is automatically converted to the default unit MHz * µm^6 in Bloqade. ","category":"page"},{"location":"units/","page":"Working with Units","title":"Working with Units","text":"Other than the Hamiltonian, we can also specify units on waveforms, e.g.: ","category":"page"},{"location":"units/","page":"Working with Units","title":"Working with Units","text":"using Unitful: rad, ms\n\nwf = piecewise_linear(clocks=[0.0ms, 0.1ms, 0.2ms], values= [0.1, 1.1, 2.1] .* (rad/ms))\nBloqade.plot(wf)","category":"page"},{"location":"units/","page":"Working with Units","title":"Working with Units","text":"From this plot, we can see that the units for clocks and values have been converted to μs and MHz respectively. ","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"EditURL = \"https://github.com/QuEraComputing/Bloqade.jl/blob/master/examples/3.quantum-scar/main.jl\"","category":"page"},{"location":"tutorials/3.quantum-scar/main/#Quantum-Scar","page":"Quantum Scar","title":"Quantum Scar","text":"","category":"section"},{"location":"tutorials/3.quantum-scar/main/#Background","page":"Quantum Scar","title":"Background","text":"","category":"section"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"The experimental study H. Bernien, et al. discovered that if one starts with a particular initial state (e.g. the Neel state), the Rydberg blockade constraint results into persistent revivals of quantum dynamics, in constrast to the expectation of reaching thermalization quickly. Later, theoretical studies (e.g. C. J. Turner, et al.) reveal that this behavior is due to special eigenstates embedded in the quantum many-body spectrum, and the phenomenon is called quantum many-body scars.","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Quantum many-body scars are analogous to the phenomenon of classical scars in single-particle quantum chaos, where scars represent a concentration of some eigenfunctions along the trajectory of classical periodic orbits. Similarly, in the quantum many-body case, the initial Neel state has a large component of these specific scar states. Under the time evolution of the Rydberg Hamiltonian, the initial state undergoes the trajectory of periodic quantum orbits. The non-thermal behavior is mainly caused by such non-ergodicity in the Hilbert space.","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"In this example, we use Bloqade to simulate the evolution of a fully coherent, strongly interacting Rydberg system.  We demonstrate the persistent revivals of many-body dynamics with measurements of the Rydberg density and entanglement entropy. For a comprehensive review of quantum many-body scars, we refer readers to the paper M. Serbyn et al.","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"In this tutorial, we provide an example of using Bloqade to simulate quantum many-body scars. To start, we first import the required libraries:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"using Bloqade\nusing PythonCall\nusing Random\n\nplt = pyimport(\"matplotlib.pyplot\");","category":"page"},{"location":"tutorials/3.quantum-scar/main/#Many-Body-Rabi-Oscillations-with-Rydberg-Blockade","page":"Quantum Scar","title":"Many-Body Rabi Oscillations with Rydberg Blockade","text":"","category":"section"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We first demonstrate that the strong Rydberg interactions have important effects on the Rabi oscillations of Rydberg atoms. To do so, we consider a system with 1, 2, and 3 atoms. All the atoms are placed within the blockade radius of any other atom (see 'Rydberg Blockade' for more details). The atom positions can be created as:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"atom1 = generate_sites(ChainLattice(), 1, scale = 3.0)\natom2 = generate_sites(ChainLattice(), 2, scale = 3.0)\natom3 = generate_sites(ChainLattice(), 3, scale = 3.0)","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Let's apply a resonant Rabi driving on each of the system. The Hamiltonians can be simply constructed by:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"h1 = rydberg_h(atom1; Δ = 0, Ω = 2π * 2)\nh2 = rydberg_h(atom2; Δ = 0, Ω = 2π * 2)\nh3 = rydberg_h(atom3; Δ = 0, Ω = 2π * 2)","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"nqubits: 3\n+\n├─ [+] ∑ 2π ⋅ 8.627e5.0/|r_i-r_j|^6 n_i n_j\n├─ [+] 2π ⋅ ∑ σ^x_i\n└─ [-] 2π ⋅ 0.0 ⋅ ∑ n_i\n","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"The initial states are chosen such that all atoms start from the ground state:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"reg1 = zero_state(1)\nreg2 = zero_state(2)\nreg3 = zero_state(3)","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"ArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We first simulate the dynamics for the single atom's case, where the intial state is quenched under a Hamiltonian with constant Rabi frequency:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"total_time = 1.5\nclocks = 0.0:1e-2:total_time\nprob1 = KrylovEvolution(reg1, clocks, h1)\ndensity1 = zeros(1, length(clocks));\n\nfor info in prob1\n    density1[1, info.step] = rydberg_density(info.reg, 1)\nend","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Here, we use the KrylovEvolution to simulate the dynamics for a time-independent Hamiltonian. One can also use ODE to simulate the dynamics. For an example, see Adiabatic Evolution. The Rydberg density of this atom exihibits Rabi oscillations as a function of time, shown by the plot below:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"fig, ax = plt.subplots()\nax.plot(clocks, density1[1, :])\nax.set_xlabel(\"Time (μs)\")\nax.set_ylabel(\"Single Rydberg Probability\")\nax.set_title(\"Rabi Oscillation: Single Atom Case\")\nfig","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"For the case of 2 and 3 atoms, if they are separated far enough with negligible interactions, the total Rydberg excitation densities are simply the sum of the Rydberg density for each atom. However, we show that this is not the case for systems when atoms are close to each other (which results in strong Rydberg interactions). Similar to the 1 atom case, we can simulate the dynamics and get the time-dependent dynamics for each atom:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"prob2 = KrylovEvolution(reg2, clocks, h2);\ndensity2 = zeros(2, length(clocks));\n\nfor info in prob2\n    for i in 1:2\n        density2[i, info.step] = rydberg_density(info.reg, i)\n    end\nend\ndensity2 = sum(density2, dims = 1);\n\nprob3 = KrylovEvolution(reg3, clocks, h3);\ndensity3 = zeros(3, length(clocks));\n\nfor info in prob3\n    for i in 1:3\n        density3[i, info.step] = rydberg_density(info.reg, i)\n    end\nend\ndensity3 = sum(density3, dims = 1);","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Because of the Rydberg blockade, the system will undergo many-body Rabi oscillation with the state oscillating between the all 0 state and the W state, where the Rabi frequency will be enhanced by sqrtN, where N is the number of atoms. For more information, please refer to H. Bernien, et al.. The total Rydberg density for the 1-, 2-, and 3-atom system is plotted below:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"fig, ax = plt.subplots()\nax.plot(clocks, density1[1, :])\nax.plot(clocks, density2[1, :])\nax.plot(clocks, density3[1, :])\nax.set_xlabel(\"Time (μs)\")\nax.set_ylabel(\"Rydberg Probability\")\nax.set_title(\"Many-body Rabi Oscillation for 1-, 2-, and 3-atom system\")\nax.legend([\"1 atom\", \"2 atoms\", \"3 atoms\"], loc = \"lower right\")\nfig","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"From this plot, we can see that the total Rydberg density for 2 (3) atom case does not exceed 1. This is because it is energitically unfavorable to have more than 1 excitations due to the strong Rydberg interactions. In addition, we can see the enhancement of the many-body Rabi frequency. This shows that the interactions play an important role in the system's dynamics.","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Below, we show that for a system with 9 atoms where only nearest-neighbor atoms in a chain are within each other's blockade radius, the system can exhibit nontrivial dynamics for certain initial states, the so-called quantum many-body scars.","category":"page"},{"location":"tutorials/3.quantum-scar/main/#Quantum-Scar-2","page":"Quantum Scar","title":"Quantum Scar","text":"","category":"section"},{"location":"tutorials/3.quantum-scar/main/#Create-the-lattice-and-the-Hamiltonian","page":"Quantum Scar","title":"Create the lattice and the Hamiltonian","text":"","category":"section"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We first create a 9-atom system with a 1D-chain arrangement, where each atom is separated from its neighbors by 5.72 μm. This results in a nearest-neighbor interaction strength of 2 pi * 24 MHz, which is much larger than the Rabi frequency Omega specified below. Thus, the nearest-neighbor Rydberg atoms are within the blockade radius, such that the atoms cannot be both excited simultaneously.","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"nsites = 9\natoms = generate_sites(ChainLattice(), nsites, scale = 5.72)","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"The waveforms have two parts. For the first part, we use the adiabatic evolution to prepare an ordered Neel state (see Adiabatic Evolution for more details):","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Δ1 = piecewise_linear(clocks = [0.0, 0.3, 1.6, 2.2], values = 2π * [-10.0, -10.0, 10.0, 10.0]);\nΩ1 = piecewise_linear(clocks = [0.0, 0.05, 1.6, 2.2], values = 2π * [0.0, 4.0, 4.0, 0.0]);","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"The second part of the waveform has constant values for the parameters, so we can use constant to construct:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Ω2 = constant(duration = 2.0, value = 2 * 2π);\nΔ2 = constant(duration = 2.0, value = 0);","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"The waveform for the whole evolution can be composed by appending the second part to the first part:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Ω_tot = append(Ω1, Ω2);\nΔ_tot = append(Δ1, Δ2);\n\nfig, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (12, 4))\nBloqade.plot!(ax1, Ω_tot)\nBloqade.plot!(ax2, Δ_tot)\nax1.set_ylabel(\"Ω/2π (MHz)\")\nax2.set_ylabel(\"Δ/2π (MHz)\")\nfig","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Note that the total evolution time is 4.2 μs. We then build the Hamiltonian by importing the defined lattice structure and waveforms:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"h = rydberg_h(atoms; Δ = Δ_tot, Ω = Ω_tot)","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"nqubits: 9\n+\n├─ [+] ∑ 2π ⋅ 8.627e5.0/|r_i-r_j|^6 n_i n_j\n├─ [+] Ω(t) ⋅ ∑ σ^x_i\n└─ [-] Δ(t) ⋅ ∑ n_i\n","category":"page"},{"location":"tutorials/3.quantum-scar/main/#Simulate-the-Quantum-Dynamics","page":"Quantum Scar","title":"Simulate the Quantum Dynamics","text":"","category":"section"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We simulate the quench dynamics of the Rydberg atom array (initially prepared in the ground state). The initial state can be created by:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"reg = zero_state(nsites);","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We can then simulate the time evolution of the quantum state using an ODE solver:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"total_time = 4.2;\nprob = SchrodingerProblem(reg, total_time, h);\nintegrator = init(prob, Vern8());","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Then, we measure the real-time expectation value of the Rydberg density and entanglement entropy:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"entropy = Float64[]\ndensities = []\nfor _ in TimeChoiceIterator(integrator, 0.0:1e-3:total_time)\n    push!(densities, rydberg_density(reg))\n    rho = density_matrix(reg, (1, 2, 3, 4, 5)) # calculate the reduced density matrix\n    push!(entropy, von_neumann_entropy(rho)) # compute entropy from the reduced density matrix\nend","category":"page"},{"location":"tutorials/3.quantum-scar/main/#Plotting-the-Results","page":"Quantum Scar","title":"Plotting the Results","text":"","category":"section"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We first plot the Rydberg density for each site as a function of time:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"clocks = 0:1e-3:total_time\nD = hcat(densities...)\n\nfig, ax = plt.subplots(figsize = (10, 4))\nshw = ax.imshow(real(D), interpolation = \"nearest\", aspect = \"auto\", extent = [0, total_time, 0.5, nsites + 0.5])\nax.set_xlabel(\"time (μs)\")\nax.set_ylabel(\"site\")\nax.set_xticks(0:0.4:total_time)\nax.set_yticks(1:nsites)\nbar = fig.colorbar(shw)\nfig","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We can see that the state evolves to a Neel state after the first part of the pulse (time around 2.2 μs). After that, there are clear oscillations between the two patterns of the Rydberg density, which is a signature of the quantum scar.","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We can also plot the entanglement as a function of time:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"fig, ax = plt.subplots(figsize = (10, 4))\nax.plot(clocks, entropy)\nax.set_xlabel(\"time (μs)\")\nax.set_ylabel(\"entanglement entropy\")\nfig","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/3.quantum-scar/main/#A-Different-Initial-State","page":"Quantum Scar","title":"A Different Initial State","text":"","category":"section"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"In order to see that the revivals depends strongly on the initial state, we now choose a different initial state, and use the KrylovEvolution solver to simulate the dynamics:","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"hd = rydberg_h(atoms; Ω = 4π)\ntotal_time = 1.2;\nclocks = 0.0:1e-2:total_time;\n\ninit_d = product_state(bit\"100000101\")\nprob_d = KrylovEvolution(init_d, clocks, hd)\ndensity_mat_d = zeros(nsites, length(clocks))\n\nfor info in prob_d\n    for i in 1:nsites\n        density_mat_d[i, info.step] = rydberg_density(info.reg, i)\n    end\nend\n\nfig, ax = plt.subplots(figsize = (10, 4))\nshw = ax.imshow(\n    real(density_mat_d),\n    interpolation = \"nearest\",\n    aspect = \"auto\",\n    extent = [0, total_time, 0.5, nsites + 0.5],\n)\nax.set_xlabel(\"time (μs)\")\nax.set_ylabel(\"site\")\nax.set_xticks(0:0.2:total_time)\nax.set_yticks(1:nsites)\nbar = fig.colorbar(shw)\nfig","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"From this figure, we see that the density does not show long-lived oscillations.","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"","category":"page"},{"location":"tutorials/3.quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"This page was generated using Literate.jl.","category":"page"},{"location":"install/#install","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"You can copy the following line to your Julia REPL to install the latest stable version of this package:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> add Bloqade","category":"page"},{"location":"install/#Low-Latency-Usage-of-Bloqade-Component-Packages","page":"Installation","title":"Low-Latency Usage of Bloqade Component Packages","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"The Bloqade project contains multiple packages. For development on top of functionality, (especially for those who do not need the ODE solvers), we recommend you use the corresponding component packages. The following is a list of component packages and what they do (WIP = work-in-progress)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"BloqadeExpr: Expressions and API definitions for Bloqade.\nBloqadeKrylov: Krylov-subspace based emulation.\nBloqadeLattices: objects, functions for lattices.\nBloqadeMIS: tools for working with maximum-independent sets in Rydberg system.\nBloqadeODE: ODE-based emulation.\nBloqadePython: WIP, python wrapper for the Bloqade package.\nBloqadeQMC: WIP, Stochastic Series Expansion for Rydberg system.\nBloqadeSchema: WIP, the schema for creating a task for Bloqade and QuEra machine.\nBloqadeWaveforms: the waveform objects.\nYaoSubspaceArrayReg: register object and functions in a subspace.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"All the non-WIP packages are registered in the General registry. Thus, you can add them as your dependency by directly running pkg> add <component package> in your Julia REPL.","category":"page"},{"location":"install/#Try-the-Latest-Version-of-Bloqade","page":"Installation","title":"Try the Latest Version of Bloqade","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Some users may want to try the latest version of Bloqade for bug fixes, new features, etc. One can use git to clone the repo to try the latest version of the entire package. This requires one to setup the local project environment via dev. Please refer to the page Contributing to Bloqade for more information.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you only want to try the latest version of a specific Bloqade package, just add #master after the package name, e.g.:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> add BloqadeExpr#master","category":"page"},{"location":"install/#Using-Bloqade-with-AWS-EC2","page":"Installation","title":"Using Bloqade with AWS EC2","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Bloqade can be deployed on any personal computer although some users might benefit from the extra performance offered by large computational resources from different providers. To address that, Bloqade is also available on the Amazon Web Services (AWS) Marketplace, and can run on AWS EC2 instances Amazon Machine Images (AMIs). More information about the AMIs and how to deploy them onto EC2 instances can be found below.","category":"page"},{"location":"install/#Bloqade-AMIs","page":"Installation","title":"Bloqade AMIs","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"There are two AMIs offered by the Bloqade team:","category":"page"},{"location":"install/#Bloqade-AMI-(Base-Image)","page":"Installation","title":"Bloqade AMI (Base Image)","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Built on top of Ubuntu Server 20.04 LTS, this image includes","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"The latest version of Julia and Bloqade\nYao.jl\nRevise.jl\nBenchmarkTools.jl\nPythonCall.jl \nConda package manager, provided by Miniconda ","category":"page"},{"location":"install/#Bloqade-CUDA-AMI","page":"Installation","title":"Bloqade CUDA AMI","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Built on top of an Amazon DLAMI (Deep Learning AMI) on Ubuntu 20.04, this AMI includes everything from the Base Image above along with:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"NVIDIA CUDA\ncuDNN\nNCCL\nGPU Drivers\nIntel MKL-DNN\nDocker\nNVIDIA-Docker\nEFA support\nSupport for Block devices","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"as well as:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"CUDA.jl\nAdapt.jl ","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Both of which are needed for Bloqade to take advantage of GPUs (see GPU Acceleration for more on how to do this). ","category":"page"},{"location":"install/#Disclaimers","page":"Installation","title":"Disclaimers","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"info: Info\nDeploying Bloqade on AWS EC2 instances will incur a cost on the user that will depend on the AWS resources utilized.  \nSupport on deploying Bloqade on AWS can be obtained via AWS Support. This is a one-on-one support channel that is staffed 24x7x365 with experienced support engineers. To learn more, follow this link.","category":"page"},{"location":"install/#Step-0:-Set-Your-AWS-Region","page":"Installation","title":"Step 0: Set Your AWS Region","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"For general guidelines on launching EC2 instances, check out the AWS EC2 tutorial. Bloqade can technically be run from any location but its images are hosted on servers in AWS' North Virginia (N. Virginia) region. To get started as easily as possible, set your AWS region location to N. Virginia (us-east-1).","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(Image: Step 0)","category":"page"},{"location":"install/#Step-1:-Access-the-EC2-Service","page":"Installation","title":"Step 1: Access the EC2 Service","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Now to really get started. On your AWS account portal, type EC2 on the search bar and access the EC2 Service","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(Image: Step 1)","category":"page"},{"location":"install/#Step-2:-Launch-Your-Instance","page":"Installation","title":"Step 2: Launch Your Instance","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Find the \"Launch Instance\" button, circled in red, to create one. To see all currently running instances, click the \"Instances (running)\" button, indicated by the red arrow.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(Image: Step 2)","category":"page"},{"location":"install/#Step-3:-Name-Your-Instance","page":"Installation","title":"Step 3: Name Your Instance","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Give your instance a memorable name...","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(Image: Step 3)","category":"page"},{"location":"install/#Step-4:-Choose-an-Image","page":"Installation","title":"Step 4: Choose an Image","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"...and choose Bloqade as an image. This will put the AMI on the instance which has Bloqade and all its dependencies ready to go. Take a look at the Bloqade AMIs section of this page for more information on available images.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(Image: Step 4)","category":"page"},{"location":"install/#Step-5:-Select-Your-Instance","page":"Installation","title":"Step 5: Select Your Instance","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Select the EC2 instance type. Note that the rate at which your charged is dependent on which instance you select. Those with larger RAM/power usually charge more. For simple usage, we recommend an m2.xlarge instance as a basic choice. If you are looking for GPU support consider the g4dn.xlarge instance as a starting point.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"More information on available instances and the ability to compare between them you can visit instances.vantage.sh.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(Image: Step 5)","category":"page"},{"location":"install/#Step-6:-Generate-a-Key-Pair","page":"Installation","title":"Step 6: Generate a Key Pair","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"In order to access your instance from your local machine's terminal you will need to generate a key pair in advance. Click on \"Create new key pair\" as circled in the image. ","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(Image: Step 6.1)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Give your key pair a memorable name and once you have selected your desirable key pair type and file format click \"Create key pair\".","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(Image: Step 6.2)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"A download should happen in your browser that gives you your private key. If you are a PuTTY user you will need to import this key into your client. If you are are a Linux/macOS user using an SSH client from the terminal, you should put the key in your ~/.ssh folder although any other location will work with the caveat being you will have to specify the exact path to the key when invoking ssh as an argument to the command.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"You will also need to run the following command to set the proper permissions on the private key:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"chmod 400 </path/to/your_key>","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"After launching your instance there will be two ways you can connect to it, shown in the later steps of this guide.","category":"page"},{"location":"install/#Step-7:-Tune-Your-Instance-Some-More","page":"Installation","title":"Step 7: Tune Your Instance Some More","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Select your security group. This depends on either your personal setup, company security practices, or AWS best practices.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(Image: Step 7)","category":"page"},{"location":"install/#Step-8:-Blast-Off!","page":"Installation","title":"Step 8: Blast Off!","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Launch your instance!","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(Image: Step 8.1)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"You should be presented with the following screen:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(Image: Step 8.2)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you click on the instance hyperlink or the \"View all instances\" button, you'll be brought to the Instances page which shows all currently running as well as previously terminated/stopped instances. This page is also accessible from EC2 service page,  accessible via the directions in Step 2.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Select your instance from the \"Instances\" menu by clicking the checkbox next to the desired instance. A \"Connect\" button should be clickable in the upper right corner.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(Image: Step 8.3)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This should bring you to a \"Connect to instance\" page where you can navigate to the \"SSH client\" section.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(Image: Step 8.4)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"From here you have one of two choices to connect with your instance:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"warning: Default User Notice\nWhen logging in to your EC2 instance, the recommended user to login as is the ubuntu user (the default, non-root user from the Ubuntu base images the Bloqade AMIs are based off of). Using root is not advised and unsupported by the Bloqade team. You will notice the \"SSH Client\" section in the photo above still gives the ssh -i ... command with \"root\" as the username. This must be changed to ubuntu IF you intended to use Option 1 below. Option 2 already accounts for this.","category":"page"},{"location":"install/#Option-1:-Instant-Command-Line-Access","page":"Installation","title":"Option 1: Instant Command Line Access","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"If you just want to connect to the instance as fast as possible and plan on either:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Keeping the instance alive for the duration of your work\nTerminating (the equivalent of completely deleting an instance) and starting new instances frequently","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Just copy and paste the example at the very bottom (the command starting with ssh -i ...), changing the user to ubuntu from root. If your key is not located in the ~/.ssh folder for Linux/macOS users, you will need to either navigate to the folder you have the key stored to in the command line and execute the command there OR specify the full path to the key as the string in front of -i. ","category":"page"},{"location":"install/#Option-2:-OpenSSH-Config-File","page":"Installation","title":"Option 2: OpenSSH Config File","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"If you plan on reusing the same instance (stopping and starting it, thereby preserving your work on the EBS (Elastic Block Storage), essentially the hard drive of your instance) instance that the EC2 instance uses by default, you can set defaults for signing in by creating (if the file does not exist)/editing (if the file does exist) your OpenSSH config found in your ~/.ssh folder. Just add the following using vim or your favorite text editor:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Host AWS\n    HostName <DNS NAME, ex: ec2-3-93-200-58.compute-1.amazonaws.com>\n    User ubuntu\n    IdentityFile ~/.ssh/<PATH TO YOUR KEY>.pem","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"You can find your DNS name by following the steps mentioned in Option 1 but focusing on Step 4, which is \"Connect to your instance using its Public DNS\".","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Upon saving the changes, you should be able to access your instance by running ssh AWS in your command line.","category":"page"},{"location":"install/#Step-9:-Shutting-Down-Your-Instance","page":"Installation","title":"Step 9: Shutting Down Your Instance","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"In order to shut down your instance, you can return to the \"Instances\" menu shown in Step 8, select your instance, and click the \"Instance State\" Drop down. ","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"You can either:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Stop your Instance - This preserves any files you may have created working in the instance that were on the EBS but will come at a cost, determinable here. You may reuse the instance by selecting it again in the \"Instances\" menu and selecting \"Start\".\nTerminating your Instance - This does NOT preserve any files and means you will lose any work not transferred off the instance to your local machine. Termination deletes the EBS instance that your instance uses and you will not be charged afterwards for storage.","category":"page"},{"location":"install/#Build-System-Images-to-Accelerate-Start-up-Time","page":"Installation","title":"Build System Images to Accelerate Start-up Time","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Since Bloqade is a large package, its loading time and time-to-first-simulation can be very long. You can build system images to save all the compilation results in a binary to accelerate its loading/compilation time. This is useful when you have lots of interactive programming needs with Bloqade.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"To build a system image for your environment, please use the PackageCompiler or use the Julia VSCode plugin's build system image feature","category":"page"},{"location":"install/#Contributing-to-Bloqade","page":"Installation","title":"Contributing to Bloqade","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Please git clone this repository to a directory of your choice on your local machine and refer to Contributing to Bloqade to see how to set up your development environment for Bloqade.","category":"page"},{"location":"contrib/#contrib","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"","category":"section"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"If you are interested in contributing to this package, please consider going through this guide to help make your development workflow as smooth as possible.","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"Contributing to documentation and unit tests are always great ways to get yourself familiar with the community and workflows.","category":"page"},{"location":"contrib/#CLI-Tool","page":"Contributing to Bloqade","title":"CLI Tool","text":"","category":"section"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"There is a CLI tool in this repository at .ci/run that can help you simplify your workflow substantially. You can run .ci/run -h in your terminal to see the help message. or run .ci/run <command> -h to see the help message of each command. Below are some common use cases.","category":"page"},{"location":"contrib/#Documentation","page":"Contributing to Bloqade","title":"Documentation","text":"","category":"section"},{"location":"contrib/#Setup-Documentation","page":"Contributing to Bloqade","title":"Setup Documentation","text":"","category":"section"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"If you are editing the documentation, you can use the serve command:","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":".ci/run doc serve","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"to serve the documentation locally, and it will automatically update the served webpage while you are editing. ","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"If you wish to just build the documentation, you can use build command, which will run the build:","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":".ci/run doc build","category":"page"},{"location":"contrib/#Light-weight-Documentation-Build","page":"Contributing to Bloqade","title":"Light-weight Documentation Build","text":"","category":"section"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"Due to the \"ancient\" technology used by Documenter, it cannot render single page while editing, which causes the doc serve command to be very slow when you are editing. We provide a light-weight build setup to workaround this by removing all literate examples from the documentation. You can enable this by:","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":".ci/run doc build --light\n.ci/run doc serve --light","category":"page"},{"location":"contrib/#Setting-Up-Environments","page":"Contributing to Bloqade","title":"Setting Up Environments","text":"","category":"section"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"The Bloqade package itself is a meta-package that simply re-exports component packages that live in the lib directory. Thus, one will need to dev the corresponding component package to make sure they are using the master branch version while developing. You can always do this manually in Julia's Pkg mode via the dev command. For example, in the Bloqade environment (the Bloqade/Project.toml file), one will need to run the following command:","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"pkg> dev lib/BloqadeExpr lib/BloqadeKrylov lib/BloqadeLattices lib/BloqadeMIS lib/BloqadeODE lib/BloqadeWaveforms","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"This can be done automatically using the CLI tool via:","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":".ci/run dev","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"How does this work? The .ci/run dev command actually calls the Pkg.develop command from Julia's package manager. Because we want to use the local changes of the package, one will need to dev the corresponding package to  make the changes happen in your current environment, e.g one will need to dev  the lib/BloqadeExpr package to apply changes in BloqadeExpr module.","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"We also provide a convenient tool to setup this more automatically by looking up dependencies in lib in one's Project.toml file,","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":".ci/run dev <path/to/your/environment>","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"will dev all the Bloqade dependencies in your environment.","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"See also Modifying A Dependency for more detailed explainations.","category":"page"},{"location":"contrib/#Create-New-Examples","page":"Contributing to Bloqade","title":"Create New Examples","text":"","category":"section"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"Create a new example project called my_new_examples in examples and setup the dependencies of Bloqade:","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":".ci/run example create my_new_example","category":"page"},{"location":"contrib/#Build-a-Single-Example","page":"Contributing to Bloqade","title":"Build a Single Example","text":"","category":"section"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"Build a single example at build/my_example to jupyter notebook:","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":".ci/run example build my_example","category":"page"},{"location":"contrib/#Run-Unit-Tests","page":"Contributing to Bloqade","title":"Run Unit Tests","text":"","category":"section"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"If you are developing unit tests or would like to verify that changes made to any of Bloqade's code have not broken existing functionality, you can run unit tests for a specific sub-package like so:","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":".ci/run test path_to_sub_package","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":"You can also run ALL tests for the package using ","category":"page"},{"location":"contrib/","page":"Contributing to Bloqade","title":"Contributing to Bloqade","text":".ci/run testall","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"EditURL = \"https://github.com/QuEraComputing/Bloqade.jl/blob/master/examples/5.MIS/main.jl\"","category":"page"},{"location":"tutorials/5.MIS/main/#mis-tutorial","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"","category":"section"},{"location":"tutorials/5.MIS/main/#Background","page":"The Maximum Independent Set Problem","title":"Background","text":"","category":"section"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"In graph theory, an independent set is a set of vertices in a graph such that no two of which are connected by an edge. The problem of finding maximum independent sets (MIS) is NP-hard, i.e., it is unlikely to be solved in a time polynomial to the problem size. Interestingly, there is a natural connection between the independent set constraint, and the Rydberg Blockade phenomenon in neutral-atom quantum computing using Rydberg states. More specifically, Rydberg blockade implies that two atoms cannot be both excited to the Rydberg state rrangle if they are close to each other, whereas independent set constraint means two vertices cannot be both in the independent set when they are connected by an edge. Thus, one can consider atoms in the Rydberg state as vertices in an independent set. See the proposal in H. Pichler, et al. for more details.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"In particular, one can use the ground state of the Rydberg Hamiltonian to encode the maximum independent set problem, which is to find the largest independent set of a given graph. For a particular subclass of geometric graphs, the so-called unit disk graphs, the Rydberg Hamiltonian can encode the solution without any overhead in the number of qubits. In fact, an experimental demonstration of quantum optimization has been realized in solving the maximum independent set problem up to 289 qubits in S. Ebadi, et al..","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"In this tutorial, we show how to solve the MIS problem using Bloqade. We focus on a particular subclass of unit disk graphs defined as diagonal-connected unit-disk grid graphs (DUGG). This is the class of graphs studied in the demonstration experiment S. Ebadi, et al.. Although these graphs have highly constraint topologies, finding its MISs is still NP-hard. Here, we show how to use variational quantum algorithms with Rydberg Hamiltonians to solve the MIS problem on these graphs. The tutorial here strongly resembles the setup in S. Ebadi, et al., but, unsurprisingly, Bloqade can only simulate a much smaller problem.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"For more details on the functionalities supported by Bloqade in studying independent set problems, please refer to the MIS manual page.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Let's start by importing the required libraries:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"using Graphs\nusing Bloqade\nusing Random\nusing GenericTensorNetworks\nusing Optim\nusing PythonCall\nplt = pyimport(\"matplotlib.pyplot\");","category":"page"},{"location":"tutorials/5.MIS/main/#Setting-Up-the-Problem","page":"The Maximum Independent Set Problem","title":"Setting Up the Problem","text":"","category":"section"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"To begin, we create a 4*4 DUGG with 0.8 filling, by using the random_dropout function. Here, we choose the lattice constant a to be 4.5 μm:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Random.seed!(2)\natoms = generate_sites(SquareLattice(), 4, 4; scale = 4.5) |> random_dropout(0.2)","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Next, we set the blockade radius to be 7.5 μm, corresponding to a case where nearest neighbors and next-nearest neighbors (diagonal) are within the blockade radius. As we discussed in Rydberg Blockade, only one Rydberg excitation is allowed within the blockade radius. To better illustrate this constraint, we plot the interactions of Rydberg atoms as a DUGG, where each edge corresponds to the blockade constraint given by the blockade radius:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Bloqade.plot(atoms, blockade_radius = 7.5)","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Our goal is to find a maximum independent set of such a graph.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"For comparison, we first use classical algorithms to calculate the MIS size here using the graph utilities in Bloqade, so that one can compare this exact result with the quantum algorithms. The exact MIS size and its degeneracy can be solved with the generic tensor network algorithm in the package GenericTensorNetworks:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"graph = BloqadeMIS.unit_disk_graph(atoms, 7.5)\nmis_size_and_counting = GenericTensorNetworks.solve(IndependentSet(graph), CountingMax())[]","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(4.0, 26.0)ₜ","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"The solve function takes a graph instance and a solution space property as inputs, where the graph instance is generated by the unit_disk_graph function in the module BloqadeMIS, and the solution space property is to count the number of maximum independent sets here. For this specific DUGG, we see that the MIS size is 4, and the number of maximum independent sets is 26. In the following, we are going to show how to solve the independent set problem with both quantum adiabatic and variational algorithms.","category":"page"},{"location":"tutorials/5.MIS/main/#The-Adiabatic-Approach","page":"The Maximum Independent Set Problem","title":"The Adiabatic Approach","text":"","category":"section"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Here, we generalize the quantum adiabatic algorithm used in the tutorial Adiabatic Evolution to prepare ground states of the Rydberg Hamiltonian for this disordered lattice. We first construct the adiabatic pulse sequences for the Rabi frequency Omega and the detuning Delta:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"T_max = 0.6\nΩ_max = 2π * 4\nΩ = piecewise_linear(clocks = [0.0, 0.1, 0.5, T_max], values = [0.0, Ω_max, Ω_max, 0])\nΔ_start = -2π * 13\nΔ_end = 2π * 11\nΔ = piecewise_linear(clocks = [0.0, 0.1, 0.5, T_max], values = [Δ_start, Δ_start, Δ_end, Δ_end])\n\nfig, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (12, 4))\nBloqade.plot!(ax1, Ω)\nax1.set_ylabel(\"Ω/2π (MHz)\")\nBloqade.plot!(ax2, Δ)\nax2.set_ylabel(\"Δ/2π (MHz)\")\nfig","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Here, the total time is fixed to T_max, the adiabatic evolution path is specified by the piecewise_linear function. Rydberg blockade radius can be computed with","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"C_6  R_b^6 sim sqrtDelta^2 + Omega^2","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"The default C_6=2π * 862690 text MHz μm^6. For encoding the corresponding MIS problem at Omega = 0, the detuning can be set around 2pi times 11 MHz for a blockade radius of 75 µm (see the parameters in S. Ebadi, et al.).","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Next, we create the time-dependent Hamiltonian and simulate its time evolution by using the SchrodingerProblem solver:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"hamiltonian = rydberg_h(atoms; Ω = Ω, Δ = Δ)\nprob = SchrodingerProblem(zero_state(nqubits(hamiltonian)), T_max, hamiltonian)\nemulate!(prob)","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"SchrodingerProblem:\n  register info:\n    type: YaoArrayRegister.ArrayReg{2, ComplexF64, Matrix{ComplexF64}}\n    storage size: 8 bytes\n\n  time span (μs): (0.0, 0.6)\n\n  equation: \n    storage size: 1.688 MiB\n    expression:\nnqubits: 13\n+\n├─ [+] ∑ 2π ⋅ 8.627e5.0/|r_i-r_j|^6 n_i n_j\n├─ [+] Ω(t) ⋅ ∑ σ^x_i\n└─ [-] Δ(t) ⋅ ∑ n_i\n\n\n  options:\n    save_everystep: false\n    save_start: false\n    save_on: false\n    dense: false\n","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Finally, we can plot the most probable bitstrings by using the bitstring_hist function on the resulting register (quantum state):","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"bitstring_hist(prob.reg; nlargest = 20)","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"We can see that some of the most probable configurations indeed have an independent set size 4 by counting the number of ones in the bitstring. The correctness of the output can be verified by comparing it to the classical solution:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"best_bit_strings = most_probable(prob.reg, 2)\nall_optimal_configs = GenericTensorNetworks.solve(IndependentSet(graph), ConfigsMax())[]\n@assert all(bs -> GenericTensorNetworks.StaticBitVector([bs...]) ∈ all_optimal_configs.c, best_bit_strings)","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"We can also visualize these atoms and check them visually:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Bloqade.plot(atoms, blockade_radius = 7.5; colors = [iszero(b) ? \"white\" : \"red\" for b in best_bit_strings[1]])","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Bloqade.plot(atoms, blockade_radius = 7.5; colors = [iszero(b) ? \"white\" : \"red\" for b in best_bit_strings[2]])","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"However, there are still some configurations that violate the blockade constraint, because the blockade interaction is not an ideal unit disk constraint (e.g. some bitstrings have a size 5). One can check whether the independence constraint is satisfied or not with the BloqadeMIS.is_independent_set function:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"best5_bit_strings = most_probable(prob.reg, 3)\nBloqadeMIS.is_independent_set.(best5_bit_strings, Ref(graph))","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"3-element BitVector:\n 1\n 1\n 0","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"This can happen when the Rydberg interaction is not very strong at the unit disk radius. See the Rydberg Blockade page for more detailed explanations on Rydberg blockade and its relation with the unit disk radius. One can perform some postprocessing by reducing the violated configurations to indendendent set configurations using the mis_postprocessing function. See the function documentation for more details on what it does. Please also refer to the paper S. Ebadi, et al. for more detailed discussion on the postprocessing procedure.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"fixed = mis_postprocessing(best5_bit_strings[3], graph)\nBloqadeMIS.is_independent_set(fixed, graph)","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"true","category":"page"},{"location":"tutorials/5.MIS/main/#QAOA-with-Piecewise-Constant-Pulses","page":"The Maximum Independent Set Problem","title":"QAOA with Piecewise Constant Pulses","text":"","category":"section"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"The QAOA algorithm (arxiv:1411.4028) is a hybrid quantum-classical algorithm. The classical part of the algorithm is an optimizer, which can be either a gradient-based or non-gradient-based one. For our specific problem, the corresponding quantum part is a neutral-atom quantum computer first evolving under the Rydberg Hamiltonian with parameterized pulse sequences and then being measured in the computational basis.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"The standard definition of QAOA involves applying the problem (cost function) Hamiltonian C and the transverse field Hamiltonian B alternately. Let G=(VE) be a graph. The cost Hamiltonian for an MIS problem can be defined as","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"C(G) = -sum_jin V^n w_j n_j^z + infty sum_langle jkrangle in En_j^z n_k^z","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"where the first summation is proportional to the size of the independent set, and the second term enforces the independence constraints.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"In a Rydberg Hamiltonian, the first term corresponds to the detuning w_i = Delta. The second term contains an infty, which corresponds to the Rydberg blockade term with its strength described as V_jk = C_6overrightarrowmathbfr_j - overrightarrowmathbfr_k^6. As we can see, the Rydberg interaction is not a perfect independence constraint (with finite blockade interaction and unwanted long-rance interaction). Thus, postprocessing might be required using neutral-atom quantum computers to solve the MIS problem.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"The transverse field Hamiltonian corresponds to the Rabi term in the Rydberg Hamiltonian,","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"B = sum_j=1^nsigma_j^x + infty sum_langle jkrangle in En_j^z n_k^z","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Note that the Rybderg interaction term is always on here in contrast to the standard QAOA protocol. For the convenience of the simulation, we use the expect function to get the averaged measurement outputs. On the actual quantum hardware, the expect should be replaced by measuring in the computational basis and obtaining the averaged number of Rydberg excitations as the loss function (also called objective function or cost function). One can then either use non-gradient-based optimizers to perform the optimization or use finite-difference methods to obtain gradients of parameters.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Let us first set up a non-optimized pulse sequences for QAOA with step p=3:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"durations = fill(0.1, 6)\nclocks = [0, cumsum(durations)...]\nΩ2 = piecewise_constant(; clocks = clocks, values = repeat([Ω_max, 0.0], 3))\nΔ2 = piecewise_constant(; clocks = clocks, values = repeat([0.0, Δ_end], 3))\n\nfig, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (12, 4))\nBloqade.plot!(ax1, Ω2)\nax1.set_ylabel(\"Ω/2π (MHz)\")\nBloqade.plot!(ax2, Δ2)\nax2.set_ylabel(\"Δ/2π (MHz)\")\nfig","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"The piecewise_constant pulses can be more accurately simulated with the KrylovEvolution solver. This time, we simulate the dynamics in the subspace generated by the blockade_subspace function, so that we do not need postprocessing anymore.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"hamiltonian2 = rydberg_h(atoms; Ω = Ω2, Δ = Δ2)\nnsites = length(atoms)\nsubspace = blockade_subspace(atoms, 7.5)  # we run our simulation within the blockade subspace\nprob2 = KrylovEvolution(zero_state(subspace), clocks, hamiltonian2)\nemulate!(prob2);","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"We defined the loss function as the negative of the mean MIS size, which corresponds to the expectation value of the SumOfN operator. Thus, we can calculate the","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"average loss function after the time evolution:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"loss_MIS(reg) = -rydberg_density_sum(prob2.reg)\nloss_MIS(prob2.reg)","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"-2.562886912802677","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"The ouput shows the negative mean independent set size. This is because we have flipped its sign since most optimizers are set to minimize the loss function. This loss is equivalent to the rydberg_density_sum loss function in the BloqadeMIS module. Alternative loss functions include the gibbs_loss and the independent_set_probabilities.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Here, the loss produced by these pulse sequences does not look very good. We can throw it into an optimizer and see if a classical optimizer can help. First, let us wrap up the above code into a loss function:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"function loss_piecewise_constant(atoms::AtomList, x::AbstractVector{T}) where {T}\n    @assert length(x) % 2 == 0\n    Ω_max = 4 * 2π\n    Δ_end = 11 * 2π\n    p = length(x) ÷ 2\n\n    # detuning and rabi terms\n    durations = abs.(x)   # the durations of each layer of the QAOA pulse take the optimizing vector x as their input\n    clocks = [0, cumsum(durations)...]\n    Ωs = piecewise_constant(; clocks = clocks, values = repeat(T[Ω_max, 0.0], p))\n    Δs = piecewise_constant(; clocks = clocks, values = repeat(T[0.0, Δ_end], p))\n\n    hamiltonian = rydberg_h(atoms; Ω = Ωs, Δ = Δs)\n    subspace = blockade_subspace(atoms, 7.5)  # we run our simulation within the blockade subspace\n    prob = KrylovEvolution(zero_state(Complex{T}, subspace), clocks, hamiltonian)\n    emulate!(prob)\n    return -rydberg_density_sum(prob.reg), prob.reg\nend","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"loss_piecewise_constant (generic function with 1 method)","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"note: Note\nRunning the simulation in the subspace does not violate the independence constraints. If one uses fullspace simulation or runs it on the quantum computer, one may need to post-process the measured bit strings to a get a correct measure of the loss, if we don't set the blockade constraint. Related APIs include is_independent_set, num_mis_violation, and mis_postprocessing.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Let us check the loss function again using the initial point above:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"x0 = durations\nrydberg_density, reg1 = loss_piecewise_constant(atoms, x0)\nrydberg_density","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"-2.562886912802677","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"The most probable bitstrings are:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"bitstring_hist(reg1; nlargest = 20)","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"We see that, without optimization, many of these bitstrings are not the MIS solutions.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Let us now use the non-gradient-based optimizer NelderMead in the Optim package to optimize the loss function:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"optresult = Optim.optimize(x -> loss_piecewise_constant(atoms, x)[1], x0)\n\nrydberg_density_final, reg1_final = loss_piecewise_constant(atoms, optresult.minimizer)\nrydberg_density_final","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"-3.0965910260012155","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"We see that the loss is indeed improved, but still not very good. This is likely because the optimization is trapped in a local minimum.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"bitstring_hist(reg1_final; nlargest = 20)","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"This example shows that the performance of the algorithm very much depends on the parametrization of the pulse sequences, the initialization of the variational parameters, and the classical optimizers. See S. Ebadi, et al. for more in-depth comparison of different pulse parametrizations and tips on how to improve the performance.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"In the example below, we show a better pulse parametrization using smoothened piecewise linear waveforms.","category":"page"},{"location":"tutorials/5.MIS/main/#Smoothened-Piecewise-Linear-Pulses","page":"The Maximum Independent Set Problem","title":"Smoothened Piecewise Linear Pulses","text":"","category":"section"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"A smoothened piecewise linear waveform can be created by applying a Gaussian filter on a waveform created by the piecewise_linear function. For example:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"pulse_piecewise_linear = piecewise_linear(clocks = [0.0, 0.05, 0.1, 0.5, 0.55, T_max], values = [0, 0, 0.4, 0.4, 0, 0]);\npulse_smooth = smooth(pulse_piecewise_linear; kernel_radius = 0.02);\n\nfig, ax = plt.subplots()\nBloqade.plot!(ax, pulse_piecewise_linear)\nBloqade.plot!(ax, pulse_smooth)\nax.set_ylabel(\"strength\")\nax.legend([\"piecewise linear\", \"smoothened piecewise linear\"], loc = \"lower right\")\nfig","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Here, the function smooth takes a kernel_radius keyword parameter as the Gaussian kernel parameter. With the new waveforms, we can define the loss function as follows:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"function loss_piecewise_linear(atoms::AtomList, x::AbstractVector{T}) where {T}\n    @assert length(x) == 3\n    Ω_max = 4 * 2π\n    Δ_start = -13 * 2π\n    Δ_end = 11 * 2π\n    Δ0 = 11 * 2π\n    T_max = 0.6\n\n    # the strength of the detunings at each step takes the optimizing x as their input\n    Δs = smooth(\n        piecewise_linear(\n            clocks = T[0.0, 0.05, 0.2, 0.3, 0.4, 0.55, T_max],\n            values = T[Δ_start, Δ_start, Δ0*x[1], Δ0*x[2], Δ0*x[3], Δ_end, Δ_end],\n        );\n        kernel_radius = 0.02,\n    )\n    Ωs = smooth(\n        piecewise_linear(clocks = T[0.0, 0.05, 0.1, 0.5, 0.55, T_max], values = T[0, 0, Ω_max, Ω_max, 0, 0]);\n        kernel_radius = 0.02,\n    )\n\n    hamiltonian = rydberg_h(atoms; Ω = Ωs, Δ = Δs)\n    subspace = blockade_subspace(atoms, 7.5)\n    prob = SchrodingerProblem(zero_state(Complex{T}, subspace), T_max, hamiltonian)\n    emulate!(prob)\n    return -rydberg_density_sum(prob.reg), prob.reg, Δs\nend\n\nx0 = [0.1, 0.8, 0.8]; # initial point for the optimization","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Let us check the loss function with smoothened waveform with the initial point:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Δ_start = -13 * 2π\nΔ_end = 11 * 2π\nΔ0 = 11 * 2π\nT_max = 0.6\nΔ_initial = piecewise_linear(\n    clocks = [0.0, 0.05, 0.2, 0.3, 0.4, 0.55, T_max],\n    values = [Δ_start, Δ_start, Δ0 * x0[1], Δ0 * x0[2], Δ0 * x0[3], Δ_end, Δ_end],\n)\n\nrydberg_density, reg2, Δ_initial_smooth = loss_piecewise_linear(atoms, x0)\nrydberg_density","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"-3.8925951550822555","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"And plot the smoothened waveform:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"fig, ax = plt.subplots()\nBloqade.plot!(ax, Δ_initial)\nBloqade.plot!(ax, Δ_initial_smooth)\nax.set_ylabel(\"Δ/2π (MHz)\")\nax.legend([\"piecewise linear\", \"smoothened piecewise linear\"], loc = \"lower right\")\nfig","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"Let's plot the distribution:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"bitstring_hist(reg2; nlargest = 20)","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"The performance of the algorithm is quite good. Again, let us use the NelderMead optimizer to optimize the loss function:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"optresult = Optim.optimize(x -> loss_piecewise_linear(atoms, x)[1], x0)\n\nrydberg_density_final, reg_final, Δ_final = loss_piecewise_linear(atoms, optresult.minimizer)\nrydberg_density_final","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"-3.9781394463169746","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"One can see the mean MIS size can be further improved to a value close to the size of the MIS, which means there is a substantial probability for measuring an MIS state.","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"bitstring_hist(reg_final; nlargest = 20)","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"We can also plot out the final optimized waveform for Δ and compare with the initial waveform:","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"fig, ax = plt.subplots()\nBloqade.plot!(ax, Δ_initial_smooth)\nBloqade.plot!(ax, Δ_final)\nax.set_ylabel(\"Δ/2π (MHz)\")\nax.legend([\"initial\", \"optimized\"], loc = \"lower right\")\nfig","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"(Image: )","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"","category":"page"},{"location":"tutorials/5.MIS/main/","page":"The Maximum Independent Set Problem","title":"The Maximum Independent Set Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"cuda/#cuda","page":"GPU Acceleration","title":"GPU Acceleration","text":"","category":"section"},{"location":"cuda/","page":"GPU Acceleration","title":"GPU Acceleration","text":"Bloqade supports CUDA acceleration. To use CUDA acceleration, you will need a NVIDIA graphics processing unit (GPU).","category":"page"},{"location":"cuda/#Installation","page":"GPU Acceleration","title":"Installation","text":"","category":"section"},{"location":"cuda/","page":"GPU Acceleration","title":"GPU Acceleration","text":"To use CUDA accelerators, you need to install the CUDA package and the Adapt package:","category":"page"},{"location":"cuda/","page":"GPU Acceleration","title":"GPU Acceleration","text":"pkg> add CUDA Adapt","category":"page"},{"location":"cuda/","page":"GPU Acceleration","title":"GPU Acceleration","text":"This will automatically download all the needed dependencies of the CUDA toolkit. This functionality requires CUDA toolkit 11.6+ and CUSPARSE 11.4+. You can check your version via","category":"page"},{"location":"cuda/","page":"GPU Acceleration","title":"GPU Acceleration","text":"julia> CUDA.version()","category":"page"},{"location":"cuda/#Using-CUDA","page":"GPU Acceleration","title":"Using CUDA","text":"","category":"section"},{"location":"cuda/","page":"GPU Acceleration","title":"GPU Acceleration","text":"Converting your CPU-based simulation to CUDA-based simulation is extremely simple: just use the cu function from CUDA on the register object, which will convert the CPU-based register to a CUDA-based register, e.g.:","category":"page"},{"location":"cuda/","page":"GPU Acceleration","title":"GPU Acceleration","text":"using CUDA, Adapt\nreg = zero_state(5)\ndreg = adapt(CuArray, reg) # device register","category":"page"},{"location":"cuda/","page":"GPU Acceleration","title":"GPU Acceleration","text":"For emulation, you can call cu on your emulation object to convert everything (emulation intermediate memory, etc.) into the GPU memory, e.g.:","category":"page"},{"location":"cuda/","page":"GPU Acceleration","title":"GPU Acceleration","text":"adapt(CuArray, KrylovEvolution(reg, clocks, h))","category":"page"},{"location":"cuda/","page":"GPU Acceleration","title":"GPU Acceleration","text":"Other codes in Bloqade should work with CUDA automatically.","category":"page"},{"location":"registers/#observables","page":"Registers and Observables","title":"Registers and Observables","text":"","category":"section"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"Bloqade follows the register interface in Yao. It uses a register to  represent a device and its internal quantum state. For Bloqade, the most commonly used register types are ArrayReg and SubspaceArrayReg. They both use a dense array to store the corresponding quantum state. The only difference is that SubspaceArrayReg also stores a subspace object. In this section, we will only cover how to create registers and perform operations on them in the full Hilbert space. For subspace operations, please refer to the subspace page. We will also discuss a few convenient wrappers on commonly used observables for Rydberg systems. ","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"In the analog mode, we use the states grangle (ground state) and rrangle (Rydberg state) to encode a qubit. To be consistent with the standard language of qubits, we refer the states grangle and rrangle as 0rangle and 1rangle here.","category":"page"},{"location":"registers/#Basic-Interface","page":"Registers and Observables","title":"Basic Interface","text":"","category":"section"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"To create a register with all atoms being in the ground state  0000 rangle, we can use  the function zero_state by specifying the number of qubits:","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"using Bloqade\nzero_state(5) # creates a 5-qubit register","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"To create a more general product state in the computational basis, one can use the product_state function by inputting its bitstring:","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"product_state(bit\"10011\")","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"where bit\"10011\" is a special Julia string literal defined for bitstrings.","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"One can also construct the ArrayReg or SubspaceArrayReg directly from arrays, e.g.:","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"ArrayReg(rand(ComplexF64, 2^5))","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"For a subspace register, one can create in the following way:","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"space = Subspace(5, [0, 2, 3, 7])\nstate = rand(ComplexF64, length(space))\nreg = SubspaceArrayReg(state, space)","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"Here, 0 2 3 7 are base-10 integer representations of the corresponding states in bitstrings. For a more detailed guide on how to work in the subspace, please see subspace.","category":"page"},{"location":"registers/#Operations-on-Registers","page":"Registers and Observables","title":"Operations on Registers","text":"","category":"section"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"You can perform various operations on registers via the standard Yao register interface. This includes, e.g., ","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"applying operators on quantum    states by using apply!, \nmeasuring bitstrings with a    projection on the quantum state by using measure!, \ncalculating the expectation value of certain observables by      using expect,\ninspecting the internal state of the register by using statevec.","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"reg = rand_state(3)\nmeasure(reg; nshots=5)\nexpect(put(3,1=>X), reg)\nstatevec(reg)\napply!(reg, put(1=>X))","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"For a more detailed introduction of the register interface, please refer to Yao:Registers.","category":"page"},{"location":"registers/#Convenient-Wrappers","page":"Registers and Observables","title":"Convenient Wrappers","text":"","category":"section"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"Bloqade also provides a few convenient wrappers on some commonly used observables for Rydberg systems, including the Rydberg density and two-point correlation functions: ","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"rydberg_density","category":"page"},{"location":"registers/#Bloqade.rydberg_density","page":"Registers and Observables","title":"Bloqade.rydberg_density","text":"rydberg_density(reg, i::Int) -> Real\n\nCalculates the rydberg density at site i.\n\nlangle n_i rangle\n\n\n\n\n\nrydberg_density(reg) -> Vector\n\nReturn the rydberg density at each site.\n\n\n\n\n\n","category":"function"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"For example, if we want to measure the Rydberg density at each site or at a specific site, we can use the code below:","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"reg = rand_state(10)\nn_each = rydberg_density(reg)\nn_2 = rydberg_density(reg, 2)","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"To access the two-point correlation functions, we can use the rydberg_corr function below: ","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"rydberg_corr","category":"page"},{"location":"registers/#Bloqade.rydberg_corr","page":"Registers and Observables","title":"Bloqade.rydberg_corr","text":"rydberg_corr([op=Op.n], reg) -> Matrix\n\nCalculates the rydberg correlation matrix.\n\nlangle textop_i textop_j rangle\n\nhere op can be Op.n, X or Y.\n\nArguments\n\nop: the correlation function, default is Op.n.\nreg: required, the register object.\n\n\n\n\n\n","category":"function"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"This function will output a matrix that stores the correlation function for each pair of sites: ","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"nn_corr = rydberg_corr(Op.n, reg)","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"It is worth mentioning that besides Op.n, other single-site operators including the Pauli operators X, Y and Z can also be used. ","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"To directly obtain the time-dependent Rydberg density under Hamiltonian evolution, we can use the highly-wrapped function get_average_rydberg_densities","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"get_average_rydberg_densities","category":"page"},{"location":"registers/#Bloqade.get_average_rydberg_densities","page":"Registers and Observables","title":"Bloqade.get_average_rydberg_densities","text":"get_average_rydberg_densities(atoms, reg; [C=2π * 862690 * MHz*µm^6], Ω[, ϕ, Δ], [dt=1e-3 * μs])\n\nReturn average Rydberg densities throughout an evolution.\n\nArguments\n\natoms: a collection of atom positions.\nreg: required, the register object.\n\nKeyword Arguments\n\nC: optional, default unit is MHz*µm^6, interation parameter,   see also RydInteract.\nΩ: optional, default unit is MHz, Rabi frequencies, divided by 2, see also SumOfX.\nϕ: optional, does not have unit, the phase, see SumOfXPhase.\nΔ: optional, default unit is MHz, detuning parameter, see SumOfN.\ndt: optional, default unit is μs, time step for the evolution.\nsolver: optional, default solver is Vern8(), the solver for the SchrodingerProblem, see SchrodingerProblem.\n\n\n\n\n\n","category":"function"},{"location":"registers/#Create-General-Observables-using-Operator-Expressions","page":"Registers and Observables","title":"Create General Observables using Operator Expressions","text":"","category":"section"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"Bloqade makes use of Yao's block system to represent operator expressions.  For example, one can construct the Rydberg correlation operator as:","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"corr(n, i, j) = chain(n, put(i=>Op.n), put(j=>Op.n))","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"You can thus create any kinds of quantum operators in this way and use it with the expect or measure function, e.g.: ","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"reg = rand_state(10)\ncorr_XY = chain(10, put(2=>Op.X), put(4=>Op.Y))\nexpect(corr_XY, reg) ","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"Because the Hamiltonian is also an operator expression, it can be used as an observable too:","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"r = rand_state(5)\npos = [(i, ) for i in 1:5]\nh = rydberg_h(pos; Ω=2π*0.1)\nexpect(h, r)","category":"page"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"Please refer to the Hamiltonians to see other operators that are supported in building the Hamiltonian.","category":"page"},{"location":"registers/#References","page":"Registers and Observables","title":"References","text":"","category":"section"},{"location":"registers/","page":"Registers and Observables","title":"Registers and Observables","text":"arrayreg\napply!\nmeasure!\nmeasure\nexpect\nstatevec\nzero_state\nrand_state\nproduct_state\nSubspaceArrayReg\nset_zero_state!\nX\nY\nZ\n","category":"page"},{"location":"registers/#YaoArrayRegister.arrayreg","page":"Registers and Observables","title":"YaoArrayRegister.arrayreg","text":"arrayreg(state; nbatch::Union{Integer,NoBatch}=NoBatch(), nlevel::Integer=2)\n\nCreate an array register, if nbatch is a integer, it will return a BatchedArrayReg.\n\n\n\n\n\narrayreg([T=ComplexF64], bit_str; nbatch=NoBatch())\n\nConstruct an array register from bit string literal. For bit string literal please read @bit_str.\n\nExamples\n\njulia> arrayreg(bit\"1010\")\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\njulia> arrayreg(ComplexF32, bit\"1010\")\nArrayReg{2, ComplexF32, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoAPI.apply!","page":"Registers and Observables","title":"YaoAPI.apply!","text":"apply!(register, block)\n\nApply a block (of quantum circuit) to a quantum register.\n\nnote: Note\nto overload apply! for a new block, please overload the unsafe_apply! function with same interface. Then the apply! interface will do the size checks on inputs automatically.\n\nExamples\n\njulia> r = zero_state(2)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 2/2\n    nlevel: 2\n\njulia> apply!(r, put(2, 1=>X))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 2/2\n    nlevel: 2\n\njulia> measure(r;nshots=10)\n10-element Vector{DitStr{2, 2, Int64}}:\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoAPI.measure!","page":"Registers and Observables","title":"YaoAPI.measure!","text":"measure!([postprocess,] [operator, ]register[, locs]; rng=Random.GLOBAL_RNG)\n\nMeasure current active qudits or qudits at locs. If the operator is not provided, it will measure on the computational basis and collapse to a product state. Otherwise, the quantum state collapse to the subspace corresponds to the resulting eigenvalue of the observable.\n\nArguments\n\npostprocess is the postprocessing method, it can be\nNoPostProcess() (default).\nResetTo(config), reset to result state to config. It can not be used if operator is provided, because measuring an operator in general does not return a product state.\nRemoveMeasured(), remove the measured qudits from the register. It is also incompatible with the operator argument.\noperator::AbstractBlock is the operator to measure.\nregister::AbstractRegister is the quantum state.\nlocs is the qubits to performance the measurement. If locs is not provided, all current active qudits are measured (regarding to active qudits,\n\nsee focus! and relax!).\n\nKeyword arguments\n\nrng is the random number generator.\n\nExamples\n\nThe following example measures a random state on the computational basis and reset it to a certain bitstring value.\n\njulia> reg = rand_state(3);\n\njulia> measure!(ResetTo(bit\"011\"), reg)\n110 ₍₂₎\n\njulia> measure(reg; nshots=3)\n3-element Vector{DitStr{2, 3, Int64}}:\n 011 ₍₂₎\n 011 ₍₂₎\n 011 ₍₂₎\n\njulia> measure!(RemoveMeasured(), reg, (1,2))\n11 ₍₂₎\n\njulia> reg  # removed qubits are not usable anymore\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 1/1\n    nlevel: 2\n\nMeasuring an operator will project the state to the subspace associated with the returned eigenvalue.\n\njulia> reg = uniform_state(3)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> print_table(reg)\n000 ₍₂₎   0.35355 + 0.0im\n001 ₍₂₎   0.35355 + 0.0im\n010 ₍₂₎   0.35355 + 0.0im\n011 ₍₂₎   0.35355 + 0.0im\n100 ₍₂₎   0.35355 + 0.0im\n101 ₍₂₎   0.35355 + 0.0im\n110 ₍₂₎   0.35355 + 0.0im\n111 ₍₂₎   0.35355 + 0.0im\n\njulia> measure!(repeat(3, Z, 1:3), reg)\n-1.0 + 0.0im\n\njulia> print_table(reg)\n000 ₍₂₎   0.0 + 0.0im\n001 ₍₂₎   0.5 + 0.0im\n010 ₍₂₎   0.5 + 0.0im\n011 ₍₂₎   0.0 + 0.0im\n100 ₍₂₎   0.5 + 0.0im\n101 ₍₂₎   0.0 + 0.0im\n110 ₍₂₎   0.0 + 0.0im\n111 ₍₂₎   0.5 + 0.0im\n\nHere, we measured the parity operator, as a result,  the resulting state collapsed to the subspace with either even or odd parity.\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoAPI.measure","page":"Registers and Observables","title":"YaoAPI.measure","text":"measure([, operator], register[, locs]; nshots=1, rng=Random.GLOBAL_RNG) -> Vector{Int}\n\nMeasure a quantum state and return measurement results of qudits. This measurement function a cheating version of measure! that does not collapse the input state. It also does not need to recompute the quantum state for performing multiple shots measurement.\n\nArguments\n\noperator::AbstractBlock is the operator to measure.\nregister::AbstractRegister is the quantum state.\nlocs is the qubits to performance the measurement. If locs is not provided, all current active qudits are measured (regarding to active qudits,\n\nsee focus! and relax!).\n\nKeyword arguments\n\nnshots::Int is the number of shots.\nrng is the random number generator.\n\nExamples\n\njulia> reg = product_state(bit\"110\")\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> measure(reg; nshots=3)\n3-element Vector{DitStr{2, 3, Int64}}:\n 110 ₍₂₎\n 110 ₍₂₎\n 110 ₍₂₎\n\njulia> measure(reg, (2,3); nshots=3)\n3-element Vector{DitStr{2, 2, Int64}}:\n 11 ₍₂₎\n 11 ₍₂₎\n 11 ₍₂₎\n\nThe following example switches to the X basis for measurement.\n\njulia> reg = apply!(product_state(bit\"100\"), repeat(3, H, 1:3))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> measure(repeat(3, X, 1:3), reg; nshots=3)\n3-element Vector{ComplexF64}:\n -1.0 + 0.0im\n -1.0 + 0.0im\n -1.0 + 0.0im\n\njulia> reg = apply!(product_state(bit\"101\"), repeat(3, H, 1:3))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> measure(repeat(3, X, 1:3), reg; nshots=3)\n3-element Vector{ComplexF64}:\n 1.0 - 0.0im\n 1.0 - 0.0im\n 1.0 - 0.0im\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoAPI.expect","page":"Registers and Observables","title":"YaoAPI.expect","text":"expect(op::AbstractBlock, reg) -> Vector\nexpect(op::AbstractBlock, reg => circuit) -> Vector\nexpect(op::AbstractBlock, density_matrix) -> Vector\n\nGet the expectation value of an operator, the second parameter can be a register reg or a pair of input register and circuit reg => circuit.\n\nexpect'(op::AbstractBlock, reg=>circuit) -> Pair\nexpect'(op::AbstractBlock, reg) -> AbstracRegister\n\nObtain the gradient with respect to registers and circuit parameters. For pair input, the second return value is a pair of gψ=>gparams, with gψ the gradient of input state and gparams the gradients of circuit parameters. For register input, the return value is a register.\n\nnote: Note\nFor batched register, expect(op, reg=>circuit) returns a vector of size number of batch as output. However, one can not differentiate over a vector loss, so expect'(op, reg=>circuit) accumulates the gradient over batch, rather than returning a batched gradient of parameters.\n\nExamples\n\njulia> r = normalize!(product_state(bit\"11\") + product_state(bit\"00\"))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 2/2\n    nlevel: 2\n\njulia> op = chain(2, put(1=>H), put(2=>X))\nnqubits: 2\nchain\n├─ put on (1)\n│  └─ H\n└─ put on (2)\n   └─ X\n\n\njulia> expect(op, r)\n0.7071067811865474 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoArrayRegister.statevec","page":"Registers and Observables","title":"YaoArrayRegister.statevec","text":"statevec(r::ArrayReg) -> array\n\nReturn a state matrix/vector by droping the last dimension of size 1 (i.e. nactive(r) = nqudits(r)). See also state.\n\nwarning: Warning\nstatevec is not type stable. It may cause performance slow down.\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoArrayRegister.zero_state","page":"Registers and Observables","title":"YaoArrayRegister.zero_state","text":"zero_state([T=ComplexF64], n::Int, subspace; nlevel=2)\n\nCreate a SubspaceArrayReg in zero state in given subspace.\n\nArguments\n\nT: optional, element type, default is ComplexF64.\nn: required, number of atoms (qubits).\nsubspace: required, the subspace of rydberg state.\n\n\n\n\n\nzero_state([T=ComplexF64], n::Int; nbatch::Int=NoBatch())\n\nCreate an AbstractArrayReg that initialized to state 0rangle^otimes n. See also product_state, rand_state, uniform_state and ghz_state.\n\nExamples\n\njulia> zero_state(4)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\njulia> zero_state(ComplexF32, 4)\nArrayReg{2, ComplexF32, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\njulia> zero_state(ComplexF32, 4; nbatch=3)\nBatchedArrayReg{2, ComplexF32, Transpose...}\n    active qubits: 4/4\n    nlevel: 2\n    nbatch: 3\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoArrayRegister.rand_state","page":"Registers and Observables","title":"YaoArrayRegister.rand_state","text":"rand_state([T=ComplexF64], subspace; nlevel=2)\n\nCreate a random state in the given subspace.\n\n\n\n\n\nrand_state([T=ComplexF64], n::Int; nbatch=NoBatch(), no_transpose_storage=false)\n\nCreate a random AbstractArrayReg with total number of qudits n.\n\nExamples\n\njulia> rand_state(4)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\njulia> rand_state(ComplexF64, 4)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\njulia> rand_state(ComplexF64, 4; nbatch=2)\nBatchedArrayReg{2, ComplexF64, Transpose...}\n    active qubits: 4/4\n    nlevel: 2\n    nbatch: 2\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoArrayRegister.product_state","page":"Registers and Observables","title":"YaoArrayRegister.product_state","text":"product_state([T=ComplexF64], config, subspace)\n\nCreate a product state of given config from subspace.\n\n\n\n\n\nproduct_state([T=ComplexF64], dit_str; nbatch=NoBatch(), no_transpose_storage=false)\nproduct_state([T=ComplexF64], nbits::Int, val::Int; nbatch=NoBatch(), nlevel=2, no_transpose_storage=false)\nproduct_state([T=ComplexF64], vector; nbatch=NoBatch(), nlevel=2, no_transpose_storage=false)\n\nCreate an ArrayReg of product state. The configuration can be specified with a dit string, which can be defined with @bit_str or @dit_str. Or equivalently, it can be specified explicitly with nbits, val and nlevel. See also zero_state, rand_state, uniform_state.\n\nExamples\n\njulia> reg = product_state(dit\"120;3\"; nbatch=2)\nBatchedArrayReg{3, ComplexF64, Transpose...}\n    active qudits: 3/3\n    nlevel: 3\n    nbatch: 2\n\njulia> measure(reg)\n1×2 Matrix{BitBasis.DitStr64{3, 3}}:\n 120 ₍₃₎  120 ₍₃₎\n\njulia> product_state(bit\"100\"; nbatch=2);\n\njulia> r1 = product_state(ComplexF32, bit\"001\"; nbatch=2);\n\njulia> r2 = product_state(ComplexF32, [1, 0, 0]; nbatch=2);\n\njulia> r3 = product_state(ComplexF32, 3, 0b001; nbatch=2);\n\njulia> r1 ≈ r2   # because we read bit strings from right to left, vectors from left to right.\ntrue\n\njulia> r1 ≈ r3\ntrue\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoSubspaceArrayReg.SubspaceArrayReg","page":"Registers and Observables","title":"YaoSubspaceArrayReg.SubspaceArrayReg","text":"SubspaceArrayReg{D, T, State, Space} <: AbstractArrayReg{D}\nSubspaceArrayReg{D}(state, subspace)\nSubspaceArrayReg(state, subspace)\n\nType for registers in a subspace. The subspace must be a Subspace.\n\n\n\n\n\n","category":"type"},{"location":"registers/#YaoSubspaceArrayReg.set_zero_state!","page":"Registers and Observables","title":"YaoSubspaceArrayReg.set_zero_state!","text":"set_zero_state!(register)\n\nSet the given register to |00...00⟩.\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoBlocks.ConstGate.X","page":"Registers and Observables","title":"YaoBlocks.ConstGate.X","text":"X\nXGate <: ConstantGate{1,2}\n\nPauli X gate. X is the instance of XGate.\n\n\n\n\n\n","category":"constant"},{"location":"registers/#YaoBlocks.ConstGate.Y","page":"Registers and Observables","title":"YaoBlocks.ConstGate.Y","text":"Y\nYGate  <: ConstantGate{1,2}\n\nPauli Y gate. Y is the instance of YGate.\n\n\n\n\n\n","category":"constant"},{"location":"registers/#YaoBlocks.ConstGate.Z","page":"Registers and Observables","title":"YaoBlocks.ConstGate.Z","text":"Z\nZGate  <: ConstantGate{1,2}\n\nPauli Z gate. Z is the instance of YGate.\n\n\n\n\n\n","category":"constant"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"EditURL = \"https://github.com/QuEraComputing/Bloqade.jl/blob/master/examples/4.LGT/main.jl\"","category":"page"},{"location":"tutorials/4.LGT/main/#Simulation-of-lattice-gauge-theory-with-Rydberg-atoms","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"","category":"section"},{"location":"tutorials/4.LGT/main/#Introduction","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Introduction","text":"","category":"section"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"In previous examples, we have shown how to prepare Z_2 ordered ground state for the Rydberg system, and discussed the quantum scar phenomenon, which is the oscillation between two ordered patterns of Rydberg densities. We note that these are achieved by tuning the detuning and the Rabi frequency of the lasers that address all the atoms simulatenously.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"In this tutorial, we shall simulate the dynamics of lattice gauge theory (LGT) with a 1D Rydberg atom chain. In the context of gauge theory, it turns out that the Z_2 ground state and the quantum scar of the Rydberg chain correspond to the \"string\" state and the string-inversion mechanism of the studied LGT respectively. More interestingly, by locally addressing certain atoms, we can create defects in the chain and simulate the propagation of particle-antiparticle pairs. This tutorial is inspired by the paper: Federica M. Surace, et al..","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"We first import the required packages","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"using Bloqade\nusing PythonCall\nplt = pyimport(\"matplotlib.pyplot\");","category":"page"},{"location":"tutorials/4.LGT/main/#Mapping-between-the-Rydberg-system-and-the-LGT","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Mapping between the Rydberg system and the LGT","text":"","category":"section"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"In this tutorial, we are interested in the so-called quantum link model (QLM) formulation of the LGT. In this formalism, depending on the configurations of the even and odd sites, the bonds between them could be interpretted as a particle q, an antiparticle barq or a vacuum state. More specifically, the bond between an odd and an even sites corresponds to an antiparticle if both atoms are in the ground states, otherwise it is interpretted as a vacuum state. On the other hand, the bond between an even and an odd sites corresponds to a particle if both atoms are in the ground states, otherwise it is interpreted as a vacuum. Further, the Rydberg states at the odd (even) sites are interpretted as electric fields pointing to the left (right), whereas the ground states at the odd (even) sites are electric field pointing to the right (left). The electric fields correspond to the red and blue arrows in the following figure, which summarizes the mappings described above (source: Federica M. Surace, et al.). For more details on the LGT and its mapping to the Rydberg system, the readers are encouraged to read the paper cited above.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"(Image: mapping)","category":"page"},{"location":"tutorials/4.LGT/main/#Preparing-the-initial-state-for-the-LGT-dynamics","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Preparing the initial state for the LGT dynamics","text":"","category":"section"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"The LGT dynamics starts from the \"anti-string\" state with all electric fields pointing to the right. This is nothing but the Z_2 ordered state in the language of Rydberg system, and we have seen how to prepare it in previous tutorials. Here, we are interested in a 1D lattice with 21 atoms. The neighboring atoms are separated by 55μm such that they are blockaded throughout the dynamics (the typical value of the Rabi frequency is 10pi MHz throughout the dynamics, which corresponds to blockade radius R_bapprox746μm. See below).","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"a = 5.5;\nN = 21;\natoms = generate_sites(ChainLattice(), N, scale=a);\nsubspace = blockade_subspace(atoms, a);","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"In order to prepare the anti-string state of the LGT, we use piecewise linear waveforms for both the detuning and the Rabi frequency. The waveforms will last for 35μs.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"total_time = 3.5;\nΩmax = 2π * 5;\nΔmin = -2π * 10;\nΔmax = 2π * 10;\n\nΔ1 = piecewise_linear(clocks = [0.0, 0.2, total_time], values = [Δmin, Δmin, Δmax]);\nΩ1 = piecewise_linear(clocks = [0.0, 0.2, total_time], values = [0.0, Ωmax, Ωmax]);","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"The waveforms for the detuning and the Rabi frequency are shown below","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"fig1, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (12, 4))\nBloqade.plot!(ax1, Ω1)\nBloqade.plot!(ax2, Δ1)\nax1.set_ylabel(\"Ω1/2π (MHz)\")\nax2.set_ylabel(\"Δ1/2π (MHz)\")\nax1.grid()\nax2.grid()\nfig1","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"(Image: )","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"In order to simulate the gauge theory dynamics, we define the function get_average_rydberg_densities which takes in a given set of detuning and Rabi frequency (Δ Ω), and returns the final state and the Rydberg density.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"function get_average_rydberg_densities(Δ, Ω; dt=1e-3)\n    h = rydberg_h(atoms; Δ=Δ, Ω=Ω)\n    reg = zero_state(subspace)\n\n    duration = Ω.duration\n    prob = SchrodingerProblem(reg, duration, h, progress=true);\n    integrator = init(prob, Vern8());\n    densities = []\n    for _ in TimeChoiceIterator(integrator, 0.0:dt:duration)\n        normalize!(reg)\n        push!(densities, rydberg_density(reg))\n    end\n\n    return densities\nend;","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"We can confirm that the waveforms produce the desired anti-string state of the LGT, by simulating the dynamics governed by the waveforms, followed by plotting the density profile, as shown below","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"dens1 = get_average_rydberg_densities(Δ1, Ω1) ;\nfig2, ax = plt.subplots(figsize = (10, 4)) ;\nax.bar(1:N, dens1[end]) ;\nax.set_xlabel(\"site index\")\nax.set_ylabel(\"Average Rydberg densities\")\nfig2","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"(Image: )","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"Recall the mapping between the Rydberg chain and the LGT illustrated above, we see that the final state is an approximation of the anti-string state of the LGT, or a Z_2 ordered state of the Rydberg chain. It is not perfectly Z_2 ordered where the discrepancy is more promonient at the center compared to the edge of the chain. But as we will see later, the prepared state is sufficient for demonstrating the dynamics of the interested LGT.","category":"page"},{"location":"tutorials/4.LGT/main/#Propagation-of-particle-antiparticle-pairs","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Propagation of particle-antiparticle pairs","text":"","category":"section"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"In order to simulate the particle-antiparticle dynamics of the interested LGT, next, we prepare defects in the anti-string state, which are links with right-pointing electric fields. The domain walls between anti-string and string states will host particles, whereas those between string and anti-string states will host anti-particles. These can be seen via the mapping between Rydberg system and LGT illustrated above. Interestingly, the particle and antiparticle always come in pairs, and their time evolution exhibits light cones, in which the string-antistring oscillation is out-of-phase compared to that outside of the light cone. This is illustrated below (source: Federica M. Surace, et al.).","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"(Image: propagation)","category":"page"},{"location":"tutorials/4.LGT/main/#Site-dependent-waveforms","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Site-dependent waveforms","text":"","category":"section"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"To realize the defects, we turn off the detuning for the target atoms while maintaining the same Rabi frequency for all the atoms. This effectively applies a pi-pulse to the target atoms for transitioning them from the Rydberg state to the ground state.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"Δq = 0.0;\ntq = π/Ωmax;","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"The waveforms of the detunings for creating one and two defects are defined as following","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"Δ2_single_defect = map(1:length(atoms)) do idx\n    if idx == floor(Int, N/2)+1\n        append(Δ1, constant(duration=tq, value=Δq))\n    else\n        append(Δ1, constant(duration=tq, value=Δmax))\n    end\nend ;\n\nΔ2_two_defects = map(1:length(atoms)) do idx\n    if idx == floor(Int, N/3) || idx == floor(Int, N-N/3)+1\n        append(Δ1, constant(duration=tq, value=Δq))\n    else\n        append(Δ1, constant(duration=tq, value=Δmax))\n    end\nend ;","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"We append to a constant waveform with the same amplitude to the Rabi frequency such that it has the same duration as the detunings.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"Ω2 = append(Ω1, constant(duration=tq, value=Ωmax));","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"As an example, for the case with a single defect, we show the detuning for the central site, which is the defect, and those for other sites separately below.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"fig3, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (12, 4))\nfor idx in 1 : length(atoms)\n    if idx == floor(Int, N/2)+1\n        Bloqade.plot!(ax1, Δ2_single_defect[idx])\n    else\n        Bloqade.plot!(ax2, Δ2_single_defect[idx])\n    end\nend\nax1.grid()\nax2.grid()\nax1.set_title(\"Detuning for the central site\")\nax2.set_title(\"Detunings for other sites\")\n\nfig3","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"(Image: )","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"We can confirm that the waveforms produce the desired domain walls for the LGT states, by simulating the dynamics governed by the waveforms, followed by plotting their density profiles.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"dens2 = get_average_rydberg_densities(Δ2_single_defect, Ω2)\ndens3 = get_average_rydberg_densities(Δ2_two_defects, Ω2)\n\nfig4, (ax1, ax2) = plt.subplots(nrows = 2, figsize = (10, 4), frameon=false)\nax1.bar(1:N, dens2[end])\nax2.bar(1:N, dens3[end])\nfig4.supxlabel(\"site index\")\nfig4.supylabel(\"Average Rydberg densities\", x=0.06)\nfig4","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"(Image: )","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"Again, we see that the Rydberg density at the defects are not exactly zero, but the prepared states, as we shall see below, serve as good initial states to study the propagation of particle-antiparticle pairs in LGT.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"We define the very last piece in the Rabi frequency and detuning that govern the time evolution of the Rydberg chain with defects.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"Δq2 = -π ;\ntq2 = 40/Ωmax ;\n\nΔ3_single_defect = map(1:length(atoms)) do idx\n    append(Δ2_single_defect[idx], constant(duration=tq2, value=Δq2))\nend\nΔ3_two_defects = map(1:length(atoms)) do idx\n    append(Δ2_two_defects[idx], constant(duration=tq2, value=Δq2))\nend\n\nΩ3 = append(Ω2, constant(duration=tq2, value=Ωmax));","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"Again, as an example, for the case with a single defect, we show the detuning for the central site, which is the defect, and those for other sites separately below.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"fig5, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (12, 4))\nfor idx in 1 : length(atoms)\n    if idx == floor(Int, N/2)+1\n        Bloqade.plot!(ax1, Δ3_single_defect[idx])\n    else\n        Bloqade.plot!(ax2, Δ3_single_defect[idx])\n    end\nend\nBloqade.plot!(ax1, Ω3)\nax1.grid()\nax2.grid()\nax1.legend([\"Detuning for the central site\", \"Rabi frequency for all sites\"])\nax2.legend([\"Detunings for other sites\"], loc=\"center left\")\n\nfig5","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"(Image: )","category":"page"},{"location":"tutorials/4.LGT/main/#Simulation-particle-antiparticle-pairs-in-LGT-dynamics","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation particle-antiparticle pairs in LGT dynamics","text":"","category":"section"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"With the waveforms defined, we can run the simulation to evolve the Rydberg chains with defects and collect the final Rydberg densities.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"densities_single_defect = get_average_rydberg_densities(Δ3_single_defect, Ω3);\ndensities_two_defects = get_average_rydberg_densities(Δ3_two_defects, Ω3);\n\nD_single_defect = hcat(densities_single_defect...);\nD_two_defects = hcat(densities_two_defects...);","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"To better visualize the propagation of particle-antiparticle pairs, we shall only show the Rydberg densities starting from the time point when the ground state of the defect chain is prepared.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"ind0 = 3550;\nD_single_defect = D_single_defect[:, ind0:end];\nD_two_defects = D_two_defects[:, ind0:end];\n\nclocks = 0:1e-3:Ω3.duration;\nclocks = clocks[ind0: end];","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"Then we plot the Rydberg density as a function of time, where the two panels correspond to the cases with single and two defects respectively","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"yticks = range(clocks[1], stop=clocks[end], length=10);\nyticks = [string(ytick)[1:4] for ytick in yticks][end:-1:1];\nfig6, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (12, 8), sharey=true)\nax1.imshow(transpose(D_single_defect)[end:-1:1,:], aspect=\"auto\", interpolation=\"none\")\nax1.set_xlabel(\"sites\")\nax1.set_ylabel(\"time (μs)\")\nax1.set_yticks(range(1, stop = length(clocks), length=10), yticks)\nim = ax2.imshow(transpose(D_two_defects)[end:-1:1,:], aspect=\"auto\", interpolation=\"none\")\nax2.set_xlabel(\"sites\")\nfig6.colorbar(im, ax=[ax1, ax2])\nfig6","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"(Image: )","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"From the left panel, we can observe a light-cone-shaped region originating from the particle-antiparticle pair in the vacuum. At the right panel, we show the interference of two light cones, which produces an additional change of periodicity corresponding to the elastic scattering. When the particle or antiparticle reaches the boundary of the chain, it will be scattered back as observed. For more details, the interested readers are referred to the paper Federica M. Surace, et al..","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"In summary, we have shown that the ground state and the dynamics of certain LGT can be simulated by a 1D chain of Rydberg atoms. More interestingly, defects can be introduced by locally addressing certain atoms in the chain, and with that we can simulate the propagation of particle-antiparticle pairs in the LGT dynamics.","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"","category":"page"},{"location":"tutorials/4.LGT/main/","page":"Simulation of lattice gauge theory with Rydberg atoms","title":"Simulation of lattice gauge theory with Rydberg atoms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"EditURL = \"https://github.com/QuEraComputing/Bloqade.jl/blob/master/examples/6.MWIS/main.jl\"","category":"page"},{"location":"tutorials/6.MWIS/main/#Maximum-Weight-Independent-Set","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"","category":"section"},{"location":"tutorials/6.MWIS/main/#Background","page":"Maximum Weight Independent Set","title":"Background","text":"","category":"section"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"In the The Maximum Independent Set Problem page, we provide a detailed example on how to solve the Maximum Independent Set (MIS) problem using neutral-atom quantum computers. The first algorithm proposal and experimental demonstration can be found in H. Pichler, et al. and S. Ebadi, et al.. In this tutorial, we present a more advanced example of using neutral atom quantum computers to solve the maximum weight independent set (MWIS) problem on a weighted unit disk graph, with arbitrary weights for each vertex. The MWIS problem seeks to find an independent set whose weights sum to the maximum possible value.","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"We first import the required packages to compute MWIS classically:","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"using Random\nRandom.seed!(42)\nusing Graphs\nusing GenericTensorNetworks\nusing GenericTensorNetworks: unit_disk_graph\nusing Bloqade\nusing PythonCall\nplt = pyimport(\"matplotlib.pyplot\");","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"We now specify the atom locations and construct an example unit disk graph on a square lattice with nearest neighbor connections. The atoms represent vertices on the problem graph, and all vertices closer than a distance 1.5 are connected by an edge.","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"locs = [(1, -1), (4, 0), (1, 1), (2, 0), (0, 0), (2, 2), (2, -2), (3, 1), (3, -1)];\ng = unit_disk_graph(locs, 1.5)\nshow_graph(g; locs = locs, vertex_colors = [\"white\" for i in 1:nv(g)])","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"(Image: )","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"We then assign random weights to each vertex for this example problem:","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"weights = [rand() for i in 1:nv(g)];","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"We can solve the MWIS problem classically for this graph using the GenericTensorNetworks package. The MWIS is shown in red.","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"configs_mapped = GenericTensorNetworks.solve(IndependentSet(g; weights = weights), ConfigsMax())[]\nMIS_config = configs_mapped.c[1]\nshow_graph(g; locs = locs, vertex_colors = [iszero(MIS_config[i]) ? \"white\" : \"red\" for i in 1:nv(g)])","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"(Image: )","category":"page"},{"location":"tutorials/6.MWIS/main/#Quantum-Adiabatic-Algorithm-to-Solve-the-MWIS-Problem","page":"Maximum Weight Independent Set","title":"Quantum Adiabatic Algorithm to Solve the MWIS Problem","text":"","category":"section"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"The quantum adiabatic algorithm (QAA) can be performed with the Hamiltonian:","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"H_textQA(t) = sum_v in V (- Delta_v(t) n_v + frac12Omega_v(t) sigma_v^x) + sum_(u w) in E U_uw n_u n_w","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":".","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"Here, we work in the limit of Delta Omega ll U, where the non-independent set space of the graph can be neglected (on neutral-atom quantum hardware, this corresponds to the limit where the interaction energy is much stronger than other energy scales). In this limit, we can restrict outselves to the Rydberg blockade subspace (see blockade) of the graph and ignore the interaction term sum_(u w) in E U n_u n_w in the Hamiltonian. Note that in this tutorial, we also do not include the long-range interaction tail in the Hamiltonian. The vertex weights of the MWIS problem in this Hamiltonian can be implemented on the hardware with individual atom detunings (specifying Delta_v(t) for each atom).","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"The QAA can be designed by first initializing all qubits to the ground state of H_textQA(t = 0) where Delta(t = 0) = -Delta_0  0  and Omega(t = 0) = 0; the many-body ground state is basically with all atoms in the ground state  g rangle. We then change the parameters by turning up Omega(t) to a finite value and then to 0, and sweeping Delta(t) to Delta_0  0 after some final time t_f.","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"By the adiabatic theorem, when the time evolution is sufficiently slow, the system should follow the instantaneous ground state and ends up in the solution to the MWIS problem.","category":"page"},{"location":"tutorials/6.MWIS/main/#Building-Pulse-Sequences","page":"Maximum Weight Independent Set","title":"Building Pulse Sequences","text":"","category":"section"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"Since we are considering the MWIS problem, we can implement individual atom detuning with, e.g., Delta(t)_i = w_i times Delta(t).","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"Let's first build and plot the individual pulse waveforms. We use the following function to build the Hamiltonian and the corresponding waveforms for the adiabatic evolution of the system:","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"function build_adiabatic_sweep(graph, Ω_max::Float64, Δ_max::Float64, t_max::Float64, weights::Vector{Float64})\n    Ω = Waveform(t -> Ω_max * sin(pi * t / t_max)^2, duration = t_max)\n    Δ = map(1:nv(graph)) do idx\n        return Waveform(t -> weights[idx] * Δ_max * (2 * t / t_max - 1), duration = t_max)\n    end\n    h = SumOfX(nv(graph), Ω) / 2 - SumOfN(nv(graph), Δ)\n    return h, Ω, Δ\nend","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"build_adiabatic_sweep (generic function with 1 method)","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"Here, we choose Delta_max  Omega_max = 3, with Omega_max = 2 pi times 4 MHz:","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"Ω_max = 2π * 4\nΔ_max = 3 * Ω_max\nt_max = 1.5\nH, Ω, Δ = build_adiabatic_sweep(g, Ω_max, Δ_max, t_max, weights);\n\nfig, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (14, 4))\nBloqade.plot!(ax1, Ω)\nax1.set_ylabel(\"Ω/2π (MHz)\")\nfor i in 1:nv(g)\n    Bloqade.plot!(ax2, Δ[i])\nend\nax2.set_ylabel(\"Δ/2π (MHz)\")\nfig","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"(Image: )","category":"page"},{"location":"tutorials/6.MWIS/main/#Compute-the-MIS-Probability-and-the-Adiabatic-Timescale","page":"Maximum Weight Independent Set","title":"Compute the MIS Probability and the Adiabatic Timescale","text":"","category":"section"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"Here, We compute the MWIS probability of the graph as a function of time. In addition, we would like to extract the adiabatic timescale T_textLZ from the Landau-Zener fitting: 1 - P_textMWIS = e^a - TT_textLZ. To do this, we find the first instance time T^* such that P_textMWIS(T)  09, and then continue to run evolutions to 25T^* to extract T_textLZ. See H. Pichler, et al. for more details on the procedure to extract the Landau-Zener timescale.","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"We run the simulation in the blockade (independent set) subspace:","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"t_list = []\nP_MWIS = [] # MIS probability\nsubspace = independent_set_subspace(g);\n\ntotal_time = 1.5\nfor t in 0.1:total_time*0.25:total_time*2.5\n    h = build_adiabatic_sweep(g, Ω_max, Δ_max, t, weights)[1]\n    r = zero_state(subspace)\n    prob = SchrodingerProblem(r, t, h)\n    emulate!(prob)\n    p = config_probability(prob.reg, g, BitVector(MIS_config))\n\n    push!(t_list, t)\n    push!(P_MWIS, p)\nend","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"We can compute the adiabatic timescale by fitting a Landau-Zener curve to the MIS probability:","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"using CurveFit\ny = broadcast(log, 1 .- P_MWIS[P_MWIS.>0.9])\na, b = linear_fit(t_list[P_MWIS.>0.9], y)\nT_LZ = -1 / b;","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"Finally, we plot the results:","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"fig, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (16, 6))\nax1.scatter(t_list, P_MWIS)\nax1.set_ylabel(\"MWIS Probability\")\nax1.set_xlabel(\"Time (μs)\")\n\nax2.scatter(t_list, broadcast(log, 1 .- P_MWIS))\nax2.plot(t_list, a .+ b .* t_list)\nax2.set_xlabel(\"Time (μs)\")\nax2.set_ylabel(\"log(1 - MWIS Probability)\")\n\nfig","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"(Image: )","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"","category":"page"},{"location":"tutorials/6.MWIS/main/","page":"Maximum Weight Independent Set","title":"Maximum Weight Independent Set","text":"This page was generated using Literate.jl.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"CurrentModule = Bloqade","category":"page"},{"location":"hamiltonians/#Hamiltonians","page":"Hamiltonians","title":"Hamiltonians","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Quantum Hamiltonians encode the essential physical properties of a quantum system. For the analog mode of neutral-atom quantum computers, the quantum dynamics is governed by the Rydberg Hamiltonian hatmathcalH:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"i hbar dfracpartialpartial t  psi rangle = hatmathcalH(t)  psi rangle  \n\nfracmathcalH(t)hbar = sum_j fracOmega_j(t)2 left( e^i phi_j(t)   g_j rangle  langle r_j  + e^-i phi_j(t)   r_j rangle  langle g_j  right) - sum_j Delta_j(t) hatn_j + sum_j  k V_jk hatn_j hatn_k","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"where Omega_j, phi_j, and Delta_j  denote the Rabi frequency, laser phase, and the detuning of the driving laser field on atom (qubit) j coupling the two states   g_j rangle (ground state) and  r_j rangle (Rydberg state); hatn_j = r_jrangle langle r_j is the number operator, and V_jk = C_6overrightarrowmathbfr_j - overrightarrowmathbfr_k^6 describes the Rydberg interaction (van der Waals interaction) between atoms j and k where overrightarrowmathbfr_j denotes the position of the atom j; C_6 is the Rydberg interaction constant that depends on the particular Rydberg state used. For Bloqade, the default C_6 = 862690 times 2pi text MHz μm^6 for r rangle = lvert 70S_12 rangle of the ^87Rb atoms; hbar is the reduced Planck's constant.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"One can use the Rydberg Hamiltonian to  understand the ground state properties of the corresponding system and to generate interesting quantum dynamics.  The Rydberg Hamiltonian is generally specified by atom positions overrightarrowmathbfr_j, Rabi frequencies Omega_j, laser phase phi_j, and detunings Delta_j. In Bloqade,  we can easily create a Hamiltonian by inputting these variable parameters into the function rydberg_h. Furthermore, by inputting waveforms for the Rabi frequency and  detuning, we can easily generate time-dependent Hamiltonians. ","category":"page"},{"location":"hamiltonians/#Building-Time-Independent-Hamiltonians","page":"Hamiltonians","title":"Building Time-Independent Hamiltonians","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"To specify the Hamiltonian, we first need to specify the atom positions, which determine the Rydberg interactions strengths V_jk between pairs of atoms. Here, we generate a square lattice by using the code below:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using Bloqade\natoms = generate_sites(SquareLattice(), 3, 3, scale=6.3)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Please refer to the Lattices page for more details on how to generate lattices and the relevant operations. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Then, the Hamiltonian can be simply built by inputting the generated atom positions atoms and by specifying the strength of the detuning Δ, Rabi frequency Ω, and laser phase ϕ:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"h0 = rydberg_h(atoms; Δ=1.2*2π, Ω=1.1*2π, ϕ=2.1)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Note that the default value for the Rydberg interaction constant is C_6 = 2pi times 862690 text MHz μm^6 to match the default unit used on the hardware. For more information about units, please  refer to Bloqade. Instead of using the default value for C_6, the users are free to set their own values. For instance, if the users would like to have a chain lattice with nearest-neighbor atoms separated by 1 μm, and interaction strength to be a particular value, say, 2pi * 100^6 text MHz μm^6, it can be done with the following code:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"atoms = generate_sites(ChainLattice(), 9, scale=1.0)\nh0 = rydberg_h(atoms; C=2π*10.0^6, Δ=1.2*2π, Ω=1.1*2π, ϕ=2.1)","category":"page"},{"location":"hamiltonians/#Building-Time-Dependent-Hamiltonians","page":"Hamiltonians","title":"Building Time-Dependent Hamiltonians","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"One can also directly use waveforms (instead of constant values of detuning, Rabi frequency, and laser phase) to build a time-dependent Hamiltonian.  First, let us again use the  generate_sites to create a list of atom coordinates: ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"atoms = generate_sites(ChainLattice(), 5, scale=5.72)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Then, we generate the time-dependent pulses for Omega and Delta by using  piecewise_linear. For details on how to create waveforms and the built-in functions, please refer to the page Waveforms. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Ω1 = piecewise_linear(clocks=[0.0, 0.1, 2.1, 2.2], values=2π*[0.0, 6.0, 6.0, 0]);\nΔ1 = piecewise_linear(clocks=[0.0, 0.6, 2.1, 2.2], values=2π*[-10.1, -10.1, 10.1, 10.1]);","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The time-dependent Hamiltonian can then be easily generated by inputting the waveforms into the function rydberg_h:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"h1 = rydberg_h(atoms; Δ=Δ1, Ω=Ω1)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"By specifying the time of h1, we can access the Hamiltonian at a particular time, e.g.: ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"ht= h1 |> attime(0.5)","category":"page"},{"location":"hamiltonians/#Building-Hamiltonians-with-Site-Dependent-Waveforms","page":"Hamiltonians","title":"Building Hamiltonians with Site-Dependent Waveforms","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"In certain cases, the user may want to build a Hamiltonian that has site-dependent Omega_j, phi_j, and Delta_j, which may or may not have time dependence.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"For the time-independent Hamiltonian, one can for example build a Hamiltonian like: ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"h0 = rydberg_h(atoms; Δ=1.2*2π*rand(length(atoms)), Ω=1.1*2π*rand(length(atoms)), ϕ=2.1)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"For time-dependent Hamiltonians, here is an example:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"atoms = generate_sites(ChainLattice(), 5, scale=5.72)\nΔ1 = map(1:length(atoms)) do idx\n    Waveform(t-> idx*sin(2π*t), duration = 2)\nend\nh =rydberg_h(atoms; Δ=Δ1)","category":"page"},{"location":"hamiltonians/#Hamiltonian-Expressions","page":"Hamiltonians","title":"Hamiltonian Expressions","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Bloqade uses \"block\"s from Yao to build symbolic hamiltonian expressions. This gives users the flexibility to define various   kinds of Hamiltonians by simply writing down the expression.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Please refer to the References section below for the types of operators supported by Bloqade.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"As an example, we can explicitly add up some Hamiltonian terms to compose a new Hamiltonian, e.g.:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using Bloqade\nh = 2π*1.1*SumOfX(5, 1.0) + 2π*1.2*SumOfZ(5, 1.0)","category":"page"},{"location":"hamiltonians/#Convert-Hamiltonians-to-Matrices","page":"Hamiltonians","title":"Convert Hamiltonians to Matrices","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"An Hamiltonian expression can be converted to a matrix via the mat interface from Yao:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"mat","category":"page"},{"location":"hamiltonians/#YaoAPI.mat","page":"Hamiltonians","title":"YaoAPI.mat","text":"mat([T=ComplexF64], blk)\n\nReturns the most compact matrix form of given block, e.g\n\nExamples\n\njulia> mat(X)\n2×2 LuxurySparse.SDPermMatrix{ComplexF64, Int64, Vector{ComplexF64}, Vector{Int64}}:\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im\n\njulia> mat(Float64, X)\n2×2 LuxurySparse.SDPermMatrix{Float64, Int64, Vector{Float64}, Vector{Int64}}:\n 0.0  1.0\n 1.0  0.0\n\njulia> mat(kron(X, X))\n4×4 LuxurySparse.SDPermMatrix{ComplexF64, Int64, Vector{ComplexF64}, Vector{Int64}}:\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n\njulia> mat(kron(X, X) + put(2, 1=>X))\n4×4 SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:\n     ⋅      1.0+0.0im      ⋅      1.0+0.0im\n 1.0+0.0im      ⋅      1.0+0.0im      ⋅\n     ⋅      1.0+0.0im      ⋅      1.0+0.0im\n 1.0+0.0im      ⋅      1.0+0.0im      ⋅    \n\n\n\n\n\n","category":"function"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"This method will return the most compact matrix representation of the operator, e.g.:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"mat(X) # will return a PermMatrix\nmat(ht) # will return a SparseMatrixCSC","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The Hamiltonian matrix can also be created in a subspace, such as the blockade subspace (see also Working with Subspace). This will allow one to simulate larger system sizes because of the smaller truncated Hilbert space.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"For the Rydberg Hamiltonian, we can create a subspace via the blockade_subspace method, e.g.:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"space = blockade_subspace(atoms, 7.5)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The above code means that the blockade subspace only includes states where there is only one Rydberg excitation  within the distance of 7.5 μm, which we call the subspace radius R_s. If we have a chain of atoms separated by 5.72 μm, the blockade subspace  does not contain states with nearest-neighbor atoms being simutaneously excited to the Rydberg state  r rangle.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Once we have defined the space, we can convert the Hamiltonian to a matrix in a subspace basis via the codes below:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"h_m = mat(ht, space)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"We can see that the size of the Hamiltonian matrix in the blockade subspace is much smaller than that in the full Hilbert space.","category":"page"},{"location":"hamiltonians/#Diagonalization-of-the-Hamiltonian","page":"Hamiltonians","title":"Diagonalization of the Hamiltonian","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Bloqade doesn't provide any built-in diagonalization tool, as there are many existing  tools in the Julia ecosystem. Here, we demonstrate how to use the KrylovKit package for this purpose as follows:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using KrylovKit\nvals, vecs, info = KrylovKit.eigsolve(h_m,  1, :SR)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"where the vals and vecs store the calculated eigenvalues and eigenvectors respectively. ","category":"page"},{"location":"hamiltonians/#Low-Level-Representation-of-the-Hamiltonian","page":"Hamiltonians","title":"Low-Level Representation of the Hamiltonian","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Besides the symbolic representation, in order to achieve the best possible performance, we use a lower-level representation of the Hamiltonian in Bloqade, which is the Hamiltonian and StepHamiltonian type:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"BloqadeExpr.Hamiltonian\nBloqadeExpr.StepHamiltonian","category":"page"},{"location":"hamiltonians/#BloqadeExpr.Hamiltonian","page":"Hamiltonians","title":"BloqadeExpr.Hamiltonian","text":"struct Hamiltonian\n\nHamiltonian stores the dynamic prefactors of each term. The actual hamiltonian is the sum of f_i(t) * t_i where f_i and t_i are entries of fs and ts.\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/#BloqadeExpr.StepHamiltonian","page":"Hamiltonians","title":"BloqadeExpr.StepHamiltonian","text":"struct StepHamiltonian\n\nA low-level linear-map object that encodes time-dependent hamiltonian at time step t. This object supports the linear map interface mul!(Y, H, X).\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The Hamiltonian type represents the following Hamiltonian expression","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"f_1(t) H_1 + f_2(t) H_2 + cdots + f_n(t) H_n + H_c","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"where f_i(t) are time-dependent parameters of the Hamiltonian, H_i are time-independent local terms of the Hamiltonian as linear operators (in Julia, this means objects that support LinearAlgebra.mul! interface), and H_c is the constant component of the Hamiltonian.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"A Hamiltonian object supports callable methods, which will produce a StepHamiltonian that is time-independent, e.g.:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using BloqadeExpr\nh = BloqadeExpr.Hamiltonian(Float64, SumOfX(5, sin) + SumOfZ(5, cos))\nh(0.1)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Here, we see that the Hamiltonian expression written as Yao blocks are automatically analyzed into time-dependent terms and constant terms. A more complicated example can be SumOfXPhase:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using BloqadeExpr\nh = BloqadeExpr.Hamiltonian(Float64, SumOfXPhase(5, sin, cos) + SumOfZ(5, cos))\nh(0.1)","category":"page"},{"location":"hamiltonians/#References","page":"Hamiltonians","title":"References","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"rydberg_h","category":"page"},{"location":"hamiltonians/#BloqadeExpr.rydberg_h","page":"Hamiltonians","title":"BloqadeExpr.rydberg_h","text":"rydberg_h(atoms; [C=2π * 862690 * MHz*µm^6], Ω[, ϕ, Δ])\n\nCreate a rydberg hamiltonian\n\n fracCr_i - r_j^6 n_i n_j + fracΩ2 σ_x - Δ σ_n\n\nshorthand for\n\nRydInteract(C, atoms) + SumOfXPhase(length(atoms), Ω, ϕ) - SumOfN(length(atoms), Δ)\n\nArguments\n\natoms: a collection of atom positions.\n\nKeyword Arguments\n\nC: optional, default unit is MHz*µm^6, interation parameter,   see also RydInteract.\nΩ: optional, default unit is MHz, Rabi frequencies, divided by 2, see also SumOfX.\nΔ: optional, default unit is MHz, detuning parameter, see SumOfN.\nϕ: optional, does not have unit, the phase, see SumOfXPhase.\n\ntips: Tips\nThe rabi frequencies are divided by two in the Rydberg hamiltonian unlike directly constructing via SumOfX or SumOfXPhase.\n\ntips: Tips\nThe parameters of Hamiltonian have their own default units to match hardware, one can use Unitful.jl to specify their units explicitly. If the units are specified explicitly, they will be converted to default units automatically.\n\nExample\n\njulia> using Bloqade\n\njulia> atoms = [(1, ), (2, ), (3, ), (4, )]\n4-element Vector{Tuple{Int64}}:\n (1,)\n (2,)\n (3,)\n (4,)\n\njulia> rydberg_h(atoms)\n∑ 5.42e6/|r_i-r_j|^6 n_i n_j\n\njulia> rydberg_h(atoms; Ω=0.1)\nnqubits: 4\n+\n├─ ∑ 5.42e6/|r_i-r_j|^6 n_i n_j\n└─ 0.05 ⋅ ∑ σ^x_i\n\n\n\n\n\n","category":"function"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Except the standard operators from Yao, the following operators are also supported by Bloqade:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"RydInteract\nSumOfX\nSumOfXPhase\nSumOfZ\nSumOfN\nXPhase","category":"page"},{"location":"hamiltonians/#BloqadeExpr.RydInteract","page":"Hamiltonians","title":"BloqadeExpr.RydInteract","text":"struct RydInteract{D} <: AbstractTerm{D}\nRydInteract(;atoms, C=2π * 862690MHz⋅μm^6)\n\nType for Rydberg interactive term.\n\nExpression\n\nsum_i j fracCr_i - r_j^6 n_i n_j\n\nKeyword Arguments\n\natoms: a list of atom positions, must be type RydAtom, default unit is μm.\nC: the interaction strength, default unit is MHz⋅μm^6. default value is 2π * 862690 * MHz*µm^6.\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/#BloqadeExpr.SumOfX","page":"Hamiltonians","title":"BloqadeExpr.SumOfX","text":"struct SumOfX <: AbstractTerm{2}\nSumOfX(nsites, Ω)\n\nTerm for sum of X operators.\n\nThe following two expressions are equivalent\n\njulia> SumOfX(nsites=5)\n∑ σ^x_i\n\njulia> sum([X for _ in 1:5])\nnqudits: 1\n+\n├─ X\n├─ X\n├─ X\n├─ X\n└─ X\n\nExpression\n\nsum_i Ω σ^x_i\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/#BloqadeExpr.SumOfXPhase","page":"Hamiltonians","title":"BloqadeExpr.SumOfXPhase","text":"struct SumOfXPhase <: AbstractTerm{2}\nSumOfXPhase(;nsites, Ω=1, ϕ)\n\nSum of XPhase operators.\n\nThe following two expressions are equivalent\n\njulia> SumOfXPhase(nsites=5, ϕ=0.1)\n1.0 ⋅ ∑ e^{0.1 ⋅ im} |0⟩⟨1| + e^{-0.1 ⋅ im} |1⟩⟨0|\n\njulia> sum([XPhase(0.1) for _ in 1:5])\nnqudits: 1\n+\n├─ XPhase(0.1)\n├─ XPhase(0.1)\n├─ XPhase(0.1)\n├─ XPhase(0.1)\n└─ XPhase(0.1)\n\nBut may provide extra speed up.\n\nExpression\n\nsum_i Ω  (e^ϕ  im 01 + e^-ϕ  im 10)\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/#BloqadeExpr.SumOfZ","page":"Hamiltonians","title":"BloqadeExpr.SumOfZ","text":"struct SumOfZ <: AbstractTerm{2}\nSumOfZ(;nsites, Δ=1)\n\nSum of Pauli Z operators.\n\nThe following two expression are equivalent\n\njulia> SumOfZ(nsites=5)\n∑ σ^z_i\n\njulia> sum([Z for _ in 1:5])\nnqudits: 1\n+\n├─ Z\n├─ Z\n├─ Z\n├─ Z\n└─ Z\n\nExpression\n\nsum_i Δ  σ^z_i\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/#BloqadeExpr.SumOfN","page":"Hamiltonians","title":"BloqadeExpr.SumOfN","text":"struct SumOfN <: AbstractTerm{2}\nSumOfN(;nsites[, Δ=1])\n\nSum of N operators. \n\nThe following two expression are equivalent\n\njulia> SumOfN(nsites=5)\n∑ n_i\n\njulia> sum([Op.n for _ in 1:5])\nnqudits: 1\n+\n├─ P1\n├─ P1\n├─ P1\n├─ P1\n└─ P1\n\nBut may provide extra speed up.\n\nExpression\n\nsum_i Δ  n_i\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/#BloqadeExpr.XPhase","page":"Hamiltonians","title":"BloqadeExpr.XPhase","text":"XPhase{T} <: PrimitiveBlock{2}\n\nXPhase operator for 2-level Rydberg system.\n\ne^ϕ  im 01 + e^-ϕ  im 10\n\n\n\n\n\n","category":"type"},{"location":"subspace/#subspace","page":"Working with Subspace","title":"Working with Subspace","text":"","category":"section"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"Due to the strong Rydberg interactions, only one Rydberg excitation is allowed if the atoms are close to each other.  We typically take this as the blockade radius, R_b, which is the  distance for which the Rydberg interaction is the same as the Rabi frequency, Omega (see Rydberg Blockade). This is the so-called blockade constraint. ","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"In Bloqade, we can take advantage of this effect by allowing users to run emulation in a truncated subspace, i.e., by throwing out states that violate the blockade constraint.  This can help accelerate the simulation and enables simulation for a larger system size.  In this section, we will show how to create a blockade subspace, create registers in the subspace,  obtain the Hamiltonian matrix in the subspace, and run emulation in the subspace.","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"note: Note\nNote that the blockade radius R_b is the distance for which the Rydberg interaction is the same as the Rabi frequency, Omega.  For accurate simulation, however, it's not recommended to throw away the states that's close to the blockade radius. In other words, it's safer to set the subspace radius R_s to be smaller than R_b, where we throw away the blockade violated states when the atoms are within R_s.  For example, if we set R_s = 12 * R_b, we will be throwing away states that have interaction energies at least 2^6*Omega, which will be a good approximation.  See the Rydberg Blockade page for recommendations on how to set R_b, R_s, and the atom lattice separation, a.","category":"page"},{"location":"subspace/#Create-the-Blockade-Subspace","page":"Working with Subspace","title":"Create the Blockade Subspace","text":"","category":"section"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"One can create a blockade subspace via the blockade_subspace method if we know the atomic positions: ","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"blockade_subspace","category":"page"},{"location":"subspace/#BloqadeMIS.blockade_subspace","page":"Working with Subspace","title":"BloqadeMIS.blockade_subspace","text":"blockade_subspace(atoms[, radius=1.0])\n\nCreate a blockade approximation subspace from given atom positions and radius.\n\n\n\n\n\n","category":"function"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"For example, we can construct a blockade subspace of a square lattice using the code below:","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"using Bloqade\natoms = generate_sites(SquareLattice(), 3, 3, scale=5.1)\nspace = blockade_subspace(atoms, 5.2)","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"We first created a 3*3 square lattice with nearest neighbor atoms seperated by 51 μm.  Then we have created a blockade subpace with the subspace radius, R_s, being 52 μm.  This means that if two atoms have a separation distance that is smaller than (or equal to) 52 μm,  then the blockade subspace does not contain states where both of them being in the Rydberg states. For the dictionary shown, the left is the new index of the states in the blockade subspace;  in this case, there are 63 allowed states, which is much smaller than the full Hilbert space size 512. The vectors on the right correspond to the base-10 representations of the states in bitstrings. ","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"Here space is of the type Subspace:","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"Subspace","category":"page"},{"location":"subspace/#BloqadeExpr.Subspace","page":"Working with Subspace","title":"BloqadeExpr.Subspace","text":"Subspace{S <: AbstractVector} <: AbstractSpace\n\nA Dict-like object stores the mapping between subspace and full space.\n\n\n\n\n\n","category":"type"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"Other than using atomic positions and the subspace radius, we can also use a graph to create a subspace. In this case, the subspace  corresponds to the space composed by the independent sets of this graph. Bloqade has an explicit function for this, by using a graph as  an input, and produces the subspace as the output. Here is an example code:","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"using Graphs\n\ng = SimpleGraph(5)\nedge_set = [(1,2), (1, 4), (2, 5), (3, 4)]\nfor (i,j) in edge_set\n    add_edge!(g, i, j)\nend \nspace = independent_set_subspace(g)","category":"page"},{"location":"subspace/#Create-Registers-in-the-Subspace","page":"Working with Subspace","title":"Create Registers in the Subspace","text":"","category":"section"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"One can create a register in the subspace by feeding the space object instead of an integer for the common register interfaces, e.g.:","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"zero_state(space)\nproduct_state(bit\"000_000_001\", space)","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"Alternatively, if you have an existing state stored as a subtype of AbstractVector, you can also create the register using the constructor:","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"state = rand(ComplexF64, length(space))\nreg = SubspaceArrayReg(state, space)","category":"page"},{"location":"subspace/#Obtain-the-Hamiltonian-Matrix-in-the-Subspace","page":"Working with Subspace","title":"Obtain the Hamiltonian Matrix in the Subspace","text":"","category":"section"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"The matrix projected in the subspace of a given Hamiltonian can be obtained via mat as well, e.g.:","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"atoms = generate_sites(SquareLattice(), 3, 3, scale=5.1);\nspace = blockade_subspace(atoms, 5.2);\nh1 = rydberg_h(atoms; Δ=2.0*2π, Ω=1.0*2π)\nmat(h1, space)","category":"page"},{"location":"subspace/#Other-Operations-in-the-Subspace","page":"Working with Subspace","title":"Other Operations in the Subspace","text":"","category":"section"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"All other operations in the subspace are the same as the fullspace case.  For example, to run an emulation in the subspace, one just need to use the subspace register SubspaceArrayReg instead of the fullspace register ArrayReg. The rest of the code are the same:","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"reg = zero_state(space)\nprob = SchrodingerProblem(reg, 1.0, h1)\nemulate!(prob)\nstatevec(reg)","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"Measurements on the subspace register is the same as that in the full space. ","category":"page"},{"location":"subspace/#Create-Constrained-Local-Hamiltonians-in-the-Subspace","page":"Working with Subspace","title":"Create Constrained Local Hamiltonians in the Subspace","text":"","category":"section"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"Although we are able to emulate our Hamiltonian problem in the projected subspace, the long-range tail of   the Rydberg interactions will be present in the subspace Hamiltonian. In certain cases, you may not want the long-range tail by only simulating a constrained short-range Hamiltonian, e.g. the PXP model. In this case, we can use Bloqade to easily deal with such problems for an arbitrary graph in an arbitrary dimension. ","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"Let us take the PXP model in 1D as an example. We first create a 1D chain and then generate a subspace by projecting out states that have nearest-neighbor interactions. ","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"atoms = generate_sites(ChainLattice(), 10, scale=5.1)\nspace = blockade_subspace(atoms, 5.2)\nregister = product_state(bit\"0101010101\", space)\nh = 2π * 4.0 * SumOfX(length(atoms)) - 2π * 1.0 * SumOfN(length(atoms))\nprob = SchrodingerProblem(register, 0.2, h)\nemulate!(prob)","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"After creating the subspace, we have built a Hamiltonian by explicitly summing up the Rabi frequency term  and the detuning term by using SumOfX and SumOfN respectively.  In this way, we have created a local constraint Hamiltonian (without the long-range interaction tail). Futhermore, if we want to emulate  quantum dynamics under this Hamiltonian, we just need to create a subspace register and emulate the system under the created Hamiltonian.","category":"page"},{"location":"mis/#mis","page":"Maximum Independent Set","title":"Maximum Independent Set","text":"","category":"section"},{"location":"mis/","page":"Maximum Independent Set","title":"Maximum Independent Set","text":"Rydberg Blockade is one of the most important properties of neutral-atom quantum computing based on Rydberg states.  It naturally encodes the independent set constraint.  More specifically, Rydberg blockade implies that two atoms cannot be both excited to the Rydberg state rrangle if they are close to each other,  whereas independent set constraint means two vertices cannot be both in the independent set when they are connected by an edge. Thus, one can consider atoms in the Rydberg state as vertices in an independent set. See the proposal in H. Pichler, et al. for more details. ","category":"page"},{"location":"mis/","page":"Maximum Independent Set","title":"Maximum Independent Set","text":"In particular, one can use the ground state of the Rydberg Hamiltonian to encode the maximum independent set problem,  which is to find the largest independent set of a given graph.  For a particular subclass of geometric graphs, the so-called unit disk graphs,  the Rydberg Hamiltonian can encode the solution without any overhead in the number of qubits.  In fact, an experimental demonstration of quantum optimization has been realized in solving the maximum independent set problem up to 289 qubits in S. Ebadi, et al..","category":"page"},{"location":"mis/","page":"Maximum Independent Set","title":"Maximum Independent Set","text":"In Bloqade, we provide several functions to support the simulation of solving independent set problems on neutral-atom quantum computers. We list them here in this section.","category":"page"},{"location":"mis/#The-Maximum-Independent-Set-Problem","page":"Maximum Independent Set","title":"The Maximum Independent Set Problem","text":"","category":"section"},{"location":"mis/","page":"Maximum Independent Set","title":"Maximum Independent Set","text":"In graph theory, an independent set is a set of vertices in a graph such that no two of which are connected by an edge. The problem of finding maximum independent sets (MIS) is NP-hard, i.e., it is unlikely to be solved in a time polynomial to the problem size. However, for a graph with a small to intermediate size, various solution space properties, including finding the MIS size and enumerating all MISs, can be computed using the package GenericTensorNetworks; please also refer to the related manual pages the independent set problem and the maximal independent set problem.","category":"page"},{"location":"mis/","page":"Maximum Independent Set","title":"Maximum Independent Set","text":"A tutorial on how to solve the MIS problem using Bloqade is detailed in the MIS tutorial page.","category":"page"},{"location":"mis/","page":"Maximum Independent Set","title":"Maximum Independent Set","text":"In the following, we list the APIs in the module BloqadeMIS, many of which support the simulation of variational quantum algorithms for solving the MIS problem.","category":"page"},{"location":"mis/#References","page":"Maximum Independent Set","title":"References","text":"","category":"section"},{"location":"mis/","page":"Maximum Independent Set","title":"Maximum Independent Set","text":"Modules = [BloqadeMIS]","category":"page"},{"location":"mis/#BloqadeMIS.add_random_vertices","page":"Maximum Independent Set","title":"BloqadeMIS.add_random_vertices","text":"add_random_vertices([rng=GLOBAL_RNG], config::AbstractVector, graph::AbstractGraph, ntrials::Int = 10)\n\nAdd vertices randomly to given configuration for ntrials times and pick the one that has largest count_vertices.\n\nArguments\n\nrng: optional, Random Number Generator.\nconfig: configuration to tweak.\ngraph: problem graph.\nntrials: number of trials to use, default is 10.\n\n\n\n\n\n","category":"function"},{"location":"mis/#BloqadeMIS.anyone-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"Maximum Independent Set","title":"BloqadeMIS.anyone","text":"anyone(index::Integer, mask::Integer) -> Bool\n\nReturn true if any masked position of index is 1.\n\nExample\n\ntrue if any masked positions is 1.\n\njulia> anyone(0b1011, 0b1001)\ntrue\njulia> anyone(0b1011, 0b1100)\ntrue\njulia> anyone(0b1011, 0b0100)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.blockade_subspace","page":"Maximum Independent Set","title":"BloqadeMIS.blockade_subspace","text":"blockade_subspace(atoms[, radius=1.0])\n\nCreate a blockade approximation subspace from given atom positions and radius.\n\n\n\n\n\n","category":"function"},{"location":"mis/#BloqadeMIS.bmask","page":"Maximum Independent Set","title":"BloqadeMIS.bmask","text":"bmask(::Type{T}) where T <: Integer -> zero(T)\nbmask([T::Type], positions::Int...) -> T\nbmask([T::Type], range::UnitRange{Int}) -> T\n\nReturn an integer mask of type T where 1 is the position masked according to positions or range. Directly use T will return an empty mask 0.\n\n\n\n\n\n","category":"function"},{"location":"mis/#BloqadeMIS.count_vertices-Tuple{Integer}","page":"Maximum Independent Set","title":"BloqadeMIS.count_vertices","text":"count_vertices(config::Integer)\n\ncounter the number of vertices in a spin configuration.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.create_subspace_from_mis-Union{Tuple{T}, Tuple{Type{T}, Int64, AbstractVector}} where T","page":"Maximum Independent Set","title":"BloqadeMIS.create_subspace_from_mis","text":"create_subspace_from_mis(T, n::Int, mis::AbstractVector)\n\nCreate Subspace from given list of maximal cliques/maximal independent set.\n\nArguments\n\nn: number of vertices of the graph.\nmis: the list of maximal independent set.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.exact_solve_mis-Tuple{Graphs.AbstractGraph}","page":"Maximum Independent Set","title":"BloqadeMIS.exact_solve_mis","text":"exact_solve_mis(g::AbstractGraph)\n\nReturn the exact MIS size of a graph g.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.gibbs_loss-Tuple{Any, Real}","page":"Maximum Independent Set","title":"BloqadeMIS.gibbs_loss","text":"gibbs_loss([f], reg_or_samples, α::Real)\n\nThe Gibbs loss for maximum independent set defined as\n\nL = -1α log(langle ψexp(α sum(n))ψrangle)\n\nwhere n is the vertex set size.\n\nArguments\n\nf: optional, postprocessing callback function f(config) -> config.   The input config is an integer of type Int, the output   config can be a type supports count_vertices   e.g, an AbstractVector or an Integer.\nreg_or_samples can be a register (Yao.ArrayReg or SubspaceArrayReg)   or a list of measurement result (config) in AbstractVector.\nα::Real: the parameter of Gibbs loss.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.independent_set_probabilities","page":"Maximum Independent Set","title":"BloqadeMIS.independent_set_probabilities","text":"independent_set_probabilities([f], reg::YaoAPI.AbstractRegister, graph_or_mis)\n\nCalculate the probabilities of independent sets with given postprocessing function f(config) -> config. The default postprocessing function f will only reduce all configurations to independent set.\n\nArguments\n\nf: optional, postprocessing function, default is to_independent_set.\nreg: required, the register object.\ngraph_or_mis: a problem graph or the MIS size of the problem   graph (can be calculated via exact_solve_mis).\n\n\n\n\n\n","category":"function"},{"location":"mis/#BloqadeMIS.independent_set_subspace-Union{Tuple{T}, Tuple{Type{T}, Graphs.SimpleGraphs.SimpleGraph}} where T","page":"Maximum Independent Set","title":"BloqadeMIS.independent_set_subspace","text":"independent_set_subspace([T, ]graph)\n\nCreate a subspace from given graph's maximal independent set.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.is_independent_set-Tuple{Any, Graphs.AbstractGraph}","page":"Maximum Independent Set","title":"BloqadeMIS.is_independent_set","text":"is_independent_set(config, graph::AbstractGraph)\n\nReturn true if config is an independent set of graph. config can be a BitStr, a vector, or any iterable.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.ismatch-Union{Tuple{T}, Tuple{T, T, T}} where T<:Integer","page":"Maximum Independent Set","title":"BloqadeMIS.ismatch","text":"ismatch(index::Integer, mask::Integer, target::Integer) -> Bool\n\nReturn true if bits at positions masked by mask equal to 1 are equal to target.\n\nExample\n\njulia> n = 0b11001; mask = 0b10100; target = 0b10000;\n\njulia> ismatch(n, mask, target)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.mis_postprocessing-Tuple{Any, Graphs.AbstractGraph}","page":"Maximum Independent Set","title":"BloqadeMIS.mis_postprocessing","text":"mis_postprocessing(config, graph::AbstractGraph; ntrials::Int=10)\n\nThe postprocessing protocal used in Harvard experiment for finding MISs: arxiv:2202.09372, which includes a combination of to_independent_set and add_random_vertices.\n\nArguments\n\nconfig: configuration to postprocess.\ngraph: the problem graph.\n\nKeyword Arguments\n\nntrials: number of trials to use.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.mis_postprocessing-Tuple{Graphs.AbstractGraph}","page":"Maximum Independent Set","title":"BloqadeMIS.mis_postprocessing","text":"mis_postprocessing(graph::AbstractGraph; ntrials::Int = 10)\n\nCurried version of mis_postprocessing.\n\nExample\n\nto calculate rydberg_density_sum loss with postprocessing used in Harvard experiment: arxiv:2202.09372.\n\nrydberg_density_sum(mis_postprocessing(graph), reg)\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.num_mis_violation-Tuple{Any, Graphs.AbstractGraph, Int64}","page":"Maximum Independent Set","title":"BloqadeMIS.num_mis_violation","text":"num_mis_violation(config, graph::AbstractGraph, i::Int)\n\nCalculate the number of MIS violations for i-th vertex in graph and configuration config. The config should be a subtype of AbstractVector.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.rydberg_density_sum","page":"Maximum Independent Set","title":"BloqadeMIS.rydberg_density_sum","text":"rydberg_density_sum([f], reg_or_samples)\n\nSum of rydberg density.\n\nArguments\n\nf: optional, postprocessing callback function f(config) -> config.   The input config is an integer of type Int, the output   config can be a type supports count_vertices   e.g, an AbstractVector or an Integer.\nreg_or_samples can be a register (Yao.ArrayReg or SubspaceArrayReg)   or a list of measurement result (config) in AbstractVector.\n\nExample\n\nTo implement the postprocessing protocal in MIS experiment:\n\ncalculating rydberg_density_sum by first reducing the configuration\n\nto independent set using to_independent_set\n\nrandomly adding vertices then pick the largest count_vertices\n\nusing add_random_vertices.\n\nrydberg_density_sum(r) do config\n    config = to_independent_set(config, graph)\n    add_random_vertices(config, graph, 10)\n    return config\nend\n\nOr one can also just add vertice by atom order\n\nrydberg_density_sum(r) do config\n    config = to_independent_set(config, graph)\n    add_vertices!(config, graph)\n    return config\nend\n\n\n\n\n\n","category":"function"},{"location":"mis/#BloqadeMIS.to_independent_set!-Tuple{AbstractVector, Graphs.AbstractGraph}","page":"Maximum Independent Set","title":"BloqadeMIS.to_independent_set!","text":"to_independent_set!(config::AbstractVector, graph::AbstractGraph)\n\nEliminate vertices in config so that remaining vertices do not have connected edges. This algorithm is a naive vertex elimination that does not nesesarily give the maximum possible vertex set.\n\n# run the following code in Atom/VSCode\natoms = [(0.0, 1.0), (1.0, 0.), (2.0, 0.0), (1.0, 1.0), (1.0, 2.0), (2.0, 2.0)]\ngraph = unit_disk_graph(atoms, 1.5)\n\nconfig = [1, 1, 1, 0, 1, 1]\nviz_config(atoms, graph, config)\n\nto_independent_set!(config, graph)\nviz_config(atoms, graph, config)\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.to_independent_set-Tuple{Integer, Graphs.AbstractGraph}","page":"Maximum Independent Set","title":"BloqadeMIS.to_independent_set","text":"to_independent_set(config::Integer, graph::AbstractGraph)\n\nEliminate vertices in config so that remaining vertices do not have connected edges without changing the original config, see also to_independent_set!.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.unit_disk_graph","page":"Maximum Independent Set","title":"BloqadeMIS.unit_disk_graph","text":"unit_disk_graph(atoms::AbstractVector, radius=1)\n\nCreate a unit disk graph from atom positions atoms. It returns a Graphs.SimpleGraph instance.\n\natoms is vector of atoms positions.\nradius is the unit in the unit disk graph definition.\n\n\n\n\n\n","category":"function"},{"location":"lattices/#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"We can use Bloqade to simulate the quantum evolution of information stored in neutral atoms. Present-day neutral-atom hardware permits the arrangement of atoms in a regular lattice structure and even in nearly arbitrary geometries in 1D, 2D, and 3D. This makes neutral atom platform a natural playground for quantum simulation of statistical models and quantum matters. With Bloqade, we support several built-in lattice structures and also allow the users to specify atom positions by inputting coordinates. Please refer to the Rydberg Blockade page for recommendations on how to set the lattice constants for different lattices.","category":"page"},{"location":"lattices/#Types-of-Lattices","page":"Lattices","title":"Types of Lattices","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"A crystal lattice is completely determined by a set of Bravais lattice vectors (in unit of μm) plus the locations of atoms within a unit cell. A Bravais lattice is an infinite array of discrete points generated by a set of discrete translation operations described by","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"mathbfR = n_1 mathbfa_1 + n_2 mathbfa_2 + ldots + n_d mathbfa_d","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"where d is the dimension of space, n_1 ldots n_d in Z are integers. The unit cell of a Bravais lattice is defined by specifying its lattice vectors (mathbfa_1 mathbfa_2 ldots mathbfa_d). To create a simple lattice, we first specify the locations of the atoms within a unit cell and then specify the lattice vectors of the Bravais lattice. For example, for a triangular lattice, we need just one site (atom) at the location (0.0, 0.0) in the unit cell and then lattice vectors (1.0, 0.0) and (0.5, 0.5*sqrt(3)):","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"using Bloqade\ntriangular = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))], [(0.0, 0.0)])","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"For composite lattices, one should provide multiple sites as the second argument to specify their locations in a unit cell. For example, the honeycomb lattice can be defined by:","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"honeycomb = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))],\n    [(0.0, 0.0), (0.5, 0.5/sqrt(3))])","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"We provide a few shorthands for several useful lattices, including the ChainLattice, SquareLattice, HoneycombLattice, TriangularLattice, LiebLattice, and KagomeLattice shown below.  One can use lattice_vectors and lattice_sites to access the lattice vectors and site locations in a unit cell as described in the above section.","category":"page"},{"location":"lattices/#[ChainLattice](@ref)","page":"Lattices","title":"ChainLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"using Bloqade\nchain = ChainLattice()","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"# to make the plot look good in both light and dark backgrounds.\nBloqadeLattices.DEFAULT_BACKGROUND_COLOR[] = \"#FFFFFF\"\n\n# to show the lattice vectors (rescaled a bit to shrink the head).\nunitvectors(lattice::AbstractLattice{2}) = [((0.0, 0.0), v) for v in lattice_vectors(lattice)]\n\nBloqade.plot(generate_sites(chain, 10); vectors=[((0.0, 0.0), (0.9, 0.0))], bond_linewidth=0.015)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"note: Note\nYou can see the above visualization in one of the following editorsa VSCode editor,\na Jupyter notebook,\nor a Pluto notebook,but not in a Julia REPL which does not have a graphical display.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_vectors(chain)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_sites(chain)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Once we have defined certain lattice shapes (which have fixed lattice vectors and site positions in the unit cell), we can generate the atom positons by  specifying the number of atoms and the scale size of the lattice.  This is done by using the function generate_sites , which will return a AtomList instance containing the coordinates of each atom, e.g.:  ","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"atoms = generate_sites(HoneycombLattice(), 3, 5; scale = 4.5)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"where scale defines the unit distance in the unit μm of the lattice, and 3, 5 specifies the repetitions of unit cells in each lattice vector direction. The default scale is 1 μm.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Here are some examples of other lattices:","category":"page"},{"location":"lattices/#[SquareLattice](@ref)","page":"Lattices","title":"SquareLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"square = SquareLattice()\nBloqade.plot(generate_sites(square, 10, 10); vectors=unitvectors(square), bond_linewidth=0.015)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Note that the indices showing on the sites are consistent with the indices of the qubits for performing computation.  In other words, if we want to do measurement or apply operations on individual sites (qubits), we can refer to the numbering on the atoms for convenience.  For more details on how to generate Hamiltonians by using the lattice as an argument, please see the section Hamiltonians.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_vectors(square)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_sites(square)","category":"page"},{"location":"lattices/#[HoneycombLattice](@ref)","page":"Lattices","title":"HoneycombLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"honeycomb = HoneycombLattice()\nBloqade.plot(generate_sites(honeycomb, 5, 5); vectors=unitvectors(honeycomb), bond_linewidth=0.015)","category":"page"},{"location":"lattices/#[TriangularLattice](@ref)","page":"Lattices","title":"TriangularLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"triangular = TriangularLattice()\nBloqade.plot(generate_sites(triangular, 8, 8); vectors=unitvectors(triangular), bond_linewidth=0.015)","category":"page"},{"location":"lattices/#[LiebLattice](@ref)","page":"Lattices","title":"LiebLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lieb = LiebLattice()\nBloqade.plot(generate_sites(lieb, 5, 5); vectors=unitvectors(lieb), bond_linewidth=0.015)","category":"page"},{"location":"lattices/#[KagomeLattice](@ref)","page":"Lattices","title":"KagomeLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"kagome = KagomeLattice()\nBloqade.plot(generate_sites(kagome, 5, 5); vectors=unitvectors(kagome), bond_linewidth=0.015)","category":"page"},{"location":"lattices/#Sort-Sites-and-Other-Operations-on-Lattices","page":"Lattices","title":"Sort Sites and Other Operations on Lattices","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"We also support different operations on the generated lattices. For instance,  one can apply some predefined filters, e.g. rescale_axes, clip_axes, offset_axes, to manipulate atom locations:","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"atoms = generate_sites(HoneycombLattice(), 3, 5; scale = 4.5)\nrescale_axes(atoms, 0.8)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"where the above operation rescales the coordinates of the original sites by a factor of 0.8. ","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"The code below restricts the atoms sitting in the window (0.0, 5.0), (0.0, 6.0) and throw away those outside this area: ","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"clip_axes(atoms, (0.0, 5.0), (0.0, 6.0))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Furthermore, we can shift the origin of the atoms by some vector (5.0, 5.0) simply by typing the code:","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"offset_axes(atoms, 5.0, 5.0)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"To sort the atoms by their x-coordinates, one can convert these locations to a MaskedGrid representation of the atoms:","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"atoms_in_grid = make_grid(atoms)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Then one can get the sorted atoms by typing:","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"sorted_atoms = collect_atoms(atoms_in_grid)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Note that the sorting has changed the index numbering of the atoms. ","category":"page"},{"location":"lattices/#User-Defined-Arbitrary-Geometries","page":"Lattices","title":"User-Defined Arbitrary Geometries","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"One can also generate atoms located at arbitrary positions by directly inputting the coordinates of the atoms:","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"atom_coordinate = AtomList([(0.0, 0.0), (0, 5), (0, 8), (5, 2), (6, 7), (9, 6)])","category":"page"},{"location":"lattices/#Query-Neighbors","page":"Lattices","title":"Query Neighbors","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"One can use make_kdtree to generate a k-d tree data type for the efficient querying of neighborhoods in a low-dimensional space.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"tree = make_kdtree(sorted_atoms)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"The return value is a KDTree instance, which is defined in the package NearestNeigbors. One can use it to query the neighbors of an atom: e.g. one can find the 20 nearest neighbors of the 5-th site by typing:","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"neighbors = grouped_nearest(tree, 5, 20)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"The return value is a DistanceGroup instance, and the indices of the second nearest neighbors are:","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"neighbors[2]","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"One can select and display these atoms with the correct labeling by typing:","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Bloqade.plot(sorted_atoms[neighbors[2]]; texts=string.(neighbors[2]))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"It shows the correct second nearest neigbors of the site 5. One can check the docstring of Bloqade.plot to know more about how to customize lattice visualization.","category":"page"},{"location":"lattices/#References","page":"Lattices","title":"References","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Modules = [BloqadeLattices]","category":"page"},{"location":"lattices/#BloqadeLattices.AtomList","page":"Lattices","title":"BloqadeLattices.AtomList","text":"AtomList{D, T} <: AbstractVector{NTuple{D, T}}\nAtomList(atoms::Vector{<:NTuple})\n\nA list of atoms in D dimensional space.\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.ByDensity-Tuple{Any}","page":"Lattices","title":"BloqadeLattices.ByDensity","text":"ByDensity(values; colormap=\"Grays\", vmin=minimum(values), vmax=maximum(values))\n\nFor specifying the colors for density plots, where values are densities.\n\nKeyword arguments\n\ncolormap is a string for specifying the color map, check the documentation of [Colors] package for the detailed description.\nvmin and vmax are the color range.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.ChainLattice","page":"Lattices","title":"BloqadeLattices.ChainLattice","text":"BloqadeLattices.ChainLattice <: AbstractLattice{1}\nBloqadeLattices.ChainLattice()\n\nBloqadeLattices.ChainLattice is a 1 dimensional lattice with:\n\nLattice vectors = ((1.0,),)\nLattice sites   = ((0.0,),)\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.DistanceGroup","page":"Lattices","title":"BloqadeLattices.DistanceGroup","text":"DistanceGroup\n\nThe vertices grouped by distances. One can use distancegroup[n] to get n-th nearest neighbors.\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.GeneralLattice","page":"Lattices","title":"BloqadeLattices.GeneralLattice","text":"GeneralLattice{D,K,T} <: AbstractLattice{D}\nGeneralLattice(vectors, sites)\n\nThe general lattice type for tiling the space. Type parameter D is the dimension, K is the number of sites in a unit cell and T is the data type for coordinates, e.g. Float64. Input arguments are\n\nvectors is a vector/tuple of D-tuple. Its length is D, it specifies the Bravais lattice vectors.\nsites is a vector/tuple of D-tuple. Its length is K, it specifies the sites inside a Bravais cell.\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.HoneycombLattice","page":"Lattices","title":"BloqadeLattices.HoneycombLattice","text":"BloqadeLattices.HoneycombLattice <: AbstractLattice{2}\nBloqadeLattices.HoneycombLattice()\n\nBloqadeLattices.HoneycombLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))\nLattice sites   = ((0.0, 0.0), (0.5, 0.2886751345948129))\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.KagomeLattice","page":"Lattices","title":"BloqadeLattices.KagomeLattice","text":"BloqadeLattices.KagomeLattice <: AbstractLattice{2}\nBloqadeLattices.KagomeLattice()\n\nBloqadeLattices.KagomeLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))\nLattice sites   = ((0.0, 0.0), (0.25, 0.4330127018922193), (0.75, 0.4330127018922193))\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.LiebLattice","page":"Lattices","title":"BloqadeLattices.LiebLattice","text":"BloqadeLattices.LiebLattice <: AbstractLattice{2}\nBloqadeLattices.LiebLattice()\n\nBloqadeLattices.LiebLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.0, 1.0))\nLattice sites   = ((0.0, 0.0), (0.5, 0.0), (0.0, 0.5))\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.MaskedGrid","page":"Lattices","title":"BloqadeLattices.MaskedGrid","text":"MaskedGrid{T}\nMaskedGrid(xs, ys, mask)\n\nMasked square lattice contains 3 fields, the x-coordinates, y-coordinates and a mask. e.g. MaskedGrid([0.0, 1.0, 3.0], [0.0, 2.0,6.0], Bool[1 0 0; 0 1 1; 0 1 0]) specifies the following lattice:\n\n     y₁   y₂        y₃\n     ↓    ↓         ↓\nx₁ → ●    ⋅         ●\nx₂ → ⋅    ●         ●\n\nx₃ → ⋅    ●         ⋅\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.RectangularLattice","page":"Lattices","title":"BloqadeLattices.RectangularLattice","text":"RectangularLattice <: AbstractLattice{2}\nRectangularLattice(aspect_ratio::Real)\n\nRectangularLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.0, aspect_ratio)\nLattice sites   = ((0.0, 0.0),)\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.SquareLattice","page":"Lattices","title":"BloqadeLattices.SquareLattice","text":"BloqadeLattices.SquareLattice <: AbstractLattice{2}\nBloqadeLattices.SquareLattice()\n\nBloqadeLattices.SquareLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.0, 1.0))\nLattice sites   = ((0.0, 0.0),)\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.TriangularLattice","page":"Lattices","title":"BloqadeLattices.TriangularLattice","text":"BloqadeLattices.TriangularLattice <: AbstractLattice{2}\nBloqadeLattices.TriangularLattice()\n\nBloqadeLattices.TriangularLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))\nLattice sites   = ((0.0, 0.0),)\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.clip_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Vararg{Tuple{T, T}, D}}} where {D, T}","page":"Lattices","title":"BloqadeLattices.clip_axes","text":"clip_axes(sites::AtomList{D, T}, bounds::Vararg{Tuple{T,T},D}) where {D, T}\nclip_axes(bounds...)\n\nRemove sites out of bounds, where bounds is specified by D D-tuples.\n\njulia> sites = AtomList([(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)])\n4-element AtomList{2, Float64}:\n (1.0, 2.0)\n (10.0, 3.0)\n (1.0, 12.0)\n (3.0, 5.0)\n\njulia> clip_axes(sites, (-5.0, 5.0), (-5.0, 5.0))\n2-element AtomList{2, Float64}:\n (1.0, 2.0)\n (3.0, 5.0)\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.collect_atoms-Tuple{MaskedGrid}","page":"Lattices","title":"BloqadeLattices.collect_atoms","text":"collect_atoms(maskedgrid::MaskedGrid)\n\nReturns an list of atoms in the maskedgrid in order.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.dimension-Union{Tuple{AbstractLattice{D}}, Tuple{D}} where D","page":"Lattices","title":"BloqadeLattices.dimension","text":"dimension(lattice)\n\nReturns the space dimension of target lattice. e.g. ChainLattice is a 1D lattice, hence returns 1.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.generate_sites-Union{Tuple{D}, Tuple{AbstractLattice{D}, Vararg{Int64, D}}} where D","page":"Lattices","title":"BloqadeLattices.generate_sites","text":"generate_sites(lattice::AbstractLattice{D}, repeats::Vararg{Int,D}; scale=1.0)\n\nReturns an AtomList instance by tiling the specified lattice. The tiling repeat the sites of the lattice m times along the first dimension, n times along the second dimension, and so on. scale is a real number that re-scales the lattice constant and atom locations.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.grouped_nearest-Tuple{NearestNeighbors.KDTree, Int64, Int64}","page":"Lattices","title":"BloqadeLattices.grouped_nearest","text":"grouped_nearest(tree::KDTree, siteindex::Int, nsites::Int; atol=1e-8)\n\nFind the nsites closest vertices to siteindex, and group them by distance. Difference of the distances smaller than the atol (default is 1e-8) are treated as the same Returns a DistanceGroup instance.\n\njulia> atoms = generate_sites(HoneycombLattice(), 5, 5);\n\njulia> tree = make_kdtree(atoms);\n\njulia> gn = grouped_nearest(tree, 23, 20)\nDistanceGroup([23, 14, 22, 24, 15, 13, 21, 25, 33, 31, 12, 16, 32, 4, 6, 34, 26, 17, 5, 41], [1, 2, 5, 11, 14, 18, 21])\n\njulia> gn[0]  # the 0-th nearest neighbor is defined by vertex itself\n1-element Vector{Int64}:\n 23\n\njulia> gn[1]  # nearest neighbors\n3-element Vector{Int64}:\n 14\n 22\n 24\n\njulia> gn[2]  # second nearest neighbors\n6-element Vector{Int64}:\n 15\n 13\n 21\n 25\n 33\n 31\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.img_atoms-Tuple{AtomList{2}}","page":"Lattices","title":"BloqadeLattices.img_atoms","text":"img_atoms(atoms::AtomList;\n    colors = [DEFAULT_LINE_COLOR[], ...],\n    texts = [\"1\", \"2\", ...],\n    vectors = [],\n    format = :svg,\n    filename = nothing,\n    kwargs...\n    )\n\nPlots atoms with colors specified by colors and texts specified by texts. You will need a VSCode, Pluto notebook or Jupyter notebook to show the image. If you want to write this image to the disk without displaying it in a frontend, please try\n\njulia> img_atoms(generate_sites(SquareLattice(), 5, 5); filename=\"test.png\")\n\nKeyword Arguments\n\ncolors is a vector of colors for nodes\ntexts is a vector of string displayed on nodes\nvectors is a vector of (startloc, endloc) pair to specify a list of arrows.\nformat can be :svg, :pdf or :png\nfilename can be a filename string with suffix .svg, .png or .pdf\n\nExtra Keyword Arguments\n\nbackground_color = DEFAULT_BACKGROUND_COLOR[]\nscale::Float64 = 1 is a multiplicative factor to rescale the atom distance for better visualization\nxpad::Float64 = 2.5 is the padding space in x axis\nypad::Float64 = 1.5 is the padding space in y axis\nunit::Int = 60 is the number of pixel per unit distance\n\naxes\n\naxes_text_color = DEFAULT_TEXT_COLOR[]\naxes_text_fontsize::Float64 = 16.0\naxes_num_of_xticks = 5\naxes_num_of_yticks = 5\naxes_x_offset::Float64 = 0.1\naxes_y_offset::Float64 = 0.06\naxes_unit::String = \"μm\"\n\nnode\n\nnode_text_fontsize::Float64 = 16.0\nnode_text_color = DEFAULT_TEXT_COLOR[]\nnode_stroke_color = DEFAULT_LINE_COLOR[]\nnode_stroke_linewidth = 1\nnode_fill_color = DEFAULT_NODE_COLOR[]\n\nbond\n\nbond_color = DEFAULT_LINE_COLOR[]\nbond_linewidth::Float64 = 1.0\n\nblockade\n\nblockade_radius::Float64=0, atoms within blockade_radius will be connected by edges.\nblockade_style::String = \"none\"\nblockade_stroke_color = DEFAULT_LINE_COLOR[]\nblockade_fill_color = \"transparent\"\nblockade_fill_opacity::Float64 = 0.5\nblockade_stroke_linewidth = 1.0   # in pt\n\narrow\n\narrow_linewidth\narrow_color\narrow_head_length\n\ngrid\n\ngrid_stroke_color=\"#AAAAAA\"\ngrid_stroke_width::Float64=1\ngrid_stroke_style::String=\"dashed\"\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.img_maskedgrid-Tuple{MaskedGrid}","page":"Lattices","title":"BloqadeLattices.img_maskedgrid","text":"img_maskedgrid(maskedgrid::MaskedGrid;\n    colors=[DEFAULT_LINE_COLOR[], ...],\n    texts=[\"1\", \"2\", ...],\n    vectors=[],\n    format=:svg,\n    filename=nothing,\n    kwargs...\n    )\n\nDraw a maskedgrid with colors specified by colors and texts specified by texts. You will need a VSCode, Pluto notebook or Jupyter notebook to show the image.\n\nKeyword Arguments\n\ncolors is a vector of colors for nodes\ntexts is a vector of string displayed on nodes\nvectors is a vector of arrows\nformat can be :svg, :pdf or :png\nfilename can be a filename string with suffix .svg, .png or .pdf\n\nExtra Keyword Arguments\n\nbackground_color = DEFAULT_BACKGROUND_COLOR[]\nscale::Float64 = 1 is a multiplicative factor to rescale the atom distance for better visualization\nxpad::Float64 = 2.5 is the padding space in x axis\nypad::Float64 = 1.5 is the padding space in y axis\nunit::Int = 60 is the number of pixel per unit distance\n\naxes\n\naxes_text_color = DEFAULT_TEXT_COLOR[]\naxes_text_fontsize::Float64 = 16.0\naxes_num_of_xticks = 5\naxes_num_of_yticks = 5\naxes_x_offset::Float64 = 0.1\naxes_y_offset::Float64 = 0.06\naxes_unit::String = \"μm\"\n\nnode\n\nnode_text_fontsize::Float64 = 16.0\nnode_text_color = DEFAULT_TEXT_COLOR[]\nnode_stroke_color = DEFAULT_LINE_COLOR[]\nnode_stroke_linewidth = 1\nnode_fill_color = DEFAULT_NODE_COLOR[]\n\nbond\n\nbond_color = DEFAULT_LINE_COLOR[]\nbond_linewidth::Float64 = 1.0\n\nblockade\n\nblockade_radius::Float64=0, atoms within blockade_radius will be connected by edges.\nblockade_style::String = \"none\"\nblockade_stroke_color = DEFAULT_LINE_COLOR[]\nblockade_fill_color = \"transparent\"\nblockade_fill_opacity::Float64 = 0.5\nblockade_stroke_linewidth = 1.0   # in pt\n\narrow\n\narrow_linewidth\narrow_color\narrow_head_length\n\ngrid\n\ngrid_stroke_color=\"#AAAAAA\"\ngrid_stroke_width::Float64=1\ngrid_stroke_style::String=\"dashed\"\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.lattice_sites-Tuple{GeneralLattice}","page":"Lattices","title":"BloqadeLattices.lattice_sites","text":"lattice_sites(lattice::AbstractLattice)\n\nReturns sites in a Bravais lattice unit cell as a Tuple of D-Tuple, where D is the space dimension.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.lattice_vectors-Tuple{GeneralLattice}","page":"Lattices","title":"BloqadeLattices.lattice_vectors","text":"lattice_vectors(lattice::AbstractLattice)\n\nReturns Bravais lattice vectors as a D-Tuple of D-Tuple, where D is the space dimension.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.make_grid-Union{Tuple{AtomList{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Lattices","title":"BloqadeLattices.make_grid","text":"make_grid(sites::AtomList; atol=...)\n\nCreate a MaskedGrid from the sites. It is required by lattice preparation of Rydberg array. Because the grid will sort the sites by rows, we need atol (default value is 10 time sit data precision) determines up to what level of round off error, two atoms belong to the same row.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.make_kdtree-Union{Tuple{AtomList{D, T}}, Tuple{D}, Tuple{T}} where {T, D}","page":"Lattices","title":"BloqadeLattices.make_kdtree","text":"make_kdtree(atoms::AtomList{D,T}) where {T, D}\n\nReturns a KDTree instance defined in package NearestNeighbors from input atoms.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.offset_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Vararg{T, D}}} where {D, T}","page":"Lattices","title":"BloqadeLattices.offset_axes","text":"offset_axes(sites::AtomList{D, T}, offsets::Vararg{T,D}) where {D, T}\noffset_axes(offsets...)\n\nOffset the sites by distance specified by offsets.\n\njulia> sites = AtomList([(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)])\n4-element AtomList{2, Float64}:\n (1.0, 2.0)\n (10.0, 3.0)\n (1.0, 12.0)\n (3.0, 5.0)\n\njulia> offset_axes(sites, 1.0, 3.0)\n4-element AtomList{2, Float64}:\n (2.0, 5.0)\n (11.0, 6.0)\n (2.0, 15.0)\n (4.0, 8.0)\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.random_dropout-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Real}} where {D, T}","page":"Lattices","title":"BloqadeLattices.random_dropout","text":"random_dropout(sites::AtomList{D, T}, ratio::Real) where {D, T}\nrandom_dropout(ratio)\n\nRandomly drop out ratio * number of sites atoms from sites, where ratio ∈ [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.rescale_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Real}} where {D, T}","page":"Lattices","title":"BloqadeLattices.rescale_axes","text":"rescale_axes(sites::AtomList{D, T}, scale::Real) where {D, T}\nrescale_axes(scale)\n\nRescale the sites by a constant scale.\n\njulia> sites = AtomList([(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)])\n4-element AtomList{2, Float64}:\n (1.0, 2.0)\n (10.0, 3.0)\n (1.0, 12.0)\n (3.0, 5.0)\n\njulia> rescale_axes(sites, 2.0)\n4-element AtomList{2, Float64}:\n (2.0, 4.0)\n (20.0, 6.0)\n (2.0, 24.0)\n (6.0, 10.0)\n\n\n\n\n\n","category":"method"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"CurrentModule = Bloqade","category":"page"},{"location":"waveform/#Waveforms","page":"Waveforms","title":"Waveforms","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Waveforms are essential ingredients for generating the Rydberg Hamiltonian. By controlling the waveforms of Omega, Delta, and phi, one can prepare the ground states of certain target Hamiltonians and study their non-equilibrium dynamics.  Bloqade supports several built-in waveforms and allows the users to specify waveforms by inputting functions. It also supports different operations of waveforms, such as waveform smoothening, composing, and more.","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"The generated waveforms can be directly used to build the time-dependent Hamiltonians. Please see the Hamiltonians section for more details.","category":"page"},{"location":"waveform/#Creating-Waveforms","page":"Waveforms","title":"Creating Waveforms","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"In Bloqade, the waveforms are defined as a Waveform object, which is a composition of a callable object and a real number duration:","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"BloqadeWaveforms.Waveform","category":"page"},{"location":"waveform/#BloqadeWaveforms.Waveform","page":"Waveforms","title":"BloqadeWaveforms.Waveform","text":"struct Waveform\n\nType for waveforms. Waveforms are defined as a function combined with a real number duration.\n\nFields\n\nf: a callable object.\nduration: a real number defines the duration of this waveform; default unit is μs.\n\n\n\n\n\n","category":"type"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Bloqade gives users the flexibility to specify general waveforms by inputting functions. The following code constructs a sinusoidal waveform with a time duration of 2 μs:","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"using Bloqade\nusing PythonCall\nplt = pyimport(\"matplotlib.pyplot\")\nwaveform = Waveform(t->2.2*2π*sin(2π*t), duration = 2);\nBloqade.plot(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"In our documentation, we use the python package matplotlib for plotting.","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Bloqade supports built-in waveforms for convenience (see References below).  For example, the codes below create different waveform shapes with a single line:","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform = piecewise_linear(clocks=[0.0, 0.2, 0.5, 0.8, 1.0], values= 2π* [0.0, 1.5, 3.1, 3.1, 0.0]); \nBloqade.plot(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform = piecewise_constant(clocks=[0.0, 0.2, 0.5, 0.7], values= 2π*[0.0, 1.5, 3.1]);\nBloqade.plot(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform = linear_ramp(duration=0.5, start_value=0.0, stop_value=2π*1.0);\nBloqade.plot(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform =  constant(duration=0.5, value=2π*2.1);\nBloqade.plot(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform = sinusoidal(duration=2, amplitude=2π*2.2); \nBloqade.plot(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"In some cases, users may have their own waveforms specified by a vector of clocks and a vector of signal strengths. To build a waveform from the two vectors, we can directly use the functions piecewise_linear or piecewise_constant, corresponding to different interpolations. ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"clocks = collect(0:1e-1:2);\nvalues1 = 2π*rand(length(clocks));\nwf1 = piecewise_linear(;clocks, values=values1); \nvalues2 = 2π*rand(length(clocks)-1)\nwf2 = piecewise_constant(;clocks, values=values2); \n\nfig, (ax1, ax2) = plt.subplots(figsize=(12, 4), ncols=2)\nBloqade.plot!(ax1, wf1)\nBloqade.plot!(ax2, wf2)\nfig","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"For more advanced interpolation options, please see the JuliaMath/Interpolations package.","category":"page"},{"location":"waveform/#Operations-on-Waveforms","page":"Waveforms","title":"Operations on Waveforms","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Bloqade also supports several operations on the waveforms. ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Waveforms can be sliced using the duration syntax start..stop, e.g.:","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf = 2π*sinusoidal(duration=2.2);\nwf1 = wf[1.1..1.5];\nBloqade.plot(wf1)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Note that time starts from 0.0 again, so the total duration is stop - start.","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Waveforms can be composed together via append:","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf2 = linear_ramp(;start_value=0.0, stop_value=1.1*2π, duration=0.5);\nwaveform = append(wf1, wf2); \nBloqade.plot(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"where the waveform wf2 is appended at the end of wf1. ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Sharp points in waveforms may result in bad performance in practice (e.g. for adiabatically preparing a ground state of a target Hamiltonian). It is sometimes preferred to smoothen the waveform using the moving average methods. One can use the smooth function to create a smoothened waveform from a piecewise linear waveform:","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf = piecewise_linear(clocks=[0.0, 2.0, 3.0, 4.0], values=2π*[0.0, 3.0, 1.1, 2.2]);\nswf = smooth(wf;kernel_radius=0.1);\n\nfig, (ax1, ax2) = plt.subplots(figsize=(12, 4), ncols=2)\nBloqade.plot!(ax1, wf)\nBloqade.plot!(ax2, swf)\nfig","category":"page"},{"location":"waveform/#Waveform-Arithmetics","page":"Waveforms","title":"Waveform Arithmetics","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Bloqade also supports several arithmetics on the waveforms. If two waveforms have the same duration, we can directly add up or subtract the strength of them, simply by using + or -: ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf1 = linear_ramp(;duration=2.2, start_value=0.0, stop_value=1.0*2π);\nwf2 = sinusoidal(duration = 2.2, amplitude = 2.2*2π);\nwf3 = wf1 + wf2; \nwf4 = wf1 - wf2;\n\nfig, (ax1, ax2) = plt.subplots(figsize=(12, 4), ncols=2)\nBloqade.plot!(ax1, wf3)\nBloqade.plot!(ax2, wf4)\nfig\n","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"To increase the strength of a waveform by some factors, we can directly use *:","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf = linear_ramp(;duration=2.2, start_value=0.0, stop_value=1.0*2π);\nwf_t = 3 * wf;\n\nfig, (ax1, ax2) = plt.subplots(figsize=(12, 4), ncols=2)\nBloqade.plot!(ax1, wf)\nBloqade.plot!(ax2, wf_t)\nfig\n","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Such operations can also be broadcasted by using .*:","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf2, wf3 = [2.0, 3.0] .* wf1; \n\nfig, (ax1, ax2) = plt.subplots(figsize=(12, 4), ncols=2)\nBloqade.plot!(ax1, wf2)\nBloqade.plot!(ax2, wf3)\nfig","category":"page"},{"location":"waveform/#References","page":"Waveforms","title":"References","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"piecewise_linear\npiecewise_constant\nlinear_ramp\nconstant\nsinusoidal\nappend\nsmooth\nsmooth(kernel, Xi::Vector, Yi::Vector, kernel_radius::Real)","category":"page"},{"location":"waveform/#BloqadeWaveforms.piecewise_linear","page":"Waveforms","title":"BloqadeWaveforms.piecewise_linear","text":"piecewise_linear(;clocks, values)\n\nCreate a piecewise linear waveform.\n\nKeyword Arguments\n\nclocks::Vector{<:Real}: the list of clocks for the corresponding values.\nvalues::Vector{<:Real}: the list of values at each clock.\n\nExample\n\njulia> piecewise_linear(clocks=[0.0, 2.0, 3.0, 4.0], values=[0.0, 2.0, 2.0, 0.0])\n                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n                2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⡀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀│ \n   value (2π ⋅ MHz) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢧⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀│ \n                  │⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⡀⠀│ \n                  │⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀│ \n                  │⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆│ \n                0 │⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀ \n\n\n\n\n\n","category":"function"},{"location":"waveform/#BloqadeWaveforms.piecewise_constant","page":"Waveforms","title":"BloqadeWaveforms.piecewise_constant","text":"piecewise_constant(;clocks, values, duration=last(clocks))\n\nCreate a piecewise constant waveform.\n\nKeyword Arguments\n\nclocks::Vector{<:Real}: the list of clocks for the corresponding values.\nvalues::Vector{<:Real}: the list of values at each clock.\nduration::Real: the duration of the entire waveform, default is the last clock.\n\nExample\n\njulia> piecewise_constant(clocks=[0.0, 0.2, 0.5], values=[0.0, 1.5, 3.1], duration=1.1)\n                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n                4 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (2π ⋅ MHz) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢠⠒⠒⠒⠒⠒⠚⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                0 │⣀⣀⣀⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2⠀ \n\n\n\n\n\n","category":"function"},{"location":"waveform/#BloqadeWaveforms.linear_ramp","page":"Waveforms","title":"BloqadeWaveforms.linear_ramp","text":"linear_ramp(;duration, start_value, stop_value)\n\nCreate a linear ramp waveform.\n\nKeyword Arguments\n\nduration::Real: duration of the whole waveform.\nstart_value::Real: start value of the linear ramp.\nstop_value::Real: stop value of the linear ramp.\n\nExample\n\njulia> linear_ramp(;duration=2.2, start_value=0.0, stop_value=1.0)\n                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n                1 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (2π ⋅ MHz) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                0 │⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀3⠀ \n\n\n\n\n\n","category":"function"},{"location":"waveform/#BloqadeWaveforms.constant","page":"Waveforms","title":"BloqadeWaveforms.constant","text":"constant(;duration::Real, value::Real)\n\nCreate a constant waveform.\n\nKeyword Arguments\n\nduration::Real: duration of the whole waveform.\nvalue::Real: value of the constant waveform.\n\n\n\n\n\n","category":"function"},{"location":"waveform/#BloqadeWaveforms.sinusoidal","page":"Waveforms","title":"BloqadeWaveforms.sinusoidal","text":"sinusoidal(;duration::Real, amplitude::Real=one(start))\n\nCreate a sinusoidal waveform of the following expression.\n\namplitude * sin(2π*t)\n\nKeyword Arguments\n\nduration: duration of the waveform.\namplitude: amplitude of the sin waveform.\n\n\n\n\n\n","category":"function"},{"location":"waveform/#BloqadeWaveforms.append","page":"Waveforms","title":"BloqadeWaveforms.append","text":"append(wf::Waveform, wfs::Waveform...)\n\nAppend other waveforms to wf on time axis.\n\n\n\n\n\n","category":"function"},{"location":"waveform/#BloqadeWaveforms.smooth","page":"Waveforms","title":"BloqadeWaveforms.smooth","text":"smooth([kernel=Kernel.gaussian], f; edge_pad_size::Int=length(f.clocks))\n\nKernel smoother function for piece-wise linear function/waveform via weighted moving average method.\n\nArguments\n\nkernel: the kernel function, default is Kernels.gaussian.\nf: a Union{PiecewiseLinear, PiecewiseConstant} function or a Waveform{<:Union{PiecewiseLinear, PiecewiseConstant}}.\n\nKeyword Arguments\n\nkernel_radius: radius of the kernel.\nedge_pad_size: the size of edge padding.\n\n\n\n\n\n","category":"function"},{"location":"waveform/#BloqadeWaveforms.smooth-Tuple{Any, Vector, Vector, Real}","page":"Waveforms","title":"BloqadeWaveforms.smooth","text":"smooth(kernel, Xi::Vector, Yi::Vector, kernel_radius::Real)\n\nKernel smoother function via weighted moving average method. See also Kernel Smoother.\n\nTheory\n\nKernel function smoothing is a technique to define a smooth function f mathcalR^p  mathbfR from a set of discrete points by weighted averaging the neighboring points. It can be written as the following equation.\n\nY(X) = sum_i K(X X_i) Y_i  sum_i K(X X_i)\n\nwhere Y(X) is the smooth function by calculating the moving average of known data points X_i and Y_i. K is the kernel function, where K(fracX - X_ih_λ) decrease when the Euclidean norm X - X_i increase, h_λ is a parameter controls the radius of the kernel.\n\nAvailable Kernels\n\nThe following kernel functions are available via the Kernels module:\n\nbiweight; cosine; gaussian; include; logistic; parabolic; sigmoid; triangle; tricube; triweight; uniform\n\nArguments\n\nkernel: a Julia function that has method kernel(t::Real).\nXi::Vector: a list of inputs X_i.\nYi::Vector: a list of outputs Y_i.\nkernel_radius::Real: the radius of the kernel.\n\n\n\n\n\n","category":"method"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"CurrentModule = Bloqade","category":"page"},{"location":"emulation/#emulation","page":"Emulation","title":"Emulation of the Quantum Dynamics","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"After we create the Rydberg Hamiltonian and the register for storing the quantum information, we can  simulate the quantum many-body dynamics. The coherent dynamics of the system is governed by the Schrödinger equation. The emulation interface of Bloqade is designed in a   define-and-run style.  With Bloqade, we have two major types of emulation:","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"ODE-solver based emulation for most of the problems.\nKrylov based emulation for piecewise constant problems or QAOA-like problem.","category":"page"},{"location":"emulation/#Define-the-ODE-Emulation-Problem","page":"Emulation","title":"Define the ODE Emulation Problem","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"ODE solvers are the major backend we use for most of the exact quantum  dynamics simulation. The ODE solvers for Bloqade are powered by the DiffEq.jl package.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"Bloqade provides a special problem type SchrodingerProblem that supports most of the  integrator interface of DiffEq, and most of the solver options. Here, we introduce some common use cases of the integrator and solver options. For more advanced usage of the solvers, please refer to the above link.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"BloqadeODE.SchrodingerProblem","category":"page"},{"location":"emulation/#BloqadeODE.SchrodingerProblem","page":"Emulation","title":"BloqadeODE.SchrodingerProblem","text":"struct SchrodingerProblem\nSchrodingerProblem(reg, tspan, hamiltonian; kw...)\n\nDefine a Schrodinger equation problem that uses ODE solver from OrdinaryDiffEq to solve the dynamics.\n\nArguments\n\nregister: required, the evolution problem register, can be a SubspaceArrayReg or an ArrayReg   from Yao.\ntspan: required, a (start, stop) tuple or a single number t, the single value form t is equivalent   to (zero(t), t).\nhamiltonian: required, the evolution hamiltonian, can be created via rydberg_h.\n\nCommon Keyword Arguments\n\nalgo: optional, algorithm to use, this only works for the emulate! interface.   for solve or integrator interface, one will need to specify the algorithm explicitly.\nprogress: print progress bar or not, this may effect the performance when problem scale is small, default is true.\nprogress_steps: steps to update the progress bar, default is 5.\nreltol: relative tolerance, default is 1e-8.\nabstol: absolute tolerance, default is 1e-8.\n\nFurther References\n\nFor more ODE options, please refer to Common Solver Options. The SchrodingerProblem type supports most of the standard DiffEq problem interface.\n\n\n\n\n\n","category":"type"},{"location":"emulation/#Run-ODE-based-Emulation","page":"Emulation","title":"Run ODE-based Emulation","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"To run the emulation, you need to define the exact evolution and solver you would like to run with via BloqadeODE.SchrodingerProblem, and then feed the corresponding object to the emulate! function:","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"emulate!","category":"page"},{"location":"emulation/#BloqadeExpr.emulate!","page":"Emulation","title":"BloqadeExpr.emulate!","text":"emulate!(prob)\n\nRun emulation of a given problem.\n\n\n\n\n\n","category":"function"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"For example, we can simulate the quantum dynamics of a time-dependent Hamiltonian by the following codes:","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"using Bloqade\natoms = generate_sites(SquareLattice(), 3, 3; scale=5.1);\nclocks = [0.0, 0.1, 0.2, 0.3, 0.4];\nwf = piecewise_constant(;clocks, values=2π*[1.0, 2.0, 3.0, 4.0]);\nh = rydberg_h(atoms; Δ=2π*2.0, Ω=wf); # create the Hamiltonian \nreg = zero_state(length(atoms)); # create fullspace register\nev = SchrodingerProblem(reg, 0.3, h) # the second input is the total time\nemulate!(ev)","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"With emulate!, the quantum state stored in reg has been updated to the state after the time evolution. ","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"If you want to do operations during the real-time evolution, such as measuring observables, you can instead using the integrator interface with for loop and with TimeChoiceIterator on your desired clocks, e.g.:","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"integrator = init(ev, Vern8())\nfor _ in TimeChoiceIterator(integrator, [0.1, 0.25])\n    ev.reg # state at selected time\n    @show measure(ev.reg)[] # measure the state at each time\nend","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"You can use any function on the reg object.  For calculating observables,  please see the Registers and Observables section.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"tip: Tip\nRemember to make sure your operation does not mutate your state so that it won't affect the evolution itself, since the entire time evolution is simulated by mutating the state vector stored in reg. Thus, do not use any function that has a ! in its name on the register info.reg unless you are certain about what you are doing.","category":"page"},{"location":"emulation/#Choose-an-ODE-Solver","page":"Emulation","title":"Choose an ODE Solver","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"One of the most powerful tool of the Julia ecosystem is the DiffEq ecosystem that implements many different solvers. These solvers have different advantages and trade-offs. Since simulating a quantum many-body Schrödinger equation has some special properties compared to a general ODE problem, we will discuss some general heuristics in this section on how to choose a good ODE solver and how to check if your simulation converges. Because many-body Schrödinger equation's stiffness is unknown, we will not be using stiff problem solvers, but instead using non-stiff problem algorithms or auto-switching algorithms.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"For most of the cases, one can use the VCABM solver for a large system simulation. However, this method requires more memory, which can be a bottleneck with GPUs.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"The Vern family is another set of solvers that is good for many-body Schrödinger equation, such as Vern6, Vern7, and Vern8. They also have relatively good memory usage when utilize GPUs.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"For a more detailed list of solvers, please refer to DiffEq:Full list of solvers. For more detailed explanation on ODE solvers, please refer to DiffEq:Recommended Methods.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"If you are familiar with MATLAB or Python, you may wish to compare the same methods that you use in MATLAB or Python; you can find the corresponding solvers in Julia in DiffEq:Translation from MATLAB/Python/R.","category":"page"},{"location":"emulation/#Adaptive-Steps-in-ODE-Solvers","page":"Emulation","title":"Adaptive Steps in ODE Solvers","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"Our ODE solvers use adaptive steps by default. It provides a significant speedup compared to standard fixed-step methods (see our benchmark here). However, if one expects to retrieve the results during the time evolution, e.g., plotting Rydberg densities with the evolution time, fixed-step methods are sometimes  preferred.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"More specifically, when the adaptive steps are turned on, the time steps might be large, but if one is interested in measuring some observables in smaller time steps, then the adaptive step  method will not produce accurate results for the finer time step, but instead output results at the specific adaptive steps.  In this situation, it's better to use fixed-step methods at the clocks where the observables are measured.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"One can use the code below to turn off the adaptive steps when setting up the SchrodingerProblem:","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"atoms = generate_sites(SquareLattice(), 3, 3; scale=5.1);\nh = rydberg_h(atoms; Δ=2π*2.0, Ω= 2π*1.0); # create the Hamiltonian \nreg = zero_state(length(atoms)); \nprob = SchrodingerProblem(reg, 3.0, h, adaptive = false, dt=1e-3);","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"Here, we've specified the fixed time step as dt = 1e-3. If one only expects the final state of the evolution, or the intervals between each chosen clock is much larger than the maximum step size, then adaptive steps are preferred.","category":"page"},{"location":"emulation/#Define-the-Krylov-Emulation-Problem","page":"Emulation","title":"Define the Krylov Emulation Problem","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"The Krylov-based method expects time-independent Hamiltonians. One can define such a time evolution via KrylovEvolution object.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"KrylovEvolution","category":"page"},{"location":"emulation/#BloqadeKrylov.KrylovEvolution","page":"Emulation","title":"BloqadeKrylov.KrylovEvolution","text":"struct KrylovEvolution\nKrylovEvolution(reg::AbstractRegister, clocks, h; kw...)\n\nCreate a KrylovEvolution object that describes a time evolution using Krylov subspace methods.\n\nArguments\n\nreg: a register, should be a subtype of AbstractRegister.\nclocks: the clocks of this time evolution at each step.\nh: a hamiltonian expression.\n\nKeyword Arguments\n\nprogress: show progress bar, default is false.\nprogress_name: progress bar name, default is \"emulating\".\nnormalize_step: normalize the state every normalize_step.\nnormalize_finally: wether normalize the state in the end of evolution, default is true.\ntol: tolerance of the Krylov method, default is 1e-7\n\nExamples\n\nThe following is the simplest way of using KrylovEvolution via emulate!. For more advanced usage, please refer to documentation page Emulation.\n\njulia> using Bloqade\n\njulia> r = zero_state(5)\nArrayReg{2, ComplexF64, Array...}\n    active qudits: 5/5\n    nlevel: 2\n\njulia> atoms = [(i, ) for i in 1:5]\n5-element Vector{Tuple{Int64}}:\n (1,)\n (2,)\n (3,)\n (4,)\n (5,)\n\njulia> h = rydberg_h(atoms; Ω=sin)\nnqubits: 5\n+\n├─ [+] ∑ 5.42e6/|r_i-r_j|^6 n_i n_j\n└─ [+] Ω(t) ⋅ ∑ σ^x_i\n\n\njulia> prob = KrylovEvolution(r, 0.0:1e-2:0.1, h);\n\njulia> emulate!(prob); # run the emulation\n\n\n\n\n\n","category":"type"},{"location":"emulation/#Run-Krylov-based-Emulation","page":"Emulation","title":"Run Krylov-based Emulation","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"We can run the Krylov-based emulation in a similar way using emulate!:","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"emulate!(KrylovEvolution(reg, clocks, h))","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"However, as its name suggests, the Krylov-based emulation is not a standard ODE problem that DiffEq  supports. Thus, it does not support the ODE problem interface, but it's more like a gate-based interface. For example, the object KrylovEvolution is iterable:","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"for (step, reg, duration) in KrylovEvolution(reg, clocks, h)\n    @show step\n    @show reg\n    @show duration\n    println(\"==========\")\nend","category":"page"},{"location":"emulation/#Krylov-vs-ODE-Solvers","page":"Emulation","title":"Krylov vs ODE Solvers","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"The KrylovEvolution uses the Krylov subspace methods to simulate the time evolution of time-independent operators exp(iDelta t_i H), where Delta t_i is the duration of time-independent Hamiltonian H at time t. This method is more efficient when the evolution itself is a discrete evolution, e.g. in QAOA and with piecewise_constant waveforms. As for other cases, ODE solvers are usually more efficient than KrylovEvolution.","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"EditURL = \"https://github.com/QuEraComputing/Bloqade.jl/blob/master/examples/2.adiabatic/main.jl\"","category":"page"},{"location":"tutorials/2.adiabatic/main/#Adiabatic-Evolution","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"","category":"section"},{"location":"tutorials/2.adiabatic/main/#Background","page":"Adiabatic Evolution","title":"Background","text":"","category":"section"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"In this example, we will show how to use Bloqade to prepare ordered ground states in the Rydberg system. The example is based on the experimental works in a 1D system and 2D system. The Rydberg Hamiltonian can be found in the Bloqade page.","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Due to the strong Rydberg interactions, only one Rydberg excitation is allowed within the blockade radius (see Rydberg Blockade). With a positive detuning Δ, more Rydberg excitations are favored (to lower the ground state(s) energy). The interplay of these two mechanisms allows the creation of different ordered states depending on the strength of the blockade radius and the detunings, such as the Z_N ordered states in 1D and the checkerboard phase, the star phase, and a pure quantum phase (the striated phase) in 2D (see the experimental and theory papers).","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Here, we use the Quantum Adiabatic Algorithm (QAA) to prepare these quantum many-body ground states. To do that, we can start with all atoms in the ground state  0 rangle, which is the ground state of the many-body Hamiltonian with a large negative detuning Delta. Then, the Rabi frequency Omega is turned on, and the detuning strength is ramped up from a large negative value to postive values. If this process is slow enough, the quantum state of the system stays close to the ground state of the instantaneous Hamiltonian. At the end of this process, we arrive at a target Hamiltonian, and correspondingly, the prepared state is approximately the ground state for the final Hamiltonian. A quantum phase transition typically occurs during this process and one can probe the phase transition and critical phenomena by simulating and understanding the quantum dynamics.","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Let's start by importing the required libraries:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"using Bloqade\nusing PythonCall\nusing KrylovKit\nusing SparseArrays\n\nplt = pyimport(\"matplotlib.pyplot\");","category":"page"},{"location":"tutorials/2.adiabatic/main/#Ground-State-Properties","page":"Adiabatic Evolution","title":"Ground State Properties","text":"","category":"section"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We start by probing the ground state properties of the Rydberg Hamiltonian in a 1D system. Let's use the 1D chain for simplicity and vary the parameters of the Rydberg Hamiltonian and calculate the corresponding ground state properties. Here, we consider a chain with 9 atoms, where nearby atoms are seperated by a distance of 5.72 μm. Please refer to the Rydberg Blockade page on tips for setting the separation distance for the atoms in preparing different ordered states. One can generate the system as follows using the function generate_sites:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"nsites = 9\natoms = generate_sites(ChainLattice(), nsites, scale = 5.72)","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We fix the Rabi frequency to be Ω = 2π * 4 MHz, and study the ground state as a function of the detuning Δ:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Ω = 2π * 4\nΔ_step = 30\nΔ = LinRange(-2π * 10, 2π * 10, Δ_step);","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"The Rydberg density profile can be computed for each parameter of Delta as:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"density_g = zeros(Δ_step, nsites)\n\nfor ii in 1:Δ_step\n    h_ii = rydberg_h(atoms; Δ = Δ[ii], Ω) # create the Rydberg Hamiltonian\n    h_m = mat(h_ii) # convert the Hamiltonian into a matrix\n    vals, vecs, info = KrylovKit.eigsolve(h_m, 1, :SR) # find the ground state eigenvalue and eigenvector\n    g_state = ArrayReg(vecs[1]) # creates the initial state with all atoms in ``| 0 \\rangle`` state\n\n    for jj in 1:nsites\n        density_g[ii, jj] = rydberg_density(g_state, jj) # measure the density of Rydberg excitations on each site\n    end\nend","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"To compare, we first plot the density profile when Delta= -2π * 10 MHz:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"fig, ax = plt.subplots(figsize = (10, 4))\nax.bar(1:nsites, density_g[1, :])\nax.set_xticks(1:nsites)\nax.set_xlabel(\"Sites\")\nax.set_ylabel(\"Rydberg density\")\nax.set_title(\"Density Profile: 1D Chain, Δ = -2π * 10 MHz\")\nfig","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We can see that the Rydberg densities in this case is close to 0 for all sites. In contrast, for Delta= 2π * 10 MHz, the density shows a clear Z_2 ordered profile:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"fig, ax = plt.subplots(figsize = (10, 4))\nax.bar(1:nsites, density_g[30, :])\nax.set_xticks(1:nsites)\nax.set_xlabel(\"Sites\")\nax.set_ylabel(\"Rydberg density\")\nax.set_title(\"Density Profile: 1D Chain, Δ = 2π * 10 MHz\")\nfig","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"More generally, we can plot an order parameter as a function of Delta to clearly see the onset of phase transition. The order parameter can be defined as the difference of Rydberg densities on even and odd sites.","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"order_para = map(1:Δ_step) do ii\n    return sum(density_g[ii, 1:2:nsites]) - sum(density_g[ii, 2:2:nsites])\nend\n\nfig, ax = plt.subplots(figsize = (10, 4))\nax.plot(Δ / 2π, order_para)\nax.set_xlabel(\"Δ/2π (MHz) \")\nax.set_ylabel(\"Order parameter\")\nfig","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"From the density profile of ground states and the change in the order parameter, we can observe a phase transition with changing Delta. Below, we show that by slowly changing the parameters of the Hamiltonian, we can follow the trajectory of the ground states and adiabatically evolve the atoms from the ground state to the Z_2 ordered state.","category":"page"},{"location":"tutorials/2.adiabatic/main/#Preparation-of-Ordered-States-in-1D","page":"Adiabatic Evolution","title":"Preparation of Ordered States in 1D","text":"","category":"section"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We first specify the adiabatic pulse sequence for Rabi frequency by using the built-in waveform function piecewise_linear:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"total_time = 3.0;\nΩ_max = 2π * 4;\nΩ = piecewise_linear(clocks = [0.0, 0.1, 2.1, 2.2, total_time], values = [0.0, Ω_max, Ω_max, 0, 0]);","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"The detuning sequence can also be created in a similar way:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"U1 = -2π * 10;\nU2 = 2π * 10;\nΔ = piecewise_linear(clocks = [0.0, 0.6, 2.1, total_time], values = [U1, U1, U2, U2]);","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We plot the two waveforms:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"fig, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (12, 4))\nBloqade.plot!(ax1, Ω)\nax1.set_ylabel(\"Ω/2π (MHz)\")\nBloqade.plot!(ax2, Δ)\nax2.set_ylabel(\"Δ/2π (MHz)\")\nfig","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We generate the positions of a 1D atomic chain again:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"nsites = 9\natoms = generate_sites(ChainLattice(), nsites, scale = 5.72)","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Note that we have specified the nearest-neighbor atoms to be seperated by 5.72 μm in order to prepare a Z_2 ordered state. With the waveforms and atomic coordinates specified, the time-dependent Hamiltonian can be simply generated by:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"h = rydberg_h(atoms; Δ, Ω)","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"nqubits: 9\n+\n├─ [+] ∑ 2π ⋅ 8.627e5.0/|r_i-r_j|^6 n_i n_j\n├─ [+] Ω(t) ⋅ ∑ σ^x_i\n└─ [-] Δ(t) ⋅ ∑ n_i\n","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We then specify all atoms to be in the ground state initially, and set up the emulation problem by choosing an ODE solver:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"reg = zero_state(9);\nprob = SchrodingerProblem(reg, total_time, h);\nintegrator = init(prob, Vern8());","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"The default for the integrator is to use adaptive steps. One can use TimeChoiceIterator to specify the time points one would like to measure some observables. Here, we measure the Rydberg density on each site:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"densities = []\nfor _ in TimeChoiceIterator(integrator, 0.0:1e-3:total_time)\n    push!(densities, rydberg_density(reg))\nend\nD = hcat(densities...);","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"and finally plot the time-dependent dynamics of Rydberg density for each site:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"fig, ax = plt.subplots(figsize = (10, 4))\nshw = ax.imshow(real(D), interpolation = \"nearest\", aspect = \"auto\", extent = [0, total_time, 0.5, nsites + 0.5])\nax.set_xlabel(\"time (μs)\")\nax.set_ylabel(\"site\")\nax.set_xticks(0:0.2:total_time)\nax.set_yticks(1:nsites)\nbar = fig.colorbar(shw)\nfig","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We can clearly see that a Z_2 ordered state has been generated by the specified adiabatic pulse sequence. We can also confirm it by plotting the bitstring distribution at the final time step:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"bitstring_hist(reg; nlargest = 20)","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"To prepare the Z_3 or Z_4 states, we can reduce the separation between nearby atoms to 3.57 μm or 2.87 μm respectively. Please refer to the Rydberg Blockade page on how to set the separation distance for preparing the ordered states.","category":"page"},{"location":"tutorials/2.adiabatic/main/#Emulation-in-the-Blockade-Subspace","page":"Adiabatic Evolution","title":"Emulation in the Blockade Subspace","text":"","category":"section"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"In the above example, we have run the fullspace emulation, without truncating the Hilbert space. To speed up the emulation, we can also run it in the blockade subspace, throwing out the configurations of the Hilbert space that violate the blockade constraint. See subspace for more details. This can be done by changing the register to a RydbergReg by feeding a subspace object.","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"The subspace can be found by looking up the independent sets of the graph constructed by a subspace radius; here we choose the subspace radius to be 5.73 μm:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"space = blockade_subspace(atoms, 5.73);","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Then create our register in the subspace:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"reg = zero_state(space)","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"YaoSubspaceArrayReg.SubspaceArrayReg{2, ComplexF64, Vector{ComplexF64}, BloqadeExpr.Subspace{Int64, Vector{Int64}}}(9, ComplexF64[1.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im], BloqadeExpr.Subspace{Int64, Vector{Int64}}(9, Dict(5 => 5, 265 => 62, 325 => 81, 32 => 14, 136 => 40, 145 => 44, 73 => 28, 272 => 64, 164 => 51, 320 => 77, 337 => 86, 64 => 22, 324 => 80, 4 => 4, 168 => 53, 328 => 82, 148 => 46, 256 => 56, 277 => 68, 264 => 61, 41 => 20, 69 => 26, 36 => 17, 68 => 25, 82 => 32, 85 => 34, 130 => 37, 162 => 50, 84 => 33, 321 => 78, 66 => 24, 292 => 72, 34 => 16, 2 => 3, 10 => 8, 18 => 11, 261 => 60, 296 => 74, 336 => 85, 42 => 21, 144 => 43, 132 => 38, 273 => 65, 257 => 57, 169 => 54, 16 => 9, 20 => 12, 81 => 31, 290 => 71, 341 => 89, 160 => 48, 340 => 88, 0 => 1, 289 => 70, 329 => 83, 266 => 63, 9 => 7, 146 => 45, 74 => 29, 138 => 42, 161 => 49, 276 => 67, 128 => 35, 21 => 13, 170 => 55, 129 => 36, 260 => 59, 297 => 75, 133 => 39, 72 => 27, 258 => 58, 8 => 6, 17 => 10, 37 => 18, 1 => 2, 137 => 41, 338 => 87, 288 => 69, 80 => 30, 33 => 15, 274 => 66, 149 => 47, 40 => 19, 65 => 23, 330 => 84, 293 => 73, 165 => 52, 298 => 76, 322 => 79), [0, 1, 2, 4, 5, 8, 9, 10, 16, 17, 18, 20, 21, 32, 33, 34, 36, 37, 40, 41, 42, 64, 65, 66, 68, 69, 72, 73, 74, 80, 81, 82, 84, 85, 128, 129, 130, 132, 133, 136, 137, 138, 144, 145, 146, 148, 149, 160, 161, 162, 164, 165, 168, 169, 170, 256, 257, 258, 260, 261, 264, 265, 266, 272, 273, 274, 276, 277, 288, 289, 290, 292, 293, 296, 297, 298, 320, 321, 322, 324, 325, 328, 329, 330, 336, 337, 338, 340, 341]))","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"The rest of codes will be the same as the fullspace:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"prob = SchrodingerProblem(reg, total_time, h)\nemulate!(prob)\nbitstring_hist(prob.reg; nlargest = 20)","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/2.adiabatic/main/#State-Preparation-in-2D","page":"Adiabatic Evolution","title":"State Preparation in 2D","text":"","category":"section"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Now we show how to prepare a 2D checkerboard phase. Most of codes will be the same as the 1D case, except that we will choose slightly different parameters and specify a square lattice instead of a chain:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"nx, ny = 3, 3\nnsites = nx * ny\natoms = generate_sites(SquareLattice(), nx, ny, scale = 6.7)","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We program and plot the waveforms in the following:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"total_time = 2.9\nΩ_max = 2π * 4.3\nΩ = piecewise_linear(clocks = [0.0, 0.3, 2.6, total_time], values = [0.0, Ω_max, Ω_max, 0]);\n\nU = 2π * 15.0\nΔ = piecewise_linear(clocks = [0.0, 0.3, 2.6, total_time], values = [-U, -U, U, U]);\n\nfig, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (10, 4))\nBloqade.plot!(ax1, Ω)\nax1.set_ylabel(\"Ω/2π (MHz)\")\nBloqade.plot!(ax2, Δ)\nax2.set_ylabel(\"Δ/2π (MHz)\")\nfig","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Then, we use the above waveforms and atom sites to create a Hamiltonian and define a time evolution problem:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"h = rydberg_h(atoms; Δ, Ω)\nreg = zero_state(9);\nprob = SchrodingerProblem(reg, total_time, h);\nintegrator = init(prob, Vern8());","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Again, we can use TimeChoiceIterator to specify the time points for measuring some observables:","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"densities = [];\nfor _ in TimeChoiceIterator(integrator, 0.0:1e-3:total_time)\n    push!(densities, rydberg_density(reg))\nend\nD = hcat(densities...)\n\nfig, ax = plt.subplots(figsize = (10, 4))\nshw = ax.imshow(real(D), interpolation = \"nearest\", aspect = \"auto\", extent = [0, total_time, 0.5, nsites + 0.5])\nax.set_xlabel(\"time (μs)\")\nax.set_ylabel(\"site\")\nax.set_xticks(0:0.2:total_time)\nax.set_yticks(1:nsites)\nbar = fig.colorbar(shw)\nfig","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"","category":"page"},{"location":"tutorials/2.adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Bloqade","category":"page"},{"location":"#Bloqade","page":"Home","title":"Bloqade","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<p>\nWelcome to the documentation page for Bloqade, a &nbsp;\n    <a href=\"https://julialang.org\">\n        <img src=\"https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia.ico\" width=\"16em\">\n        Julia Language\n    </a>\n    &nbsp; package for quantum computation and quantum dynamics based on neutral-atom architectures.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Neutral-atom quantum computers have two major modes of computation: the first mode is a \"digital mode\" to do universal, digital quantum computation that uses two ground states 0rangle and 1rangle to encode the qubit, which has long coherence time, and one Rydberg state rrangle to entangle the qubits; the second mode is an \"analog mode\" as a programmable quantum simulator that uses one ground state grangle and one Rydberg state rrangle, where the quantum dynamics is governed by a Rydberg Hamiltonian hatmathcalH described below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, Bloqade enables the easy design and fast execution of quantum dynamics in the analog mode,  based on the neutral-atom quantum computing architecture. Besides fast full Hilbert-space simulation on CPUs, the main features include the design of arbitrary-layout quantum registers (Lattices), easy waveform generation (Waveforms), simulation in subspace constrained by the Rydberg blockade (Working with Subspace), faster GPU-accelerated simulation (GPU Acceleration), and more.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<p>\nTo install Bloqade,\n    please <a href=\"https://docs.julialang.org/en/v1/manual/getting-started/\">open\n    Julia's interactive session (known as REPL)</a>, press <kbd>]</kbd> key in the REPL to use the package mode, and then add the QuEra Julia registry via:\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the stable release, type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Bloqade","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or for the current master:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Bloqade#master","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a more advanced installation guide, please see the Installation page.","category":"page"},{"location":"#What-does-Bloqade-Do?","page":"Home","title":"What does Bloqade Do?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the analog mode, Bloqade simulates the time evolution of a quantum state under the Schrödinger equation where the Hamiltonian is the interacting Rydberg Hamiltonian hatmathcalH, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"i hbar dfracpartialpartial t  psi rangle = hatmathcalH(t)  psi rangle  \n\nfracmathcalH(t)hbar = sum_j fracOmega_j(t)2 left( e^i phi_j(t)   g_j rangle  langle r_j  + e^-i phi_j(t)   r_j rangle  langle g_j  right) - sum_j Delta_j(t) hatn_j + sum_j  k V_jk hatn_j hatn_k","category":"page"},{"location":"","page":"Home","title":"Home","text":"Following the atomic physics nomenclature, Omega_j, phi_j, and Delta_j  denote the Rabi frequency, laser phase, and the detuning of the driving laser field on atom (qubit) j coupling the two states   g_j rangle (ground state) and  r_j rangle (Rydberg state); hatn_j = r_jrangle langle r_j is the number operator, and V_jk = C_6overrightarrowmathbfr_j - overrightarrowmathbfr_k^6 describes the Rydberg interaction (van der Waals interaction) between atoms j and k where overrightarrowmathbfr_j denotes the position of the atom j; C_6 is the Rydberg interaction constant that depends on the particular Rydberg state used. For Bloqade, the default C_6 = 862690 times 2pi text MHz μm^6 for r rangle = lvert 70S_12 rangle of the ^87Rb atoms; hbar is the reduced Planck's constant. Sometimes, we also refer the states grangle and rrangle as 0rangle and 1rangle as well in the analog mode.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Starting from an initial quantum state  psi_textini rangle, Bloqade simulates its time evolution under the Hamiltonian hatmathcalH(t), given the qubit positions and the time-dependent profiles for  Omega_j, phi_j, and Delta_j. Bloqade then outputs the real-time-evolved state  psi(t) rangle, which can then be used for measuring different observables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More specifically, here are the steps to program neutral-atom quantum computers using Bloqade:","category":"page"},{"location":"","page":"Home","title":"Home","text":"specify atom positions (see Lattices)\nprogram waveforms of Hamiltonian parameters (see Waveforms)  \ncreate the Hamiltonian (see Hamiltonians)\nspecify the initial state (see Registers and Observables)\nemulation (see Emulation)\nmeasurements & observables (see Registers and Observables).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The default units for various quantities are: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quantity Default Unit\nLength μm\nTime μs\nOmega 2π * MHz\nphi rad\nDelta 2π * MHz","category":"page"},{"location":"#A-Simple-Example","page":"Home","title":"A Simple Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's try a simple example of simulating quantum many-body dynamics governed by the Rydberg Hamiltonian. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We start by loading the Bloqade Module:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Bloqade","category":"page"},{"location":"","page":"Home","title":"Home","text":"As one can see from the Rydberg Hamiltonian, the interactions between Rydberg atoms depend on their positions. Bloqade provides several built-in Lattices structures for specifying the atom positions. For instance, we can use the following codes to quickly generate a chain of 10 atoms in 1D: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"nsites = 10;\natoms = generate_sites(ChainLattice(), nsites, scale = 5.74)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We have set the distance between nearest-neighbor atoms to be 5.74 μm. Note that the default unit of length is μm as shown in the table above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's set both Omega and Delta to be constants (and phi = 0). Since all the variable parameters in the Hamiltonian are specified, we can now create an interacting Rydberg Hamiltonian by using rydberg_h: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"h = rydberg_h(atoms; Ω = 4 * 2π, Δ = 0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To create more complicated waveforms for Omega and Delta and find the supported utilities, please refer to the Waveforms page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's create an initial state with all the atoms in the ground state by using zero_state.","category":"page"},{"location":"","page":"Home","title":"Home","text":"reg = zero_state(10)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are interested in measuring observables of the final quantum state of the Rydberg system starting from the initial state and evolving under the Rydberg Hamiltonian over some time duration. We can first create the problem and then directly simulate the time evolution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"prob = SchrodingerProblem(reg, 1.6, h)\nintegrator = init(prob, Vern8());\nemulate!(prob);","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, we have chosen the ODE-based solver (Vern8()) by using SchrodingerProblem and set the total evolution time to be 1.6 μs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"After simulating the time evolution and get the final state, we can measure the Rydberg population at each site for the final state: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"rydberg_populations = map(1:nsites) do i\n    rydberg_density(prob.reg, i)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"prob.reg is the register storing the final state after the time evolution.","category":"page"},{"location":"#Benchmarks","page":"Home","title":"Benchmarks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Have-Suggestions-or-Interested-in-Contributing?","page":"Home","title":"Have Suggestions or Interested in Contributing?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"File an issue to report a bug or request a feature.\nCheck out the Contributing to Bloqade guide if you would like to make your own changes and make a Pull Request when you would like your work to be reviewed","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"EditURL = \"https://github.com/QuEraComputing/Bloqade.jl/blob/master/examples/1.blockade/main.jl\"","category":"page"},{"location":"tutorials/1.blockade/main/#blockade","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"","category":"section"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The Rydberg blockade mechanism is one of the most important phenomena of neutral atom quantum computing based on Rydberg interactions. By including a term in the effective Hamiltonian which adds an interaction between adjacent atoms in the Rydberg states, one can construct gates and nontrivial dynamics that create entanglement and correlation across the system.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The Rydberg interaction is a van der Waals interaction, where there is an energy shift if two adjacent atoms are both in the Rydberg state. The van der Waals interaction is","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"V_jk = fracC_6overrightarrowmathbfr_j - overrightarrowmathbfr_k^6hat n_j hat n_k","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"where hat n_j=r_jranglelangle r_j is the number operator on the jth site, which is 1 if the atom is in the Rydberg state  r_j rangle, and zero if the atom is in the ground state  g_j rangle. The coefficient C_6 = 2pitimes 862690 text MHz μm^6 is the interaction strength; characteristically, this interaction has a strength C_6 approx 2pitimes 4 MHz for two atoms separated by 774 μm, a similar scale to the Rabi frequency coupling the ground and the Rydberg state. Crucially, this can be seen as an energy shift on atom k, conditional on the state of atom j, and so can be used, in a loose sense, as a conditional logical gate. This is because the adjacent atom forces the atom to be off-resonant with the laser field if it is in the Rydberg state. Please refer to the Hamiltonians page for descriptions of all the terms in the Rydberg Hamiltonian.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"This conditional drive can be seen given the following dynamics. Suppose two atoms are close to each other ( 10 μm) and so experience a strong Rydberg interaction. The left atom is either in a Rydberg state, or in the ground state, and the right atom is originally in the ground state. Then, a Rabi drive is applied to the right atom, which couples the atom's ground state to the Rydberg state. For this example, we choose a Rabi frequency of Omega=2pitimes 05 MHz and distance between atoms overrightarrowmathbfr_j - overrightarrowmathbfr_k = 7 μm, which gives a conditional detuning (Rydberg interaction) of approx 2pi times 733 MHz. When the left atom is in the ground state (black, top), there are no interactions and the state of the right atom experiences standard Rabi oscillation between the ground state and the Rydberg state; for a particular choice of timing, this executes a pi pulse, flipping the right atom from the ground to the Rydberg state. However, when the left atom is in the Rydberg state (red, bottom), there is a large detuning on the right atom due to the strong Rydberg interaction, which causes the transfer to the Rydberg state to be strongly suppressed. In this case, the right atom (up to perturbative corrections) is never in the Rydberg state. This is the so-called Rydberg blockade.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"(Image: RydbergBlockade)","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Because of the large energy shift from having two adjacent atoms in the Rydberg state, evolution from an atomic ground state with local Rabi couplings between ground and Rydberg is restricted to a low-energy subspace of states where no two adjacent atoms are in the Rydberg state. Furthermore, because the interaction strength with distance is a large power law, one can define a characteristic scale set by the Rabi frequency. If two atoms are close such that the conditional detuning is much larger than the Rabi frequency, one can consider the atoms to be blockading each other, and both atoms cannot simultaneously be in the Rydberg state. In contrast, if two atoms are far away, the two atoms never blockade each other and both atoms can simultaneously be in the Rydberg state.","category":"page"},{"location":"tutorials/1.blockade/main/#Blockade-radius-R_b,-subspace-radius-R_s,-and-unit-disk-graphs","page":"Rydberg Blockade","title":"Blockade radius R_b, subspace radius R_s, and unit disk graphs","text":"","category":"section"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The blockade radius is defined as the distance at which the Rydberg interaction energy is the same as the Rabi frequency","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"fracC_6R_b^6 = Omega","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"where R_b is the blockade radius, which sets the characteristic distance scale for which Rydberg interaction will be strong compared to the coupling strength between the ground and the Rydberg state set by Omega. In the above example, Omega = 2pitimes 05 MHz, so R_b = (C_6  Omega)^16 approx 1095  μm. In practice, the blockade approximation, i.e., truncating the states that have both atoms in the Rydberg state, may not be a good approximation at the distance R_b, since it is more like the onset energy scale at which Rydberg interaction becomes strong. For a better blockade approximation, the atoms should be closer than R_b. We refer this distance as the subspace radius R_s (R_s leq R_b), at which we claim it will be a reasonably good approximation to throw away all the states that have more than one Rydberg states whenever they are within the radius R_s.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Therefore, in simulating the quantum dynamics, instead of doing it in the full 2^N Hilbert space, we may take advantage of the energy structure and truncate those blockade-violated states. Mathematically, this is related to the independent sets of the unit disk graph defined by the positions of the atoms. A unit disk graph is a set of vertices and edges, where each vertex represents an atom, and there are edges if the distance between vertices is less than or equal to some unit disk radius overrightarrowmathbfr_j - overrightarrowmathbfr_k leq R_u. An independent set is a set of vertices in the graph such that no two of which are connected by an edge. Thus, the non-blockade-violated states are the independent set states of the corresponding unit disk graph, where the independent set consists of the vertices (atoms) that are excited to the Rydberg state. If we set R_u = R_s, it will be a good approximation to throw away those non-independent-sets. In practice, a priori, it may not be easy to know what will be a good choice for R_s, since it depends on the specific atom arrangement and the specific many-body quantum dynamics. For example, if R_s = 12 * R_b, we will be throwing away states that have interaction energies at least 2^6*Omega, which will typically be a very good approximation. In the two-atom example above, we can set R_s = 7 μm and throw away the state when both atoms are in the Rydberg state, which is quite good an approximation as seen in the figure. In this case, the Rydberg-blockaded state has an interaction of (R_b  R_s)^6 Omega approx 147 Omega. When the blockade approximation is valid, the computational states would be separated into bands due to the strong Rydberg interaction, and there will be small perturbative coupling between the bands due to the Rabi coupling, (which is typically in the order of (Omega  V_jk)^2). See the illustrative figure below:","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"(Image: EnergyTruncation)","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The lowest energy states are representative of independent sets of the unit disk graph, where Rydberg excitations are in the independent set and no two Rydberg excitations are within the unit disk radius. The second energy band are sets with a single independent set violation, where there are equivalently just two Rydberg excitations within the unit disk radius of each other. Higher and higher bands represent more and more independent set violations. We emphasize again that this band structure is dependent on the arrangement of atoms, and for arbitrary configurations, this band structure may not be clear.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"To run more efficient simulation in the blockade subspace, the simplest scheme is to truncate the Hilbert space to the low-energy subspace, and exclude all states above a certain energy. Given the natural band structure of the classical Hamiltonian, we may simply truncate the Hilbert space to the subspace of independent sets of the unit disk graph with the unit disk radius set as R_u = R_s. Equivalently, this is the blockade subspace, where atoms within the subspace radius are excluded from both being in the Rydberg state. The validity of the energy truncation subspace is governed by the strength of off-diagonal matrix elements coupling the low-energy subspace to the high-energy one. For the Rydberg Hamiltonian, these off-diagonal elements 1rrangleleftrightarrowrrrangle have a strength Omega. In order to preserve dynamics within the subspace, the energy difference between states within the blockade subspace (e.g., 1rrangle) and outside (rrrangle) must be much larger than the Rabi strength. Formally, if Omega ll C_6R_s^6, then the blockade approximation should be valid (the perturbation is typically in the second order (Omega (C_6R_s^6))^2). As long as this condition holds, the exact dynamics in the full Hilbert space should be closely approximated by the approximate dynamics in the blockade subspace, as the mixing terms only couple to low-energy states.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Please also refer to the subspace page for more details on running simulation in the subspace. Also, see MIS tutorial for more descriptions on the correspondence between the independent set constraint and the blockade constraint, and a tutorial on how to solve the maximum independent set problem using Rydberg Hamiltonians.","category":"page"},{"location":"tutorials/1.blockade/main/#Setting-Atom-Separation-Distance-from-the-Blockade-Radius","page":"Rydberg Blockade","title":"Setting Atom Separation Distance from the Blockade Radius","text":"","category":"section"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Suppose given certain arrangement of atoms, we would like to have the close-by atoms to be mutually blockaded, while the far-away atoms to be non-blockaded. This corresponds to a unit disk graph and the distance scale can be set by the blockade radius R_b. For any two atoms within the unit disk radius R_u, the energy scale of having both in the Rydberg state must be much larger than Omega; this sets a lower bound for R_u compared to R_b. On the other hand, for any two atoms outside of the unit disk radius, the energy scale of having both be in the Rydberg state must be much smaller than Omega, as the two atoms should not be blockaded; this sets an upper bound for R_u, as there are still 1R^6 interactions between nearby atoms which may \"accidentally\" blockade each other if R_u is too large to include the supposedly unblockaded atoms. This upper bound on R_u guarantees that dynamics occur within the correct independent set subspace and is not affected by long-range \"Rydberg tails\", which cause each independent set state to have a slightly different energy.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"More specifically, we denote the lower bound as R_textmin, which is the minimum R_u can be without removing any edges from the unit disk graph. Equivalently, it is the maximum distance between vertices that are connected by an edge. We denote the upper bound as R_textmax, which is the maximum R_u can be without adding any additional edges to the unit disk graph. This is equivalently the minimum distance between vertices that are not connected by an edge in the unit disk graph. Therefore, we have R_textminleq R_u  R_textmax.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The actual scale for R_textmin R_u R_textmax can be set by R_b. In order to fulfill the condition","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":" fracC_6R_textmax^6 ll Omega equiv fracC_6R_b^6 ll fracC_6R_textmin^6","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"as much as possible, it's best to have","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"R_b = sqrtR_textmin R_textmax = R_textmin * sqrtfracR_textmaxR_textmin\nquad Rightarrow quad R_textmin = R_b * sqrtfracR_textminR_textmax","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Now, there are several characteristic distances. To summarize, we have:","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"R_u is the unit disk radius of the graph. Usually, this is taken to be R_u = R_textmin, though generally R_textmin leq R_u  R_textmax.\nR_textmin is the minimum R_u can be without removing any edges from the unit disk graph.\nR_textmax is the maximum R_u can be without adding any edges from the unit disk graph.\nR_b is the blockade radius of the system defined as C_6R_b^6 = Omega. It's preferable to scale R_textmin and R_textmax such that R_b = sqrtR_textmin R_textmax.\nR_s is the subspace radius, at which it is a good approximation to truncate the Hilbert space when two Rydberg excitations are closer than R_s. We have R_s leq R_b.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Note that R_s is used only for faster simulation in the truncated blockade subspace. The smaller the R_s, the better the approximation for the simulation. When R_s = 0, one recovers the full-space simulation.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Below, we explain how to set the distance scale using a few example unit disk graphs.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"(Image: BlockadRadius)","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"In these examples in the above figure, R_textmin is the radius of the dark-red disk, R_textmax is the radius of the light-red disk, and R_b is the radius of the red-dashed circle. The ratios R_textmaxR_textmin are shown for several arrangements of atoms. For the 1D chain with nearest-neighbor blockade, let's say the lattice constant is a with R_textmin = a and R_textmax = 2a. So with R_b = sqrtR_textmin R_textmax, we have a = R_bsqrt2. Therefore,","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"For a given Omega = 2pi times 4 MHz,\nR_b = (C_6  Omega)^16 approx 774 μm,\na = R_b sqrt2 approx 548 μm.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Thus, for the Z_2 phase transition of the adiabatic example and in the 1D paper, it is good to set a = 548 μm. Similarly, one can compute that a = 316 μm and a = 224 μm will be good choices for observing Z_3 and Z_4 phase transitions in the 1D chain. For the 2D square lattice, a = 651 μm and a = 460 μm are good options for observing the checkerboard phase (nearest-neighbor blockade) and the striated phase (next-nearest-neighbor blockade) as in this paper, following the same rationale as above. Here, we summarize the recommended lattice constants (unit μm) for common lattices in the following table:","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":" R_textmin R_textmax a for Omega = 2pi * 4 MHz a for Omega = 2pi * 10 MHz\nChain Z_2 a 2a 5.48 4.70\nChain Z_3 2a 3a 3.16 2.71\nChain Z_4 3a 4a 2.24 1.92\nSquare checkerboard a sqrt2a 6.51 5.59\nSquare striated sqrt2a 2a 4.60 3.95\nSquare star 2a sqrt5a 3.66 3.14\nLieb NN a 2a 5.48 4.70\nLieb NNN 2a sqrt5a 3.66 3.14\nLieb NNNN sqrt5a sqrt8a 3.08 2.64\nTriangular NN a sqrt3a 5.88 5.05\nTriangular NNN sqrt3a 2a 4.16 3.57\nHoneycomb NN a sqrt3a 5.88 5.05\nHoneycomb NNN sqrt3a 2a 4.16 3.57\nKagome NN a sqrt3a 5.88 5.05\nKagome NNN sqrt3a 2a 4.16 3.57","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Other than regular lattices, for an example arbitrary graph shown in the right most panel of the above figure, one only has R_textmaxR_textmin approx 115. Thus, there is only a small window to set the unit disk radius, and the energy scale for the blockaded versus non-blockaded Rydberg interaction is not as large (115^6 approx  234). Thus, the blockade approximation for the atoms with a separation close to the blockade radius will not be as good. For accurate simulation of the actual Rydberg dynamics, one should take a subspace radius R_s ll R_textmin. Therefore, we can see that graphs on a regular lattice typically have larger and better energy separation between the blockaded and the non-blockaded states than arbitrary graphs.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Below, we give an example of doing the simulation in the blockade subspace for a ring system. For more information on subspace emulation, please refer to the subspace page.","category":"page"},{"location":"tutorials/1.blockade/main/#Example-Dynamics-in-the-Blockade-Subspace","page":"Rydberg Blockade","title":"Example Dynamics in the Blockade Subspace","text":"","category":"section"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"To emphasize the effectiveness of the subspace emulation, some example nonequilibrium dynamics are shown below, for a ring of 12 atoms seperated by R_textmin = 69 μm. The minimum distance of atoms not within the blockade radius is R_textmax approx 1333 μm (next-nearest neighbor separation), Thus, the blockade radius can be R_b = 69 times sqrt133369 approx 959 μm. This blockade energy scale corresponds to Omega approx 2pi * 111 MHz, and the perturbative limits to be Omega ll C_6R_textmin approx 799 MHz and Omega gg C_6R_textmax approx 015 MHz.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Note that in this example, we set the blockade radius from R_textmin and R_textmax, and then obtain Rabi frequency Omega from the blockade radius. In practice, it's often the opposite order for specification on the hardware. Omega is typically limited by the laser power on the hardware. Thus, one starts from a given Omega, which determines the blockade radius, R_b, which can then inform the separation between atoms as described in the previous section. If one starts from the atom separation distance first, it may often results in a Rabi frequency that is too large or too small to be feasible on the neutral-atom hardware.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The set of atoms for this ring example can be defined by:","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"using Bloqade\nnsites = 12; # 12-site ring\nunit_disk_radius = 6.9 # Distance between nearest-neighbor atoms, in microns; R_min\n\nR = unit_disk_radius / (2 * sin(2 * pi / (nsites) / 2)) # Radius of the circle, using a little trigonometry; it is also the next-nearest neighbor distance, R_max.\npos = [(R * sin(i * 2 * pi / (nsites)), R * cos(i * 2 * pi / (nsites))) for i in 1:nsites] # Positions of each atom\natoms = AtomList(pos); # Define the atom positions as an AtomList.\n\nblockade_radius = sqrt(unit_disk_radius * R);  # R_b = \\sqrt{R_min R_max}","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"    CondaPkg Found dependencies: /home/runner/work/Bloqade.jl/Bloqade.jl/CondaPkg.toml\n    CondaPkg Found dependencies: /home/runner/.julia/packages/PythonCall/DqZCE/CondaPkg.toml\n    CondaPkg Resolving changes\n             + libstdcxx-ng\n    CondaPkg Installing packages\n  Package              Version  Build               Channel                    Size\n─────────────────────────────────────────────────────────────────────────────────────\n  Install:\n─────────────────────────────────────────────────────────────────────────────────────\n\n  + lz4-c                1.9.3  h9c3ff4c_1          conda-forge/linux-64     Cached\n  + olefile               0.46  pyh9f0ad1d_1        conda-forge/noarch         33kB\n  + pcre                  8.45  h9c3ff4c_0          conda-forge/linux-64     Cached\n\n  Change:\n─────────────────────────────────────────────────────────────────────────────────────\n\n  - fonttools           4.37.4  py310h5764c6d_0     conda-forge              Cached\n  + fonttools           4.37.4  py39hb9d737c_0      conda-forge/linux-64        2MB\n  - matplotlib           3.5.1  py310hff52083_0     conda-forge              Cached\n  + matplotlib           3.5.1  py39hf3d152e_0      conda-forge/linux-64        6kB\n  - matplotlib-base      3.5.1  py310h23f4a51_0     conda-forge              Cached\n  + matplotlib-base      3.5.1  py39h2fa2bec_0      conda-forge/linux-64        8MB\n  - pyqt                5.12.3  py310hff52083_8     conda-forge              Cached\n  + pyqt                5.12.3  py39hf3d152e_8      conda-forge/linux-64       22kB\n  - pyqt-impl           5.12.3  py310h1f8e252_8     conda-forge              Cached\n  + pyqt-impl           5.12.3  py39hde8b62d_8      conda-forge/linux-64        6MB\n  - pyqt5-sip          4.19.18  py310h122e73d_8     conda-forge              Cached\n  + pyqt5-sip          4.19.18  py39he80948d_8      conda-forge/linux-64      318kB\n  - pyqtchart             5.12  py310hfcd6d55_8     conda-forge              Cached\n  + pyqtchart             5.12  py39h0fcd23e_8      conda-forge/linux-64      263kB\n  - pyqtwebengine       5.12.1  py310hfcd6d55_8     conda-forge              Cached\n  + pyqtwebengine       5.12.1  py39h0fcd23e_8      conda-forge/linux-64      178kB\n  - tornado                6.2  py310h5764c6d_0     conda-forge              Cached\n  + tornado                6.2  py39hb9d737c_0      conda-forge/linux-64      673kB\n  - unicodedata2        14.0.0  py310h5764c6d_1     conda-forge              Cached\n  + unicodedata2        14.0.0  py39hb9d737c_1      conda-forge/linux-64      510kB\n  - zstd                 1.5.2  h6239696_4          conda-forge              Cached\n  + zstd                 1.5.2  h8a70e8d_1          conda-forge/linux-64     Cached\n\n  Reinstall:\n─────────────────────────────────────────────────────────────────────────────────────\n\n  o certifi          2022.9.24  pyhd8ed1ab_0        conda-forge              Cached\n  o cycler              0.11.0  pyhd8ed1ab_0        conda-forge              Cached\n  o munkres              1.1.4  pyh9f0ad1d_0        conda-forge              Cached\n  o packaging             21.3  pyhd8ed1ab_0        conda-forge              Cached\n  o pip                 22.2.2  pyhd8ed1ab_0        conda-forge              Cached\n  o pyparsing            3.0.9  pyhd8ed1ab_0        conda-forge              Cached\n  o python-dateutil      2.8.2  pyhd8ed1ab_0        conda-forge              Cached\n  o setuptools          65.4.1  pyhd8ed1ab_0        conda-forge              Cached\n  o six                 1.16.0  pyh6c4a22f_0        conda-forge              Cached\n  o wheel               0.37.1  pyhd8ed1ab_0        conda-forge              Cached\n\n  Downgrade:\n─────────────────────────────────────────────────────────────────────────────────────\n\n  - expat                2.4.9  h27087fc_0          conda-forge              Cached\n  + expat                2.4.8  h27087fc_0          conda-forge/linux-64     Cached\n  - glib                2.74.0  h6239696_0          conda-forge              Cached\n  + glib                2.70.2  h780b84a_4          conda-forge/linux-64      441kB\n  - glib-tools          2.74.0  h6239696_0          conda-forge              Cached\n  + glib-tools          2.70.2  h780b84a_4          conda-forge/linux-64      108kB\n  - gstreamer           1.20.3  hd4edc92_2          conda-forge              Cached\n  + gstreamer           1.20.2  hd4edc92_1          conda-forge/linux-64     Cached\n  - kiwisolver           1.4.4  py310hbf28c38_0     conda-forge              Cached\n  + kiwisolver           1.4.2  py39hf939315_1      conda-forge/linux-64       77kB\n  - lerc                 4.0.0  h27087fc_0          conda-forge              Cached\n  + lerc                   3.0  h9c3ff4c_0          conda-forge/linux-64     Cached\n  - libglib             2.74.0  h7a41b64_0          conda-forge              Cached\n  + libglib             2.70.2  h174f98d_4          conda-forge/linux-64     Cached\n  - libstdcxx-ng        12.1.0  ha89aaad_16         conda-forge              Cached\n  + libstdcxx-ng        11.3.0  hd8f1017_16         conda-forge/linux-64     Cached\n  - libtiff              4.4.0  h55922b4_4          conda-forge              Cached\n  + libtiff              4.2.0  hf544144_3          conda-forge/linux-64      605kB\n  - mysql-common        8.0.30  h26416b9_1          conda-forge              Cached\n  + mysql-common        8.0.29  h26416b9_1          conda-forge/linux-64     Cached\n  - mysql-libs          8.0.30  hbc51c84_1          conda-forge              Cached\n  + mysql-libs          8.0.29  hbc51c84_1          conda-forge/linux-64     Cached\n  - nss                   3.78  h2350873_0          conda-forge              Cached\n  + nss                   3.77  h2350873_0          conda-forge/linux-64     Cached\n  - numpy               1.23.3  py310h53a5b5f_0     conda-forge              Cached\n  + numpy               1.22.3  py39hc58783e_2      conda-forge/linux-64        7MB\n  - openjpeg             2.5.0  h7d73246_1          conda-forge              Cached\n  + openjpeg             2.4.0  hb52868f_1          conda-forge/linux-64      455kB\n  - pillow               9.2.0  py310hbd86126_2     conda-forge              Cached\n  + pillow               8.2.0  py39hf95b381_1      conda-forge/linux-64      706kB\n  - python              3.10.6  ha86cf86_0_cpython  conda-forge              Cached\n  + python              3.9.13  h2660328_0_cpython  conda-forge/linux-64       28MB\n  - python_abi            3.10  2_cp310             conda-forge              Cached\n  + python_abi             3.9  2_cp39              conda-forge/linux-64        4kB\n\n  Summary:\n\n  Install: 3 packages\n  Change: 11 packages\n  Reinstall: 5 packages\n  Downgrade: 17 packages\n\n  Total download: 55MB\n\n─────────────────────────────────────────────────────────────────────────────────────\n\n","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The system is driven by a constant Rabi drive, which couples each atom's ground and Rydberg state. The Hamiltonian can be defined in Bloqade with:","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"C6 = 2π * 862690;\nΩ = C6 / blockade_radius^6\nh = rydberg_h(atoms; Ω = Ω);","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The system is then initialized into the ground state of all atoms, which is the lowest energy of the classical Hamiltonian. We have two choices of basis: the first choice is the full Hilbert space of 2^12 elements, whereas the second basis is the blockade subspace, which excludes Rydberg excitations within the subspace radius, R_s. In principle, the subspace radius can be taken to be any value less than the blockade radius, but for better approximation, it is better to take smaller R_s. Typically, R_s  R_b  17 will be reasonably good approximation, since states with Rydberg interaction 17^6 Omega approx 24 Omega will be then truncated, and the perturbative truncation error is typically in second order. For R_s = 0, no states are excluded and one recovers the exact dynamics. For a subspace radius anywhere between R_textmin and R_textmax, the subspace is the same, as there are no vertices having a separation within those radii. Here, we choose the subspace radius for the ring of atoms to be the unit disk radius, which corresponds to truncating the states having a Rydberg interaction (R_bR_u)^6 Omega approx 72 Omega. For more general graphs, it may be reasonable to choose the subspace radius to be smaller than the unit disk radius and include extra states to improve the fidelity of the energy truncation. For example, for the next-nearest-neighbor line, it may be reasonable to choose the subspace radius to be half the blockade radius, which includes high-energy NNN blockaded states to improve numerical accuracy. See the subspace page for more details.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"subspace_radius = unit_disk_radius # R_s\n\ninit_state = zero_state(nsites) # Define the initial state in the full space.\nspace = blockade_subspace(atoms, subspace_radius) # Compute the blockade subspace with R_s.\ninit_state2 = zero_state(space); # Define the initial state in the blockade subspace.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The blockade subspace has D=322 elements, which is much smaller than 2^12, so the emulation will be much faster. If the atoms were far apart and non-interacting, each atom would oscillate completely between its ground state and Rydberg state with a period of approx 05 μs. However, because adjacent atoms shift to the Rydberg state concurrently, they are dynamically blockaded, causing the maximum Rydberg density to only be 12, corresponding to an antiferromagnetic Z_2 state. Note that because the ring has a translation symmetry, the Rydberg density is equal on all sites.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Tmax = 6.0\nnsteps = 2001\ntimes = LinRange(0, Tmax, nsteps)\ndt = Tmax / (nsteps - 1)\n\nprob = SchrodingerProblem(init_state, Tmax, h, dt = dt, adaptive = false);\nintegrator = init(prob, Vern8());\n\ndensities = [] # Time evolve the system in the full space\nfor _ in TimeChoiceIterator(integrator, 0.0:dt:Tmax)\n    push!(densities, rydberg_density(init_state, 1))\nend\n\nprob2 = SchrodingerProblem(init_state2, Tmax, h, dt = dt, adaptive = false);\nintegrator2 = init(prob2, Vern8());\n\ndensities2 = [] # Time evolve the system in the subspace\nfor _ in TimeChoiceIterator(integrator2, 0.0:dt:Tmax)\n    push!(densities2, rydberg_density(init_state2, 1))\nend","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Plot the data:","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"using PythonCall # Use matplotlib to generate plots\nmatplotlib = pyimport(\"matplotlib\")\nplt = pyimport(\"matplotlib.pyplot\")\n\nax = plt.subplot(1, 1, 1)\nplt.plot(times, real(densities), \"k\", label = \"Full space\")\nplt.plot(times, real(densities2), \"r--\", label = \"Subspace\")\nax.axis([0, Tmax, 0, 0.45])\nplt.xlabel(\"Time (us)\")\nplt.ylabel(\"Rydberg density\")\nplt.tight_layout()\nplt.legend()\n\ninset_axes = pyimport(\"mpl_toolkits.axes_grid1.inset_locator\")\nax2 = inset_axes.inset_axes(ax, width = \"20%\", height = \"30%\", loc = \"lower right\", borderpad = 1)\nplt.plot(times, real(densities - densities2))\nplt.axis([0, 0.5, -0.001, 0.003])\nplt.ylabel(\"Difference\", fontsize = 12)\nplt.yticks(LinRange(-0.001, 0.003, 5), fontsize = 12);\nplt.xticks([0, 0.2, 0.4, 0.6], fontsize = 12);","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"(Image: RydbergBlockadeSubspace)","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Data for this evolution is shown above, where exact evolution in the full space is shown by the black line, and the truncated evolution in the subspace is shown by the red dashed line. It is clear that even though the Hilbert space is 12times smaller, the dynamics are faithfully reproduced, up to high frequency oscillations (inset) from adjacent atoms in the Rydberg state, similar to the high frequency oscillations of the 2-atom conditional blockade example above. However, at longer times, this subspace approximation fails to reproduce the full space (shown by divergence between the black and red dashed lines), as the perturbative effects become relevant over longer timescales.","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"","category":"page"},{"location":"tutorials/1.blockade/main/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"This page was generated using Literate.jl.","category":"page"},{"location":"julia/#The-Julia-Programming-Language","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"The Bloqade project is built in the Julia programming language.  For those who are not familiar with Julia, here is a quick start for some basic Julia grammar, and a guide for learning more about Julia and advanced usage.","category":"page"},{"location":"julia/#Why-Julia?","page":"The Julia Programming Language","title":"Why Julia?","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Fast. As you might have heard, Julia is very fast; there are various benchmarks online.   It can be used to even write Basic Linear Algebra Subroutine (BLAS) to reach performance that is on par with the   manually optimized assembly with C (check Octavian).\nGeneric. The language itself and its ecosystem are built to be generic, and the compiler can specialize   on generic methods automatically. Thus, you will find that a lot things can be combined easily, and they will   just work, e.g. plugging in the Measurement number from    Measurement.jl into your ODE solver, you will get error propagation automatically; plugging in Tropical numbers or in general a semi-ring algebra into a tensor-network contraction function, you can   solve optimization problems with tensor networks, and so on.\nDifferentiable. The language is differentiable, which means you can calculate the derivatives   using an automatic differentiation (AD) engine on the whole language. The AD ecosystem in Julia is very well developed and supported.    The current stable AD engine   is powered by Zygote and the next generation AD engine includes   Diffractor (check the video talk on ACM SIGPLAN) and   Enzyme.\nExtensible. The language is designed to be compiler friendly. It supports staged programming   as well as compiler plugins. This makes supporting new hardware much easier. As a result, Julia   can conveniently support multiple different hardware, such as CUDA,   oneAPI, TPU, and potentially quantum computers in the future.\nEasy. With all these powerful features, the language itself is still rather easy to learn. Let's go to   the quick start section to skim through the basic syntax.","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"info: Info\nMulti-stage programming (MSP) is a variety of metaprogramming in which compilation is divided into a series of intermediate phases, allowing typesafe run-time code generation. Statically defined types are used to verify that dynamically constructed types are valid and do not violate the type system. – Wikipedia","category":"page"},{"location":"julia/#Quick-Start","page":"The Julia Programming Language","title":"Quick Start","text":"","category":"section"},{"location":"julia/#Variables-and-Some-Basic-Types","page":"The Julia Programming Language","title":"Variables and Some Basic Types","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"In Julia, you can define a variable similar to how you define it in Python.  For example, you can define a x using = (assignment):","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"x = 1","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Every variable has a type. You can check it using typeof:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"typeof(x)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"By default, Julia displays the output of the last operation. You can suppress the output by adding ; (a semicolon) at the end.","category":"page"},{"location":"julia/#Functions","page":"The Julia Programming Language","title":"Functions","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"In Julia, you can also define short-form, one-line functions using = (assignment) similar to how you write things mathematically.","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"f(x) = 2x","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Typing the function's name gives information about the function. To call it, we must use parentheses:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"f\nf(2)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"For longer functions, we use the following syntax with the function keyword and end:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"function g(x, y)\n\tz = x + y\n\treturn z^2\nend","category":"page"},{"location":"julia/#Control-Flows","page":"The Julia Programming Language","title":"Control Flows","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"In Julia, there are for, if and while control flows. For example, the for loop looks like:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"s = 0\nfor i in 1:10\n    s += 1\nend","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"we can now check the value of s by typing it again:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"s","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Here, 1:10 is a range representing the numbers from 1 to 10:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"typeof(1:10)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"the if else statement looks like the following:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"if s < 10\n\t# do something\nelseif 10 < s < 13\n\t# do something\nelse\n\t# do something\nend","category":"page"},{"location":"julia/#Matrix-and-Array","page":"The Julia Programming Language","title":"Matrix and Array","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Julia carries its own Array type. If you use Python, it is similar to numpy.array in Python except:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"index starts from 1,\nthe multi-dimensional index is column-wise.","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"You can also use list comprehension:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"[i for i in 1:10]","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"It works for multi-dimensional case too:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"[(i, j) for i in 1:10, j in 1:5]","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Most functions involving matrices and arrays follow the same convention as numpy or MATLAB. For example, you can create a random matrix using:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"rand(5, 5)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"If you have questions about using a function, you can always type the question mark ? in your REPL following the function name:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> ?rand","category":"page"},{"location":"julia/#Package-Manager-and-Environments","page":"The Julia Programming Language","title":"Package Manager & Environments","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Julia carries its own package manager. You can use it as a normal package:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> using Pkg","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"To install a package, you can use:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> Pkg.add(\"Bloqade\")","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"To remove a package, you can use:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> Pkg.rm(\"Bloqade\")","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"All Julia programs run inside an environment. The default is the global environment. It is usually recommended to run your notebook in a local environment, so you won't hit any version conflicts between different packages. ","category":"page"},{"location":"julia/#Resources","page":"The Julia Programming Language","title":"Resources","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"For more resources, check the official website julialang.org/learning:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"<style>\n  iframe {\n    width: 1px;\n    min-width: 100%;\n    min-height: 1000px;\n  }\n</style>\n<iframe id=\"myIframe\" src=\"https://julialang.org/learning/\"></iframe>\n<script>\n  iFrameResize({ log: true }, '#myIframe')\n</script>","category":"page"}]
}
