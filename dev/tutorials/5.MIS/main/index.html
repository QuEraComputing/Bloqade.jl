<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Maximum Independent Set Problem · Bloqade.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link rel="canonical" href="https://QuEraComputing.github.io/Bloqade.jl/tutorials/5.MIS/main/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/indigo.css" rel="stylesheet" type="text/css"/><link href="../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img class="docs-light-only" src="../../../assets/logo.svg" alt="Bloqade.jl logo"/><img class="docs-dark-only" src="../../../assets/logo-dark.svg" alt="Bloqade.jl logo"/></a><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../install/">Installation</a></li><li><a class="tocitem" href="../../../julia/">The Julia Programming Language</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../lattices/">Lattices</a></li><li><a class="tocitem" href="../../../waveform/">Waveforms</a></li><li><a class="tocitem" href="../../../hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../../../registers/">Registers and Observables</a></li><li><a class="tocitem" href="../../../emulation/">Emulation</a></li><li><a class="tocitem" href="../../../subspace/">Working with Subspace</a></li><li><a class="tocitem" href="../../../units/">Working with Units</a></li><li><a class="tocitem" href="../../../mis/">Maximum Independent Set</a></li><li><a class="tocitem" href="../../../cuda/">GPU Acceleration</a></li><li><a class="tocitem" href="../../../3-level/">3-Level Support and Quantum Gates</a></li><li><a class="tocitem" href="../../../schema/">Interacting with Neutral Atom Hardware</a></li><li><a class="tocitem" href="../../../capabilities/">Hardware Capabilities</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../1.blockade/main/">Rydberg Blockade</a></li><li><a class="tocitem" href="../../2.adiabatic/main/">Adiabatic Evolution</a></li><li><a class="tocitem" href="../../3.quantum-scar/main/">Quantum Scar</a></li><li><a class="tocitem" href="../../4.LGT/main/">Simulation of lattice gauge theory with Rydberg atoms</a></li><li class="is-active"><a class="tocitem" href>The Maximum Independent Set Problem</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Setting-Up-the-Problem"><span>Setting Up the Problem</span></a></li><li><a class="tocitem" href="#The-Adiabatic-Approach"><span>The Adiabatic Approach</span></a></li><li><a class="tocitem" href="#QAOA-with-Piecewise-Constant-Pulses"><span>QAOA with Piecewise Constant Pulses</span></a></li><li><a class="tocitem" href="#Smoothened-Piecewise-Linear-Pulses"><span>Smoothened Piecewise Linear Pulses</span></a></li></ul></li><li><a class="tocitem" href="../../6.MWIS/main/">Maximum Weight Independent Set</a></li><li><a class="tocitem" href="../../7.QMC/main/">Quantum Monte Carlo Method</a></li></ul></li><li><a class="tocitem" href="../../../contrib/">Contributing to Bloqade</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>The Maximum Independent Set Problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Maximum Independent Set Problem</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuEraComputing/Bloqade.jl/blob/master/examples/5.MIS/main.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="mis-tutorial"><a class="docs-heading-anchor" href="#mis-tutorial">The Maximum Independent Set Problem</a><a id="mis-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#mis-tutorial" title="Permalink"></a></h1><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>In graph theory, an independent set is a set of vertices in a graph such that no two of which are connected by an edge. The problem of finding Maximum Independent Sets (MISs) is NP-hard, i.e., it is unlikely to be solved in a time polynomial to the problem size. Interestingly, there is a natural connection between the independent set constraint, and the <a href="../../1.blockade/main/#blockade">Rydberg Blockade</a> phenomenon in neutral-atom quantum computing using Rydberg states. More specifically, Rydberg blockade implies that two atoms cannot be both excited to the Rydberg state <span>$|r\rangle$</span> if they are close to each other, whereas independent set constraint means two vertices cannot be both in the independent set when they are connected by an edge. Thus, one can consider atoms in the Rydberg state as vertices in an independent set. See the proposal in <a href="https://arxiv.org/pdf/1808.10816.pdf">H. Pichler, et al.</a> for more details.</p><p>In particular, one can use the ground state of the <a href="../../../hamiltonians/#Hamiltonians">Rydberg Hamiltonian</a> to encode the <a href="https://en.wikipedia.org/wiki/Independent_set_(graph_theory)">maximum independent set problem</a>, which is to find the largest independent set of a given graph. For a particular subclass of geometric graphs, the so-called unit disk graphs, the Rydberg Hamiltonian can encode the solution without any overhead in the number of qubits. In fact, an experimental demonstration of quantum optimization has been realized in solving the maximum independent set problem on up to 289 qubits in <a href="https://arxiv.org/abs/2202.09372">S. Ebadi, et al.</a>.</p><p>In this tutorial, we show how to solve the MIS problem using Bloqade. We focus on a particular subclass of unit disk graphs defined as Diagonal-connected Unit-disk Grid Graphs (DUGG). This is the class of graphs studied in the demonstration experiment <a href="https://arxiv.org/abs/2202.09372">S. Ebadi, et al.</a>. Although these graphs have highly constrained topologies, finding its MISs is still NP-hard. Here, we show how to use variational quantum algorithms with Rydberg Hamiltonians to solve the MIS problem on these graphs. The tutorial here strongly resembles the setup in <a href="https://arxiv.org/abs/2202.09372">S. Ebadi, et al.</a>, with the limitation that Bloqade can only simulate a much smaller problem.</p><p>For more details on the functionalities supported by Bloqade in studying independent set problems, please refer to the <a href="../../../mis/#mis">Maximum Independent Set</a> page.</p><p>Let&#39;s start by importing the required libraries:</p><pre><code class="language-julia hljs">using Graphs
using Bloqade
using Random
using GenericTensorNetworks
using Optim
using PythonCall
plt = pyimport(&quot;matplotlib.pyplot&quot;);</code></pre><h2 id="Setting-Up-the-Problem"><a class="docs-heading-anchor" href="#Setting-Up-the-Problem">Setting Up the Problem</a><a id="Setting-Up-the-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Up-the-Problem" title="Permalink"></a></h2><p>To begin, we create a <span>$4*4$</span> DUGG with 0.8 filling, by using the <a href="../../../lattices/#BloqadeLattices.random_dropout"><code>random_dropout</code></a> function. Here, we choose the lattice constant <span>$a$</span> to be 4.5 μm:</p><pre><code class="language-julia hljs">Random.seed!(2)
atoms = generate_sites(SquareLattice(), 4, 4; scale = 4.5) |&gt; random_dropout(0.2)</code></pre><p><img src="../main-12.svg" alt/></p><p>Next, we set the blockade radius to be 7.5 μm, corresponding to a case where nearest neighbors and next-nearest neighbors (diagonal from the initial atom) are within the blockade radius. As we discussed in <a href="../../1.blockade/main/#blockade">Rydberg Blockade</a>, only one Rydberg excitation is allowed within the blockade radius. To better illustrate this constraint, we plot the interactions of Rydberg atoms as a DUGG, where each edge corresponds to the blockade constraint given by the blockade radius:</p><pre><code class="language-julia hljs">Bloqade.plot(atoms, blockade_radius = 7.5)</code></pre><p><img src="../main-14.svg" alt/></p><p>Our goal is to find a maximum independent set of such a graph.</p><p>For comparison, we first use classical algorithms to calculate the MIS size here using the graph utilities in Bloqade, so that one can compare this exact result with the quantum algorithms. The exact MIS size and its degeneracy can be solved with the generic tensor network algorithm in the package <a href="https://github.com/QuEraComputing/GenericTensorNetworks.jl"><code>GenericTensorNetworks</code></a>:</p><pre><code class="language-julia hljs">graph = BloqadeMIS.unit_disk_graph(atoms, 7.5)
mis_size_and_counting = GenericTensorNetworks.solve(IndependentSet(graph), CountingMax())[]</code></pre><pre><code class="nohighlight hljs">(4.0, 26.0)ₜ</code></pre><p>The <code>solve</code> function takes a graph instance and a solution space property as inputs, where the graph instance is generated by the <a href="../../../mis/#BloqadeMIS.unit_disk_graph"><code>unit_disk_graph</code></a> function in the module <code>BloqadeMIS</code>, and the solution space property is to count the number of maximum independent sets here. For this specific DUGG, we see that the MIS size is 4, and the number of maximum independent sets is 26. In the following, we are going to show how to solve the independent set problem with both quantum adiabatic and variational algorithms.</p><h2 id="The-Adiabatic-Approach"><a class="docs-heading-anchor" href="#The-Adiabatic-Approach">The Adiabatic Approach</a><a id="The-Adiabatic-Approach-1"></a><a class="docs-heading-anchor-permalink" href="#The-Adiabatic-Approach" title="Permalink"></a></h2><p>Here, we generalize the quantum adiabatic algorithm used in the tutorial <a href="../../2.adiabatic/main/#Adiabatic-Evolution">Adiabatic Evolution</a> to prepare ground states of the Rydberg Hamiltonian for this disordered lattice. We first construct the adiabatic pulse sequences for the Rabi frequency <span>$\Omega$</span> and the detuning <span>$\Delta$</span>:</p><pre><code class="language-julia hljs">T_max = 0.6
Ω_max = 2π * 4
Ω = piecewise_linear(clocks = [0.0, 0.1, 0.5, T_max], values = [0.0, Ω_max, Ω_max, 0])
Δ_start = -2π * 13
Δ_end = 2π * 11
Δ = piecewise_linear(clocks = [0.0, 0.1, 0.5, T_max], values = [Δ_start, Δ_start, Δ_end, Δ_end])

fig, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (12, 4))
Bloqade.plot!(ax1, Ω)
ax1.set_ylabel(&quot;Ω/2π (MHz)&quot;)
Bloqade.plot!(ax2, Δ)
ax2.set_ylabel(&quot;Δ/2π (MHz)&quot;)
fig</code></pre><p><img src="../main-21.svg" alt/></p><p>Here, the total time is fixed to <code>T_max</code>, the adiabatic evolution path is specified by the <a href="../../../waveform/#BloqadeWaveforms.piecewise_linear"><code>piecewise_linear</code></a> function. Rydberg blockade radius can be computed with</p><p class="math-container">\[C_6 / R_b^6 \sim \sqrt{\Delta^2 + \Omega^2}\]</p><p>The default <span>$C_6=2π * 862690 \text{ MHz μm}^6$</span>. For encoding the corresponding MIS problem at <span>$\Omega = 0$</span>, the detuning can be set around <span>$2\pi \times 11$</span> MHz for a blockade radius of <span>$7.5$</span> µm (see the parameters in <a href="https://arxiv.org/abs/2202.09372">S. Ebadi, et al.</a>).</p><p>Next, we create the time-dependent Hamiltonian and simulate its time evolution by using the <a href="../../../emulation/#BloqadeODE.SchrodingerProblem"><code>SchrodingerProblem</code></a> solver:</p><pre><code class="language-julia hljs">hamiltonian = rydberg_h(atoms; Ω = Ω, Δ = Δ)
prob = SchrodingerProblem(zero_state(nqubits(hamiltonian)), T_max, hamiltonian)
emulate!(prob)</code></pre><pre><code class="nohighlight hljs">SchrodingerProblem:
  register info:
    type: YaoArrayRegister.ArrayReg{2, ComplexF64, Matrix{ComplexF64}}
    storage size: 8 bytes

  time span (μs): (0.0, 0.6)

  equation: 
    storage size: 1.688 MiB
    expression:
nqubits: 13
+
├─ [+] ∑ 2π ⋅ 8.627e5.0/|x_i-x_j|^6 n_i n_j
├─ [+] Ω(t) ⋅ ∑ σ^x_i
└─ [-] Δ(t) ⋅ ∑ n_i


    algorithm: OrdinaryDiffEq.CompositeAlgorithm{Tuple{OrdinaryDiffEq.Vern9{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, OrdinaryDiffEq.Rodas5{0, false, Nothing, typeof(OrdinaryDiffEq.DEFAULT_PRECS), Val{:forward}, true, nothing}}, OrdinaryDiffEq.AutoSwitch{OrdinaryDiffEq.Vern9{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, OrdinaryDiffEq.Rodas5{0, false, Nothing, typeof(OrdinaryDiffEq.DEFAULT_PRECS), Val{:forward}, true, nothing}, Rational{Int64}, Int64}}((Vern9(stage_limiter! = trivial_limiter!, step_limiter! = trivial_limiter!, thread = static(false), lazy = true), OrdinaryDiffEq.Rodas5{0, false, Nothing, typeof(OrdinaryDiffEq.DEFAULT_PRECS), Val{:forward}, true, nothing}(nothing, OrdinaryDiffEq.DEFAULT_PRECS)), OrdinaryDiffEq.AutoSwitch{OrdinaryDiffEq.Vern9{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, OrdinaryDiffEq.Rodas5{0, false, Nothing, typeof(OrdinaryDiffEq.DEFAULT_PRECS), Val{:forward}, true, nothing}, Rational{Int64}, Int64}(Vern9(stage_limiter! = trivial_limiter!, step_limiter! = trivial_limiter!, thread = static(false), lazy = true), OrdinaryDiffEq.Rodas5{0, false, Nothing, typeof(OrdinaryDiffEq.DEFAULT_PRECS), Val{:forward}, true, nothing}(nothing, OrdinaryDiffEq.DEFAULT_PRECS), 10, 3, 9//10, 9//10, 2, false, 5))
  options:
    save_everystep: false
    save_start: false
    save_on: false
    dense: false
    reltol: 1.0e-10
    abstol: 1.0e-10
</code></pre><p>Finally, we can plot the most probable bitstrings by using the <a href="tutorials/5.MIS/@ref"><code>bitstring_hist</code></a> function on the resulting register (quantum state):</p><pre><code class="language-julia hljs">bitstring_hist(prob.reg; nlargest = 20)</code></pre><p><img src="../main-26.svg" alt/></p><p>We can see that some of the most probable configurations indeed have an independent set size 4 by counting the number of ones in the bitstring. The correctness of the output can be verified by comparing it to the classical solution:</p><pre><code class="language-julia hljs">best_bit_strings = most_probable(prob.reg, 2)
all_optimal_configs = GenericTensorNetworks.solve(IndependentSet(graph), ConfigsMax())[]
@assert all(bs -&gt; GenericTensorNetworks.StaticBitVector([bs...]) ∈ all_optimal_configs.c, best_bit_strings)</code></pre><p>We can also visualize these atoms and check them visually:</p><pre><code class="language-julia hljs">Bloqade.plot(atoms, blockade_radius = 7.5; colors = [iszero(b) ? &quot;white&quot; : &quot;red&quot; for b in best_bit_strings[1]])</code></pre><p><img src="../main-30.svg" alt/></p><pre><code class="language-julia hljs">Bloqade.plot(atoms, blockade_radius = 7.5; colors = [iszero(b) ? &quot;white&quot; : &quot;red&quot; for b in best_bit_strings[2]])</code></pre><p><img src="../main-31.svg" alt/></p><p>However, there are still some configurations that violate the blockade constraint, because the blockade interaction is not an ideal unit disk constraint (e.g. some bitstrings have a size 5). One can check whether the independence constraint is satisfied or not with the <a href="../../../mis/#BloqadeMIS.is_independent_set-Tuple{Any, Graphs.AbstractGraph}"><code>BloqadeMIS.is_independent_set</code></a> function:</p><pre><code class="language-julia hljs">best5_bit_strings = most_probable(prob.reg, 3)
BloqadeMIS.is_independent_set.(best5_bit_strings, Ref(graph))</code></pre><pre><code class="nohighlight hljs">3-element BitVector:
 1
 1
 0</code></pre><p>This can happen when the Rydberg interaction is not very strong at the unit disk radius. See the <a href="../../1.blockade/main/#blockade">Rydberg Blockade</a> page for more detailed explanations on Rydberg blockade and its relation with the unit disk radius. One can perform some postprocessing by reducing the violated configurations to indendendent set configurations using the <a href="../../../mis/#BloqadeMIS.mis_postprocessing-Tuple{Any, Graphs.AbstractGraph}"><code>mis_postprocessing</code></a> function. See the function documentation for more details on what it does. Please also refer to the paper <a href="https://arxiv.org/abs/2202.09372">S. Ebadi, et al.</a> for more detailed discussion on the postprocessing procedure.</p><pre><code class="language-julia hljs">fixed = mis_postprocessing(best5_bit_strings[3], graph)
BloqadeMIS.is_independent_set(fixed, graph)</code></pre><pre><code class="nohighlight hljs">true</code></pre><h2 id="QAOA-with-Piecewise-Constant-Pulses"><a class="docs-heading-anchor" href="#QAOA-with-Piecewise-Constant-Pulses">QAOA with Piecewise Constant Pulses</a><a id="QAOA-with-Piecewise-Constant-Pulses-1"></a><a class="docs-heading-anchor-permalink" href="#QAOA-with-Piecewise-Constant-Pulses" title="Permalink"></a></h2><p>The QAOA algorithm (<a href="https://arxiv.org/abs/1411.4028">arxiv:1411.4028</a>) is a hybrid quantum-classical algorithm. The classical part of the algorithm is an optimizer, which can be either a gradient-based or non-gradient-based one. For our specific problem, the corresponding quantum part is a neutral-atom quantum computer first evolving under the Rydberg Hamiltonian with parameterized pulse sequences and then being measured in the computational basis.</p><p>The standard definition of QAOA involves applying the problem (cost function) Hamiltonian <span>$C$</span> and the transverse field Hamiltonian <span>$B$</span> alternately. Let <span>$G=(V,E)$</span> be a graph. The cost Hamiltonian for an MIS problem can be defined as</p><p class="math-container">\[C(G) = -\sum_{j\in V}^{n} w_j n_j^z + \infty \sum_{\langle j,k\rangle \in E}n_j^z n_k^z\]</p><p>where the first summation is proportional to the size of the independent set, and the second term enforces the independence constraints.</p><p>In a Rydberg Hamiltonian, the first term corresponds to the detuning <span>$w_i = \Delta$</span>. The second term contains an <span>$\infty$</span>, which corresponds to the Rydberg blockade term with its strength described as <span>$V_{jk} = C_6/|\mathbf{x}_j - \mathbf{x}_k|^6$</span>. As we can see, the Rydberg interaction is not a perfect independence constraint (with finite blockade interaction and unwanted long-rance interaction). Thus, postprocessing might be required using neutral-atom quantum computers to solve the MIS problem.</p><p>The transverse field Hamiltonian corresponds to the Rabi term in the Rydberg Hamiltonian,</p><p class="math-container">\[B = \sum_{j=1}^{n}\sigma_j^x + \infty \sum_{\langle j,k\rangle \in E}n_j^z n_k^z.\]</p><p>Note that the Rybderg interaction term is always on here in contrast to the standard QAOA protocol. For the convenience of the simulation, we use the <a href="../../../registers/#YaoAPI.expect"><code>expect</code></a> function to get the averaged measurement outputs. On the actual quantum hardware, the <code>expect</code> should be replaced by measuring in the computational basis and obtaining the averaged number of Rydberg excitations as the loss function (also called objective function or cost function). One can then either use non-gradient-based optimizers to perform the optimization or use finite-difference methods to obtain gradients of parameters.</p><p>Let us first set up a non-optimized pulse sequences for QAOA with step <span>$p=3$</span>:</p><pre><code class="language-julia hljs">durations = fill(0.1, 6)
clocks = [0, cumsum(durations)...]
Ω2 = piecewise_constant(; clocks = clocks, values = repeat([Ω_max, 0.0], 3))
Δ2 = piecewise_constant(; clocks = clocks, values = repeat([0.0, Δ_end], 3))

fig, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (12, 4))
Bloqade.plot!(ax1, Ω2)
ax1.set_ylabel(&quot;Ω/2π (MHz)&quot;)
Bloqade.plot!(ax2, Δ2)
ax2.set_ylabel(&quot;Δ/2π (MHz)&quot;)
fig</code></pre><p><img src="../main-41.svg" alt/></p><p>The <code>piecewise_constant</code> pulses can be more accurately simulated with the <a href="../../../emulation/#BloqadeKrylov.KrylovEvolution"><code>KrylovEvolution</code></a> solver. This time, we simulate the dynamics in the subspace generated by the <a href="../../../subspace/#BloqadeMIS.blockade_subspace"><code>blockade_subspace</code></a> function, so that we do not need postprocessing anymore.</p><pre><code class="language-julia hljs">hamiltonian2 = rydberg_h(atoms; Ω = Ω2, Δ = Δ2)
nsites = length(atoms)
subspace = blockade_subspace(atoms, 7.5)  # we run our simulation within the blockade subspace
prob2 = KrylovEvolution(zero_state(subspace), clocks, hamiltonian2)
emulate!(prob2);</code></pre><p>We defined the loss function as the negative of the mean MIS size, which corresponds to the expectation value of the <a href="../../../hamiltonians/#BloqadeExpr.SumOfN"><code>SumOfN</code></a> operator. Thus, we can calculate the</p><p>average loss function after the time evolution:</p><pre><code class="language-julia hljs">loss_MIS(reg) = -rydberg_density_sum(prob2.reg)
loss_MIS(prob2.reg)</code></pre><pre><code class="nohighlight hljs">-2.5628869128026843</code></pre><p>The ouput shows the negative mean independent set size. This is because we have flipped its sign since most optimizers are set to minimize the loss function. This loss is equivalent to the <a href="../../../mis/#BloqadeMIS.rydberg_density_sum"><code>rydberg_density_sum</code></a> loss function in the <a href="tutorials/5.MIS/@ref"><code>BloqadeMIS</code></a> module. Alternative loss functions include the <a href="../../../mis/#BloqadeMIS.gibbs_loss-Tuple{Any, Real}"><code>gibbs_loss</code></a> and the <a href="../../../mis/#BloqadeMIS.independent_set_probabilities"><code>independent_set_probabilities</code></a>.</p><p>Here, the loss produced by these pulse sequences does not look very good. We can throw it into an optimizer and see if a classical optimizer can help. First, let us wrap up the above code into a loss function:</p><pre><code class="language-julia hljs">function loss_piecewise_constant(atoms::AtomList, x::AbstractVector{T}) where {T}
    @assert length(x) % 2 == 0
    Ω_max = 4 * 2π
    Δ_end = 11 * 2π
    p = length(x) ÷ 2

    # detuning and rabi terms
    durations = abs.(x)   # the durations of each layer of the QAOA pulse take the optimizing vector x as their input
    clocks = [0, cumsum(durations)...]
    Ωs = piecewise_constant(; clocks = clocks, values = repeat(T[Ω_max, 0.0], p))
    Δs = piecewise_constant(; clocks = clocks, values = repeat(T[0.0, Δ_end], p))

    hamiltonian = rydberg_h(atoms; Ω = Ωs, Δ = Δs)
    subspace = blockade_subspace(atoms, 7.5)  # we run our simulation within the blockade subspace
    prob = KrylovEvolution(zero_state(Complex{T}, subspace), clocks, hamiltonian)
    emulate!(prob)
    return -rydberg_density_sum(prob.reg), prob.reg
end</code></pre><pre><code class="nohighlight hljs">loss_piecewise_constant (generic function with 1 method)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Running the simulation in the subspace does not violate the independence constraints. If one uses fullspace simulation or runs it on the quantum computer, one may need to post-process the measured bit strings to a get a correct measure of the loss, if we don&#39;t set the blockade constraint. Related APIs include <a href="../../../mis/#BloqadeMIS.is_independent_set-Tuple{Any, Graphs.AbstractGraph}"><code>is_independent_set</code></a>, <a href="tutorials/5.MIS/@ref"><code>num_mis_violation</code></a>, and <a href="../../../mis/#BloqadeMIS.mis_postprocessing-Tuple{Any, Graphs.AbstractGraph}"><code>mis_postprocessing</code></a>.</p></div></div><p>Let us check the loss function again using the initial point above:</p><pre><code class="language-julia hljs">x0 = durations
rydberg_density, reg1 = loss_piecewise_constant(atoms, x0)
rydberg_density</code></pre><pre><code class="nohighlight hljs">-2.5628869128026843</code></pre><p>The most probable bitstrings are:</p><pre><code class="language-julia hljs">bitstring_hist(reg1; nlargest = 20)</code></pre><p><img src="../main-54.svg" alt/></p><p>We see that, without optimization, many of these bitstrings are not the MIS solutions.</p><p>Let us now use the non-gradient-based optimizer <code>NelderMead</code> in the <code>Optim</code> package to optimize the loss function:</p><pre><code class="language-julia hljs">optresult = Optim.optimize(x -&gt; loss_piecewise_constant(atoms, x)[1], x0)

rydberg_density_final, reg1_final = loss_piecewise_constant(atoms, optresult.minimizer)
rydberg_density_final</code></pre><pre><code class="nohighlight hljs">-3.0965910260012213</code></pre><p>We see that the loss is indeed improved, but still not very good. This is likely because the optimization is trapped in a local minimum.</p><pre><code class="language-julia hljs">bitstring_hist(reg1_final; nlargest = 20)</code></pre><p><img src="../main-59.svg" alt/></p><p>This example shows that the performance of the algorithm very much depends on the parametrization of the pulse sequences, the initialization of the variational parameters, and the classical optimizers. See <a href="https://arxiv.org/abs/2202.09372">S. Ebadi, et al.</a> for more in-depth comparison of different pulse parametrizations and tips on how to improve the performance.</p><p>In the example below, we show a better pulse parametrization using smoothened piecewise linear waveforms.</p><h2 id="Smoothened-Piecewise-Linear-Pulses"><a class="docs-heading-anchor" href="#Smoothened-Piecewise-Linear-Pulses">Smoothened Piecewise Linear Pulses</a><a id="Smoothened-Piecewise-Linear-Pulses-1"></a><a class="docs-heading-anchor-permalink" href="#Smoothened-Piecewise-Linear-Pulses" title="Permalink"></a></h2><p>A smoothened piecewise linear waveform can be created by applying a Gaussian filter on a waveform created by the <code>piecewise_linear</code> function. For example:</p><pre><code class="language-julia hljs">pulse_piecewise_linear = piecewise_linear(clocks = [0.0, 0.05, 0.1, 0.5, 0.55, T_max], values = [0, 0, 0.4, 0.4, 0, 0]);
pulse_smooth = smooth(pulse_piecewise_linear; kernel_radius = 0.02);

fig, ax = plt.subplots()
Bloqade.plot!(ax, pulse_piecewise_linear)
Bloqade.plot!(ax, pulse_smooth)
ax.set_ylabel(&quot;strength&quot;)
ax.legend([&quot;piecewise linear&quot;, &quot;smoothened piecewise linear&quot;], loc = &quot;lower right&quot;)
fig</code></pre><p><img src="../main-64.svg" alt/></p><p>Here, the function <a href="../../../waveform/#BloqadeWaveforms.smooth"><code>smooth</code></a> takes a <code>kernel_radius</code> keyword parameter as the Gaussian kernel parameter. With the new waveforms, we can define the loss function as follows:</p><pre><code class="language-julia hljs">function loss_piecewise_linear(atoms::AtomList, x::AbstractVector{T}) where {T}
    @assert length(x) == 3
    Ω_max = 4 * 2π
    Δ_start = -13 * 2π
    Δ_end = 11 * 2π
    Δ0 = 11 * 2π
    T_max = 0.6

    # the strength of the detunings at each step takes the optimizing x as their input
    Δs = smooth(
        piecewise_linear(
            clocks = T[0.0, 0.05, 0.2, 0.3, 0.4, 0.55, T_max],
            values = T[Δ_start, Δ_start, Δ0*x[1], Δ0*x[2], Δ0*x[3], Δ_end, Δ_end],
        );
        kernel_radius = 0.02,
    )
    Ωs = smooth(
        piecewise_linear(clocks = T[0.0, 0.05, 0.1, 0.5, 0.55, T_max], values = T[0, 0, Ω_max, Ω_max, 0, 0]);
        kernel_radius = 0.02,
    )

    hamiltonian = rydberg_h(atoms; Ω = Ωs, Δ = Δs)
    subspace = blockade_subspace(atoms, 7.5)
    prob = SchrodingerProblem(zero_state(Complex{T}, subspace), T_max, hamiltonian)
    emulate!(prob)
    return -rydberg_density_sum(prob.reg), prob.reg, Δs
end

x0 = [0.1, 0.8, 0.8]; # initial point for the optimization</code></pre><p>Let us check the loss function with smoothened waveform with the initial point:</p><pre><code class="language-julia hljs">Δ_start = -13 * 2π
Δ_end = 11 * 2π
Δ0 = 11 * 2π
T_max = 0.6
Δ_initial = piecewise_linear(
    clocks = [0.0, 0.05, 0.2, 0.3, 0.4, 0.55, T_max],
    values = [Δ_start, Δ_start, Δ0 * x0[1], Δ0 * x0[2], Δ0 * x0[3], Δ_end, Δ_end],
)

rydberg_density, reg2, Δ_initial_smooth = loss_piecewise_linear(atoms, x0)
rydberg_density</code></pre><pre><code class="nohighlight hljs">-3.8903850811122664</code></pre><p>And plot the smoothened waveform:</p><pre><code class="language-julia hljs">fig, ax = plt.subplots()
Bloqade.plot!(ax, Δ_initial)
Bloqade.plot!(ax, Δ_initial_smooth)
ax.set_ylabel(&quot;Δ/2π (MHz)&quot;)
ax.legend([&quot;piecewise linear&quot;, &quot;smoothened piecewise linear&quot;], loc = &quot;lower right&quot;)
fig</code></pre><p><img src="../main-70.svg" alt/></p><p>Let&#39;s plot the distribution:</p><pre><code class="language-julia hljs">bitstring_hist(reg2; nlargest = 20)</code></pre><p><img src="../main-72.svg" alt/></p><p>The performance of the algorithm is quite good. Again, let us use the <code>NelderMead</code> optimizer to optimize the loss function:</p><pre><code class="language-julia hljs">optresult = Optim.optimize(x -&gt; loss_piecewise_linear(atoms, x)[1], x0)

rydberg_density_final, reg_final, Δ_final = loss_piecewise_linear(atoms, optresult.minimizer)
rydberg_density_final</code></pre><pre><code class="nohighlight hljs">-3.9748273474395703</code></pre><p>One can see the mean MIS size can be further improved to a value close to the size of the MIS, which means there is a substantial probability for measuring an MIS state.</p><pre><code class="language-julia hljs">bitstring_hist(reg_final; nlargest = 20)</code></pre><p><img src="../main-76.svg" alt/></p><p>We can also plot out the final optimized waveform for Δ and compare with the initial waveform:</p><pre><code class="language-julia hljs">fig, ax = plt.subplots()
Bloqade.plot!(ax, Δ_initial_smooth)
Bloqade.plot!(ax, Δ_final)
ax.set_ylabel(&quot;Δ/2π (MHz)&quot;)
ax.legend([&quot;initial&quot;, &quot;optimized&quot;], loc = &quot;lower right&quot;)
fig</code></pre><p><img src="../main-78.svg" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../4.LGT/main/">« Simulation of lattice gauge theory with Rydberg atoms</a><a class="docs-footer-nextpage" href="../../6.MWIS/main/">Maximum Weight Independent Set »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 28 January 2023 16:50">Saturday 28 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
