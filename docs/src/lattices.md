# Lattices

With Bloqade, we are going to be simulating the quantum evolution of information stored in neutral atoms. Present-day experimental platforms allow distribution of atoms in an organized lattice structure and even in  arbitrary shapes.
This makes neutral atom a natural setup for quantum simulation of statistical models and quantum matter. With Bloqade, we support several built-in lattice structure and allow the users to specify atom positions by inputing coordinates.


## Lattice types

A crystal lattice is completely determined by a set of Bravais lattice vectors (in unit of ``\mu m``) plus atom locations in a unit cell.
A [Bravais lattice](https://en.wikipedia.org/wiki/Bravais_lattice) is an infinite array of decrete points generated by a set of discrete translation operations described by
```math
\mathbf{R} = n_1 \mathbf{a}_1 + n_2 \mathbf{a}_2 + \ldots + n_d \mathbf{a}_d
```
where ``d`` is the dimension of space, ``n_1, \ldots, n_d \in Z`` are integers.
The unit cell of a Bravais lattice is defined by specifing its lattice vectors ``(\mathbf{a}_1, \mathbf{a}_2, \ldots, \mathbf{a}_d)``.
To create a simple lattice, we just place one site at location `(0.0, 0.0)` in a unit cell. For example, to create a triangular lattice, we can specify its lattice vector to be `(1.0, 0.0)` and `(0.5, 0.5*sqrt(3))`.

```@repl quick-start
using Bloqade
triangular = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))], [(0.0, 0.0)])
```

For composite lattices, one should provide multiple sites as the second argument to specify their locations in a unitcell. For example, the honeycomb lattice can be defined by typing
```@repl quick-start
honeycomb = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))],
    [(0.0, 0.0), (0.5, 0.5/sqrt(3))])
```


We provide a few shorthands for several useful lattices, inlucding the [`ChainLattice`](@ref), [`SquareLattice`](@ref), [`HoneycombLattice`](@ref), [`TriangularLattice`](@ref), [`LiebLattice`](@ref), and [`KagomeLattice`](@ref) shown below. 
One can use [`lattice_vectors`](@ref) and [`lattice_sites`](@ref) to access the lattice vectors and sites locations in a unit cell as described in the above section.

##### [`ChainLattice`](@ref)
```@example quick-start
using Bloqade
chain = ChainLattice()
```

```@example quick-start
img_atoms(generate_sites(chain, 10))
```

!!! note
    You can see the above visulization in one of the following editors
    * a [VSCode](https://github.com/julia-vscode/julia-vscode) editor,
    * a [Jupyter](https://github.com/JunoLab/Juno.jl) notebook,
    * or a [Pluto](https://github.com/fonsp/Pluto.jl) notebook,
    
    But not in a Julia REPL that does not have a graphical display.
    

```@example quick-start
lattice_vectors(chain)
```

```@example quick-start
lattice_sites(chain)
```


##### [`SquareLattice`](@ref)
```@example quick-start
square = SquareLattice()
img_atoms(generate_sites(square, 10, 10))
```

Note that the index showing on sites are consistent with the index of qubits for performing computation. 
In other words, if we want to do measurment or apply opearations on individual sites (qubits), we can refer the numbering on atoms for convienience. 
For more details about how to generate Hamiltonian by using lattice as an argument, please see the section [Hamiltonians](@ref).

```@example quick-start
lattice_vectors(square)
```
```@example quick-start
lattice_sites(square)
```

##### [`HoneycombLattice`](@ref)
```@example quick-start
honeycomb = HoneycombLattice()
img_atoms(generate_sites(honeycomb, 5, 5))
```



##### [`TriangularLattice`](@ref)
```@example quick-start
triangular = TriangularLattice()
img_atoms(generate_sites(triangular, 8, 8))
```


##### [`LiebLattice`](@ref)
```@example quick-start
lieb = LiebLattice()
img_atoms(generate_sites(lieb, 5, 5))
```


##### [`KagomeLattice`](@ref)
```@example quick-start
kagome = KagomeLattice()
img_atoms(generate_sites(kagome, 5, 5))
```


## Generate and sort sites

Once we have defined certain lattice shapes (which have fixed lattice vectors and site positions), we can generate the atom positons by 
specifying the number of atoms and the scale size of the lattice. 
This is done by using the function [`generate_sites`](@ref) , which will return a [`AtomList`](@ref) instance containing the coordinates for each atoms. e.g.  

```@example quick-start
atoms = generate_sites(HoneycombLattice(), 3, 5; scale=4.5)
```
where `scale` defines the unit distance in experimental unit (``\mu m``) of the lattice, and `3, 5` specifies the repetitions of unit cells in each lattice vector direction.  

We also support different operations for the generated lattices. For instance,  one can apply predefined filters, e.g. [`rescale_axes`](@ref), [`clip_axes`](@ref), [`offset_axes`](@ref), to manipulate atom locations.

```@example quick-start
rescale_axes(atoms, 0.8)
```
where the above operation rescales the coordinates of original `sites` by a factor of `0.8`. 

The code below restricts the atoms sitting in window `(0.0, 5.0), (0.0, 6.0)` and throw aways those outside this regime. 

```@example quick-start
clip_axes(atoms, (0.0, 5.0), (0.0, 6.0))
```

Further, we can shift the origin of `atoms` by some vector `(5.0, 5.0)` simply by typing the code

```@example quick-start
offset_axes(atoms, 5.0, 5.0)
```


To sort the atoms by the their x-coordinates, one can convert these locations to a [`MaskedGrid`](@ref) representation of the atoms.
```@example quick-start
atoms_in_grid = make_grid(atoms)
```

Then one can get the sorted atoms by typing
```@example quick-start
sorted_atoms = collect_atoms(atoms_in_grid)
```

Note that the sorting has changed the index numbering of atoms. 



## User-determined arbitrary lattices

One can also generate atoms located at arbitray positions by directly inputing the atoms' coordinates  
```@repl quick-start
atom_coordinate = AtomList([(0.0, 0.0), (0, 5), (0, 8), (5, 2), (6, 7), (9, 6)])
```

## Query neighbors

One can use [`make_kdtree`](@ref) to generate a [k-d tree](https://en.wikipedia.org/wiki/K-d_tree) data type for efficient querying neighborhoods in low dimensional space.
```@example quick-start
tree = make_kdtree(sorted_atoms)
```

The return value is a `KDTree` instance, which is defined in package [`NearestNeigbors`](https://github.com/KristofferC/NearestNeighbors.jl). One can use it to query the neighbors of an atom, e.g. one can find the 20 nearest neighbors of the 5-th site by typing
```@example quick-start
neighbors = grouped_nearest(tree, 5, 20)
```

The return value is a [`DistanceGroup`](@ref) instance, and the indices of second nearest neighbors are
```@example quick-start
neighbors[2]
```

One can select and display these atoms with correct labeling by typing
```@example quick-start
img_atoms(sorted_atoms[neighbors[2]]; texts=string.(neighbors[2]))
```

It show the correct second nearest neigbors of site 5.
One can check the docstring of [`img_atoms`](@ref) to know more about how to custom lattice visualization.

## References

```@autodocs
Modules = [BloqadeLattices]
```
