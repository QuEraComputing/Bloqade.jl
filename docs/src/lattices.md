# Lattices

## Create a lattice

Creating a lattice is very simple in EaRyd, e.g we can create a square lattice as following

```@repl quick-start
using EaRyd
generate_sites(SquareLattice(), 3, 3)
```

this generates the atom positions on a ``3\times 3`` square lattice using the [`generate_sites`](@ref) function.

we support the following built-in lattice: [`SquareLattice`](@ref), [`KagomeLattice`](@ref), [`HoneycombLattice`](@ref), and more. Please refer to [Lattices](@ref) for more detailed guide of lattice related operation.

## Lattice types

A crystal lattice is completely determined by a set of Bravais lattice vectors (in unit of ``\mu m``) plus atom locations in a unit cell.
A [Bravais lattice](https://en.wikipedia.org/wiki/Bravais_lattice) is an infinite array of decrete points generated by a set of discrete translation operations described by
```math
\mathbf{R} = n_1 \mathbf{a}_1 + n_2 \mathbf{a}_2 + \ldots + n_d \mathbf{a}_d
```
where ``d`` is the dimension of space, ``n_1, \ldots, n_d \in Z`` are integers.
The unit cell of a Bravais lattice is defined by specifing its lattice vectors ``(\mathbf{a}_1, \mathbf{a}_2, \ldots, \mathbf{a}_d)``.
To create a simple lattice, we just place one atom at location `(0.0, 0.0)` in a unit cell. The following code defines a triangular lattice.

```@repl quick-start
triangular = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))], [(0.0, 0.0)])
```

!!! note
    You can see the above visulization in one of the following editors
    * a [VSCode](https://github.com/julia-vscode/julia-vscode) editor,
    * a [Jupyter](https://github.com/JunoLab/Juno.jl) notebook,
    * or a [Pluto](https://github.com/fonsp/Pluto.jl) notebook,
    
    But not in a Julia REPL that does not have a graphical display.
    

For composite lattices, one should provide multiple atoms as the second argument to specify atom locations in a unitcell. For example, the honeycomb lattice can be defined by typing
```@repl quick-start
honeycomb = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))],
    [(0.0, 0.0), (0.5, 0.5/sqrt(3))])
```

We provide a few shorthands for several useful lattices.
One can use [`lattice_vectors`](@ref) and [`lattice_sites`](@ref) to access the lattice vectors and atom locations in a unit cell as described in the above section.

##### [`ChainLattice`](@ref)
```@example quick-start
using EaRyd

chain = ChainLattice()
```

```@example quick-start
lattice_vectors(chain)
```

```@example quick-start
lattice_sites(chain)
```

##### [`SquareLattice`](@ref)
```@example quick-start
square = SquareLattice()
```

```@example quick-start
lattice_vectors(square)
```

```@example quick-start
lattice_sites(square)
```

```@example quick-start
generate_sites(square, 5, 5)
```

##### [`RectangularLattice`](@ref)
```@example quick-start
rectangle = RectangularLattice(0.5)
```

```@example quick-start
lattice_vectors(rectangle)
```

```@example quick-start
lattice_sites(rectangle)
```

```@example quick-start
generate_sites(rectangle, 5, 5)
```

##### [`HoneycombLattice`](@ref)
```@example quick-start
honeycomb = HoneycombLattice()
```

```@example quick-start
lattice_vectors(honeycomb)
```

```@example quick-start
lattice_sites(honeycomb)
```

##### [`TriangularLattice`](@ref)
```@example quick-start
triangular = TriangularLattice()
```

```@example quick-start
lattice_vectors(triangular)
```

```@example quick-start
lattice_sites(triangular)
```

##### [`LiebLattice`](@ref)
```@example quick-start
lieb = LiebLattice()
```

```@example quick-start
lattice_vectors(lieb)
```

```@example quick-start
lattice_sites(lieb)
```

##### [`KagomeLattice`](@ref)
```@example quick-start
kagome = KagomeLattice()
```

```@example quick-start
lattice_vectors(kagome)
```

```@example quick-start
lattice_sites(kagome)
```

## Generate and sort sites
One can generate atom locations using the [`generate_sites`](@ref) API.
It will return a [`AtomList`](@ref) instance.

```@example quick-start
atoms = generate_sites(HoneycombLattice(), 3, 5; scale=4.5)
```
where `scale` defines the unit distance (in ``\mu m``) of the lattice.
One can apply predefined filters, e.g. [`rescale_axes`](@ref), [`clip_axes`](@ref), [`offset_axes`](@ref), to manipulate atom locations.

```@example quick-start
rescale_axes(atoms, 0.8)
```

```@example quick-start
clip_axes(atoms, (0.0, 5.0), (0.0, 6.0))
```

```@example quick-start
offset_axes(atoms, 5.0, 5.0)
```

To sort the atoms by the their x-coordinates, one can convert these locations to a [`MaskedGrid`](@ref) representation of the atoms.
```@example quick-start
atoms_in_grid = make_grid(atoms)
```

Then one can get the sorted atoms by typing
```@example quick-start
sorted_atoms = collect_atoms(atoms_in_grid)
```

## Query neighbors

One can use [`make_kdtree`](@ref) to generate a [k-d tree](https://en.wikipedia.org/wiki/K-d_tree) data type for efficient querying neighborhoods in low dimensional space.
```@example quick-start
tree = make_kdtree(sorted_atoms)
```

The return value is a `KDTree` instance, which is defined in package [`NearestNeigbors`](https://github.com/KristofferC/NearestNeighbors.jl). One can use it to query the neighbors of an atom, e.g. one can find the 20 nearest neighbors of the 5-th site by typing
```@example quick-start
neighbors = grouped_nearest(tree, 5, 20)
```

The return value is a [`DistanceGroup`](@ref) instance, and the indices of second nearest neighbors are
```@example quick-start
neighbors[2]
```

One can select and display these atoms with correct labeling by typing
```@example quick-start
img_atoms(sorted_atoms[neighbors[2]]; texts=string.(neighbors[2]))
```

It show the correct second nearest neigbors of site 5.
One can check the docstring of [`img_atoms`](@ref) to know more about how to custom lattice visualization.
