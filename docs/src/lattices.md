# Lattices

## Create a lattice


With EaRyd, we are going to be simulating the quantum evolution of information stored in neutral atoms. While present-day experimental platforms allow distribution of atoms in arbitrary shapes, most often those come in the shape of an organized lattice structure. This is also the natural setup for quantum simulation of statistical models and quantum matter. To get started with EaRyd, you have to decide on the very architecture you want your quantum processor to have!


Creating a lattice is very simple in EaRyd, e.g we can create a square lattice as following

```@repl quick-start
using EaRyd
generate_sites(SquareLattice(), 3, 3)
```

this generates the atom positions on a ``3\times 3`` square lattice using the [`generate_sites`](@ref) function.

we support the following built-in lattice: [`SquareLattice`](@ref), [`KagomeLattice`](@ref), [`HoneycombLattice`](@ref), and more. Please refer to [Lattices](@ref) for more detailed guide of lattice related operation.

## Lattice types

A crystal lattice is completely determined by a set of Bravais lattice vectors (in unit of ``\mu m``) plus atom locations in a unit cell.
A [Bravais lattice](https://en.wikipedia.org/wiki/Bravais_lattice) is an infinite array of decrete points generated by a set of discrete translation operations described by
```math
\mathbf{R} = n_1 \mathbf{a}_1 + n_2 \mathbf{a}_2 + \ldots + n_d a_d
```
where ``d`` is the dimension of space, ``n_1, \ldots, n_d \in Z`` are integers.

Hence the lattice vectors ``(\mathbf{a}_1, \mathbf{a}_2, \ldots, \mathbf{a}_n)`` defines a Bravais lattice.
To create a simple lattice, we just place one atom at location `(0.0, 0.0)` in a unit cell. The following code defines a triangular lattice.

```@repl quick-start
triangular_manual = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))], [(0.0, 0.0)])
```

!!! note
    You can see the above visulization in one of the following editors
    * a [VSCode](https://github.com/julia-vscode/julia-vscode) editor,
    * a [Jupyter](https://github.com/JunoLab/Juno.jl) notebook,
    * or a [Pluto](https://github.com/fonsp/Pluto.jl) notebook,
    
    But not in a Julia REPL that does not have a graphical display.
    

For composite lattices, one should provide multiple atoms as the second argument to specify atom locations in a unitcell. For example, the honeycomb lattice can be defined by typing
```@repl quick-start
honeycomb_manual = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))], [(0.0, 0.0), (0.5, 0.5/sqrt(3))])
```

We provide a few shorthands for several useful lattices.
One can use [`lattice_vectors`](@ref) and [`lattice_sites`](@ref) to access the lattice vectors and atom locations in a unit cell as described in the above section.

##### [`ChainLattice`](@ref)
```@repl quick-start
chain = ChainLattice()
```

```@repl quick-start
lattice_vectors(chain)
```

```@repl quick-start
lattice_sites(chain)
```

```@repl quick-start
img_atoms(chain)
```

##### [`SquareLattice`](@ref)
```@repl quick-start
square = SquareLattice()
```

```@repl quick-start
lattice_vectors(square)
```

```@repl quick-start
lattice_sites(square)
```

```@repl quick-start
img_atoms(square)
```

##### [`RectangularLattice`](@ref)
```@repl quick-start
rectangle = RectangularLattice(0.5)
```

```@repl quick-start
lattice_vectors(rectangle)
```

```@repl quick-start
lattice_sites(rectangle)
```

```@repl quick-start
img_atoms(rectangle)
```

##### [`HoneycombLattice`](@ref)
```@repl quick-start
honeycomb = HoneycombLattice()
```

```@repl quick-start
lattice_vectors(honeycomb)
```

```@repl quick-start
lattice_sites(honeycomb)
```

```@repl quick-start
img_atoms(honeycomb)
```

##### [`TriangularLattice`](@ref)
```@repl quick-start
triangular = TriangularLattice()
```

```@repl quick-start
lattice_vectors(triangular)
```

```@repl quick-start
lattice_sites(triangular)
```

```@repl quick-start
img_atoms(triangular)
```

##### [`LiebLattice`](@ref)
```@repl quick-start
lieb = LiebLattice()
```

```@repl quick-start
lattice_vectors(lieb)
```

```@repl quick-start
lattice_sites(lieb)
```

```@repl quick-start
img_atoms(lieb)
```

##### [`KagomeLattice`](ref)
```@repl quick-start
kagome = KagomeLattice()
```

```@repl quick-start
lattice_vectors(kagome)
```

```@repl quick-start
lattice_sites(kagome)
```

```@repl quick-start
img_atoms(kagome)
```

## Generate sites and sorting
```@repl quick-start
atoms = generate_sites(Honeycomb(), 3, 5; scale=4.5)
```
where `scale` defines the unit distance (in ``\mu m``) of the lattice.
The return value is a `AtomList` instance.
One can apply predefined filters to it, including

```@repl quick-start
scale_axes(atoms, 0.8)
```

```@repl quick-start
clip_axes(atoms, (0.0, 5.0), (0.0, 6.0))
```

```@repl quick-start
offset_axes(atoms, 5.0, 5.0)
```

To sort the atoms by the x-axis, one can convert these locations to a [`MaskedGrid`](@ref) representation of the atoms.
```@repl quick-start
atoms_in_grid = make_grid(atoms)
```

Then one can get the sorted atoms by typing
```@repl quick-start
sorted_atoms = collect_atoms(atoms_in_grid)
```

## User-determined arbitrary lattices

One can also generate atoms located by arbitray positions by directly inputing the atoms' coordinates  
```@repl quick-start
atom_coordinate = [(0.0, 0.0), (0, 5), (0, 8), (5, 2), (6, 7), (9, 6)]
'''

## Query neighbors

One can use [`make_kdtree`](@ref) to generate a [k-d tree](https://en.wikipedia.org/wiki/K-d_tree) data type for efficient querying neighborhoods in low dimensional space.
```@repl quick-start
tree = make_kdtree(sorted_atoms)
```

The return value is a [`KDTree`](@ref) instance, which is defined in package [`NearestNeigbors`](https://github.com/KristofferC/NearestNeighbors.jl). One can use it to query the neighbors of an atom, e.g. one can find the 20 nearest neighbors of the 5-th site by typing
```@repl quick-start
neighbors = grouped_nearest(tree, 5, 20)
```

The return value is a [`DistanceGroup`](@ref) instance, and the indices of second nearest neighbors are
```@repl quick-start
neighbors[2]
```

One can select and display these atoms out by typing
```@repl quick-start
img_atoms(sorted_atoms[neighbors[2]]; texts=string.(neighbors[2]))
```

It show the correct second nearest neigbors of site 5.
