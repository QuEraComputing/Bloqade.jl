# # Background

# In this example, we will show how to use the Emulator to prepare ordered ground states in Rydberg systems. 
# The example is based on experimental works in [1D system](https://www.nature.com/articles/nature24622), and [2D system](https://www.nature.com/articles/s41586-021-03582-4). 

# Due to the strong Rydberg interactions, only one Rydberg excitation is allowed within the so-called blocakde radius [Blockade](@ref). With positive detunings, more Rydberg excitations, however, 
# are favored to lower the energies of the ground states. With the interplay of these two mechanisms, different ordered states are supported depending on the strength of blockade radius and the detuning.
# For example, in 1D there exists the [``Z_N`` ordered states](https://www.nature.com/articles/nature24622), and in 2D there are the checkboard phase, star phase, and even pure quantum phase ([straited phase](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.124.103601)). 

# The adibatic process works as follows: One starts from all the atoms being in the ground state, which is also the ground states of many-body Hamiltonian with large negative detuning. Then the Rabi freuency ``\Omega`` is turned on, and the detuning strength is 
# ramped up from large negative value to postive values. If such process is slow enough, the quantum state  the system stays close to the ground state of the instantaneous Hamiltonian. At the end of the process, 
# one arrives a target Hamiltonian, and correspondingly, the prepared state is approximately the ground state for the final Hamiltonian.  


# We start by importing required libraries

using EaRyd
using CairoMakie
using EaRydPlots
using KrylovKit
using SparseArrays

# # Ground state properties

# To get a sense of the quantum phase transition, let us first calculate the ground states' properties for Hamiltonians with different parameters. 
# We will focus on ground state of 1D chain for simplicity. We consider a chain with 9 atoms, where nearby atoms are seperated by a distance of 5.72 ``\mu m``. 
# Such a system is generated by the following codes 

nsites = 9
atoms = generate_sites(ChainLattice(), nsites, scale=5.72)

# We fix the Rabi frequency to be ``Ω = 2π * 4``, and study the ground state as a function of detuning ``Δ``. 

Ω = 2π * 4
Δ_step = 30
Δ = LinRange(-10*2π , 10*2π , Δ_step)

# We compute the Rydberg density profile for each parameter of ``\Delta``. 

density_g = zeros(Δ_step, nsites)

for ii=1: Δ_step

    h_ii = rydberg_h(atoms; Δ=Δ[ii], Ω)
    h_m = SparseMatrixCSC(h_ii)
    vals, vecs, info = KrylovKit.eigsolve(h_m,  1, :SR)
    g_state = ArrayReg(vecs[1]) 

    for jj in 1:nsites
        density_g[ii, jj] = real(expect(put(nsites, jj=>Op.n), g_state))
    end

end

# To compare, we first plot the density profile when ``\Delta= -10*2π``, 

lines(1:nsites, density_g[1, :])

# We can see that the Rydberg densities in this case is close to 0 for all sites. In contrast, for ``\Delta= -10*2π``, the density shows clear ``Z_2`` ordered profile 
lines(1:nsites, density_g[20, :])

# More generally, we can plot an order parameter as a function of ``\Delta`` to clearly see the onset of phase transition. Such a parameter is defined by the difference of
# Rydberg densities in even and odd sites. 

order_para = map(1: Δ_step) do ii

    sum(density_g[ii, 1:2:8])-  sum(density_g[ii, 2:2:8])

end


lines(collect(Δ)/2π, order_para)

# From the density profile of ground states and the change of order parameter, we are convinced that there is indeed a phase transition taking place during the change of ``\Delta``. 
# Below we show that by slowly changing the parameters in the Hamiltonian, we can follow the trajectory of the ground states and adibatically evolve from all atoms being in state `0` to the ``Z_2`` 
# ordered state.  



# # Ordered state prepration in 1D 

# We first specify the adiabatic pulse sequence for Rabi frequency by using the built-in waveform function [`piecewise_linear`](@ref)

total_time = 3.0
Ω_max = 2π * 4
Ω = piecewise_linear(clocks=[0.0, 0.1, 2.1, 2.2, total_time], values=[0.0, Ω_max, Ω_max, 0, 0])
draw(Ω)


#Δ1 = piecewise_linear(clocks=[0.0, 0.6, 2.1, 3], values=[-10*2π, -10*2π, 10*2π, 10* 2π])


# The detuning sequence could also be created in a similar way
U1 = -2π * 10
U2 = 2π * 10
Δ = piecewise_linear(clocks=[0.0, 0.6, 2.1, total_time], values=[U1, U1, U2, U2])
draw(Δ)

# We then generate the positions of a 1D atomic chain by using the function [`generate_sites`](@ref) 

nsites = 9
atoms = generate_sites(ChainLattice(), nsites, scale=5.72)

# Note that we have specify the nearest-neighbor atoms being seperated by 5.72 ``\mu m`` in order to prepare a ``Z_2`` ordered state. 
# With the waveforms and atomic coordinate specified, the time-dependent Hamiltonian can be simply generated by the following

h = rydberg_h(atoms; Δ, Ω)

# We then specify all atoms to be in ground state initially, and set up the emulation problem by choosing the ODE solver

reg = zero_state(9)
prob = SchrodingerProblem(reg, total_time, h; dt=1e-5, adaptive=false)
integrator = init(prob, Vern8())
# We measure the Rydberg density for each site and time step

densities = []
for _ in integrator
    push!(densities, [expect(put(nsites, i=>Op.n), reg) for i in 1:nsites])
end
D = hcat(densities...)

# Finally, we plot the time-dependent dynamics of Rydberg density for each site

clocks = [t for t in 0:1e-5:total_time]
heatmap(clocks, 1:9, D'; axis=(xlabel="iterations", ylabel="rydberg density per site"))

# We can clearly see that a ``Z_2`` ordered state has been generated by following the adiabatic pulse sequence. 
# We can also confirm this by plotting out the bitstring distribution at the final time step

bitstring_histgram(reg; nlargest=20)

# To prepare ``Z_3`` (``Z_4``) states, we can reduce the seperation between nearby atoms to 3.57 ``\mu m`` (2.87 ``\mu m``). 

# # Run in the blockade subspace  

# In the above example, we have run the emulation in fullspace, which can be slow and only works in small system. We can turn the above simulation into a blockade subspace simulation 
# by changing the register to a RydbergReg by feeding a subspace object

# The subspace can be found by looking up the independent set of the graph constructed by a blockade radius, here we choose the radius to be 6.2 ``\mu m``

space = blockade_subspace(atoms, 6.2)

# Then we create our register in subspace

reg = zero_state(space)

# The rest of code will be the same as the full space 

prob = SchrodingerProblem(reg, total_time, h)
emulate!(prob)
bitstring_histgram(prob.reg; nlargest=20)


# # State preparation in 2D

#  Now we will show how to prepare a 2D checkboard phase. Most of codes will be the same as the 1D case, except that we will choose slightly different 
# parameters and specify a square lattice 

nx, ny = 3, 3
nsites = nx*ny
atoms = generate_sites(SquareLattice(), nx, ny, scale=6.7)

total_time = 2.9
Ω_max = 2π * 4.3
Ω = piecewise_linear(clocks=[0.0, 0.3, 2.6, total_time], values=[0.0, Ω_max , Ω_max , 0])
draw(Ω)

U = 2π * 15.0
Δ = piecewise_linear(clocks=[0.0, 0.3, 2.6, total_time], values=[-U, -U, U , U])
draw(Δ)

h = rydberg_h(atoms; Δ, Ω)


reg = zero_state(9)
prob = SchrodingerProblem(reg, total_time, h)
integrator = init(prob, Vern8())
densities = []

# If you are using adaptive steps (by default),
# you can use `TimeChoiceIterator` to specify the
# points you would like to stop by
for _ in TimeChoiceIterator(integrator, 0.0:1e-3:total_time)
    push!(densities, [expect(put(nsites, i=>Op.n), reg) for i in 1:nsites])
end
D = hcat(densities...)

clocks = [t for t in 0:1e-3:total_time]
heatmap(clocks, 1:9, D'; axis=(xlabel="iterations", ylabel="rydberg density per site"))
